; Listing generated by Microsoft (R) Optimizing Compiler Version 19.35.32217.1 

	TITLE	C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\Debug\DeduceMove.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG225979 DB	'Deduce Move', 00H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0VECTOR@@QAE@XZ				; VECTOR::VECTOR
PUBLIC	??4VECTOR@@QAEAAV0@ABUtagPOINT@@@Z		; VECTOR::operator=
PUBLIC	??9VECTOR@@QAE_NABV0@@Z				; VECTOR::operator!=
PUBLIC	?Size@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ	; DOTS_AND_BOXES::Size
PUBLIC	?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
PUBLIC	?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::VLineType
PUBLIC	?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
PUBLIC	?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::HLineType
PUBLIC	??0MOVE@@QAE@XZ					; MOVE::MOVE
PUBLIC	?DeduceMove@@YA?AUMOVE@@PAVDOTS_AND_BOXES@@PBVCON@@W4MOVE_TYPE@@@Z ; DeduceMove
PUBLIC	?FollowChain@@YA?AUMOVE@@PAVDOTS_AND_BOXES@@VVECTOR@@U1@@Z ; FollowChain
PUBLIC	?LocateChainEnds@@YAXPAVDOTS_AND_BOXES@@PAUMOVE@@H@Z ; LocateChainEnds
PUBLIC	?LocatePenultimateLine@@YA?AUMOVE@@PAVDOTS_AND_BOXES@@PAU1@@Z ; LocatePenultimateLine
EXTRN	?NotImplemented@@YAXPAD@Z:PROC			; NotImplemented
EXTRN	?FindCaptures@MOVE@@QAEXPAVDOTS_AND_BOXES@@@Z:PROC ; MOVE::FindCaptures
EXTRN	?ConstructFromLineNumber@MOVE@@QAEXH@Z:PROC	; MOVE::ConstructFromLineNumber
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?LocatePenultimateLine@@YA?AUMOVE@@PAVDOTS_AND_BOXES@@PAU1@@Z
	DD	01eH
	DD	03c4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?LocateChainEnds@@YAXPAVDOTS_AND_BOXES@@PAUMOVE@@H@Z
	DD	024H
	DD	0246H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?FollowChain@@YA?AUMOVE@@PAVDOTS_AND_BOXES@@VVECTOR@@U1@@Z
	DD	024H
	DD	02b4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?DeduceMove@@YA?AUMOVE@@PAVDOTS_AND_BOXES@@PBVCON@@W4MOVE_TYPE@@@Z
	DD	01eH
	DD	06cH
voltbl	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\DeduceMove.cpp
_TEXT	SEGMENT
$T1 = -112						; size = 8
_size$ = -100						; size = 8
_n$ = -88						; size = 4
_result$ = -80						; size = 56
_point$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
__$ReturnAddress$ = 8					; size = 4
_pGame$ = 12						; size = 4
_pMove$ = 16						; size = 4
?LocatePenultimateLine@@YA?AUMOVE@@PAVDOTS_AND_BOXES@@PAU1@@Z PROC ; LocatePenultimateLine

; 113  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d 90	 lea	 edi, DWORD PTR [ebp-112]
  0000b	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 114  :   //Given the 'Ultimate' line in a chain of boxes,
; 115  :   //attempt to locate the 'Penultimate' line.  If the
; 116  :   //chain is zero boxes long then the result is the
; 117  :   //same as the 'Ultimate' line.
; 118  :   //
; 119  :   //Look on both sides of the 'Ultimate' line.  If a 
; 120  :   //box on one side or the other has exactly two
; 121  :   //open sides then choose the other and return;
; 122  :   VECTOR point;

  00021	8d 4d f0	 lea	 ecx, DWORD PTR _point$[ebp]
  00024	e8 00 00 00 00	 call	 ??0VECTOR@@QAE@XZ	; VECTOR::VECTOR

; 123  :   MOVE result;

  00029	8d 4d b0	 lea	 ecx, DWORD PTR _result$[ebp]
  0002c	e8 00 00 00 00	 call	 ??0MOVE@@QAE@XZ

; 124  :   ui n;
; 125  :   VECTOR size;

  00031	8d 4d 9c	 lea	 ecx, DWORD PTR _size$[ebp]
  00034	e8 00 00 00 00	 call	 ??0VECTOR@@QAE@XZ	; VECTOR::VECTOR

; 126  :   size = pGame->Size();

  00039	8d 45 90	 lea	 eax, DWORD PTR $T1[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR _pGame$[ebp]
  00040	e8 00 00 00 00	 call	 ?Size@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ ; DOTS_AND_BOXES::Size
  00045	50		 push	 eax
  00046	8d 4d 9c	 lea	 ecx, DWORD PTR _size$[ebp]
  00049	e8 00 00 00 00	 call	 ??4VECTOR@@QAEAAV0@ABUtagPOINT@@@Z ; VECTOR::operator=

; 127  :   if (pMove->vertical)

  0004e	8b 4d 10	 mov	 ecx, DWORD PTR _pMove$[ebp]
  00051	0f b6 51 08	 movzx	 edx, BYTE PTR [ecx+8]
  00055	85 d2		 test	 edx, edx
  00057	0f 84 a5 01 00
	00		 je	 $LN2@LocatePenu

; 128  :   {
; 129  :     //Look at the boxes to the left and right.
; 130  :     if (pMove->dotNum.x > 0)

  0005d	8b 45 10	 mov	 eax, DWORD PTR _pMove$[ebp]
  00060	83 38 00	 cmp	 DWORD PTR [eax], 0
  00063	0f 8e bd 00 00
	00		 jle	 $LN4@LocatePenu

; 131  :     { //Look to the left
; 132  :       n = 0;

  00069	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 133  :       point = pMove->dotNum;

  00070	8b 4d 10	 mov	 ecx, DWORD PTR _pMove$[ebp]
  00073	8b 11		 mov	 edx, DWORD PTR [ecx]
  00075	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00078	89 55 f0	 mov	 DWORD PTR _point$[ebp], edx
  0007b	89 45 f4	 mov	 DWORD PTR _point$[ebp+4], eax

; 134  :       point.x--;

  0007e	8b 4d f0	 mov	 ecx, DWORD PTR _point$[ebp]
  00081	83 e9 01	 sub	 ecx, 1
  00084	89 4d f0	 mov	 DWORD PTR _point$[ebp], ecx

; 135  :       if (pGame->HLineType(point) == LINE_NONE)

  00087	8d 55 f0	 lea	 edx, DWORD PTR _point$[ebp]
  0008a	52		 push	 edx
  0008b	8b 4d 0c	 mov	 ecx, DWORD PTR _pGame$[ebp]
  0008e	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::HLineType
  00093	85 c0		 test	 eax, eax
  00095	75 19		 jne	 SHORT $LN5@LocatePenu

; 136  :       {
; 137  :         n++;

  00097	8b 45 a8	 mov	 eax, DWORD PTR _n$[ebp]
  0009a	83 c0 01	 add	 eax, 1
  0009d	89 45 a8	 mov	 DWORD PTR _n$[ebp], eax

; 138  :         result.dotNum = point;

  000a0	8b 4d f0	 mov	 ecx, DWORD PTR _point$[ebp]
  000a3	8b 55 f4	 mov	 edx, DWORD PTR _point$[ebp+4]
  000a6	89 4d b0	 mov	 DWORD PTR _result$[ebp], ecx
  000a9	89 55 b4	 mov	 DWORD PTR _result$[ebp+4], edx

; 139  :         result.vertical = false;

  000ac	c6 45 b8 00	 mov	 BYTE PTR _result$[ebp+8], 0
$LN5@LocatePenu:

; 140  :       };
; 141  :       if (pGame->VLineType(point) == LINE_NONE)

  000b0	8d 45 f0	 lea	 eax, DWORD PTR _point$[ebp]
  000b3	50		 push	 eax
  000b4	8b 4d 0c	 mov	 ecx, DWORD PTR _pGame$[ebp]
  000b7	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::VLineType
  000bc	85 c0		 test	 eax, eax
  000be	75 19		 jne	 SHORT $LN6@LocatePenu

; 142  :       {
; 143  :         n++;

  000c0	8b 4d a8	 mov	 ecx, DWORD PTR _n$[ebp]
  000c3	83 c1 01	 add	 ecx, 1
  000c6	89 4d a8	 mov	 DWORD PTR _n$[ebp], ecx

; 144  :         result.dotNum = point;

  000c9	8b 55 f0	 mov	 edx, DWORD PTR _point$[ebp]
  000cc	8b 45 f4	 mov	 eax, DWORD PTR _point$[ebp+4]
  000cf	89 55 b0	 mov	 DWORD PTR _result$[ebp], edx
  000d2	89 45 b4	 mov	 DWORD PTR _result$[ebp+4], eax

; 145  :         result.vertical = true;

  000d5	c6 45 b8 01	 mov	 BYTE PTR _result$[ebp+8], 1
$LN6@LocatePenu:

; 146  :       };
; 147  :       point.y++;

  000d9	8b 4d f4	 mov	 ecx, DWORD PTR _point$[ebp+4]
  000dc	83 c1 01	 add	 ecx, 1
  000df	89 4d f4	 mov	 DWORD PTR _point$[ebp+4], ecx

; 148  :       if (pGame->HLineType(point) == LINE_NONE)

  000e2	8d 55 f0	 lea	 edx, DWORD PTR _point$[ebp]
  000e5	52		 push	 edx
  000e6	8b 4d 0c	 mov	 ecx, DWORD PTR _pGame$[ebp]
  000e9	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::HLineType
  000ee	85 c0		 test	 eax, eax
  000f0	75 19		 jne	 SHORT $LN7@LocatePenu

; 149  :       {
; 150  :         n++;

  000f2	8b 45 a8	 mov	 eax, DWORD PTR _n$[ebp]
  000f5	83 c0 01	 add	 eax, 1
  000f8	89 45 a8	 mov	 DWORD PTR _n$[ebp], eax

; 151  :         result.dotNum = point;

  000fb	8b 4d f0	 mov	 ecx, DWORD PTR _point$[ebp]
  000fe	8b 55 f4	 mov	 edx, DWORD PTR _point$[ebp+4]
  00101	89 4d b0	 mov	 DWORD PTR _result$[ebp], ecx
  00104	89 55 b4	 mov	 DWORD PTR _result$[ebp+4], edx

; 152  :         result.vertical = false;

  00107	c6 45 b8 00	 mov	 BYTE PTR _result$[ebp+8], 0
$LN7@LocatePenu:

; 153  :       };
; 154  :       if (n==1) return result;

  0010b	83 7d a8 01	 cmp	 DWORD PTR _n$[ebp], 1
  0010f	75 15		 jne	 SHORT $LN4@LocatePenu
  00111	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  00116	8d 75 b0	 lea	 esi, DWORD PTR _result$[ebp]
  00119	8b 7d 08	 mov	 edi, DWORD PTR __$ReturnAddress$[ebp]
  0011c	f3 a5		 rep movsd
  0011e	8b 45 08	 mov	 eax, DWORD PTR __$ReturnAddress$[ebp]
  00121	e9 8b 02 00 00	 jmp	 $LN1@LocatePenu
$LN4@LocatePenu:

; 155  :     };
; 156  :     if (pMove->dotNum.x < size.x-1)

  00126	8b 45 9c	 mov	 eax, DWORD PTR _size$[ebp]
  00129	83 e8 01	 sub	 eax, 1
  0012c	8b 4d 10	 mov	 ecx, DWORD PTR _pMove$[ebp]
  0012f	39 01		 cmp	 DWORD PTR [ecx], eax
  00131	0f 8d c6 00 00
	00		 jge	 $LN9@LocatePenu

; 157  :     { //Look to the right
; 158  :       n = 0;

  00137	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 159  :       point = pMove->dotNum;

  0013e	8b 55 10	 mov	 edx, DWORD PTR _pMove$[ebp]
  00141	8b 02		 mov	 eax, DWORD PTR [edx]
  00143	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00146	89 45 f0	 mov	 DWORD PTR _point$[ebp], eax
  00149	89 4d f4	 mov	 DWORD PTR _point$[ebp+4], ecx

; 160  :       if (pGame->HLineType(point) == LINE_NONE)

  0014c	8d 55 f0	 lea	 edx, DWORD PTR _point$[ebp]
  0014f	52		 push	 edx
  00150	8b 4d 0c	 mov	 ecx, DWORD PTR _pGame$[ebp]
  00153	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::HLineType
  00158	85 c0		 test	 eax, eax
  0015a	75 19		 jne	 SHORT $LN10@LocatePenu

; 161  :       {
; 162  :         n++;

  0015c	8b 45 a8	 mov	 eax, DWORD PTR _n$[ebp]
  0015f	83 c0 01	 add	 eax, 1
  00162	89 45 a8	 mov	 DWORD PTR _n$[ebp], eax

; 163  :         result.dotNum = point;

  00165	8b 4d f0	 mov	 ecx, DWORD PTR _point$[ebp]
  00168	8b 55 f4	 mov	 edx, DWORD PTR _point$[ebp+4]
  0016b	89 4d b0	 mov	 DWORD PTR _result$[ebp], ecx
  0016e	89 55 b4	 mov	 DWORD PTR _result$[ebp+4], edx

; 164  :         result.vertical = false;

  00171	c6 45 b8 00	 mov	 BYTE PTR _result$[ebp+8], 0
$LN10@LocatePenu:

; 165  :       };
; 166  :       point.x++;

  00175	8b 45 f0	 mov	 eax, DWORD PTR _point$[ebp]
  00178	83 c0 01	 add	 eax, 1
  0017b	89 45 f0	 mov	 DWORD PTR _point$[ebp], eax

; 167  :       if (pGame->VLineType(point) == LINE_NONE)

  0017e	8d 4d f0	 lea	 ecx, DWORD PTR _point$[ebp]
  00181	51		 push	 ecx
  00182	8b 4d 0c	 mov	 ecx, DWORD PTR _pGame$[ebp]
  00185	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::VLineType
  0018a	85 c0		 test	 eax, eax
  0018c	75 19		 jne	 SHORT $LN11@LocatePenu

; 168  :       {
; 169  :         n++;

  0018e	8b 55 a8	 mov	 edx, DWORD PTR _n$[ebp]
  00191	83 c2 01	 add	 edx, 1
  00194	89 55 a8	 mov	 DWORD PTR _n$[ebp], edx

; 170  :         result.dotNum = point;

  00197	8b 45 f0	 mov	 eax, DWORD PTR _point$[ebp]
  0019a	8b 4d f4	 mov	 ecx, DWORD PTR _point$[ebp+4]
  0019d	89 45 b0	 mov	 DWORD PTR _result$[ebp], eax
  001a0	89 4d b4	 mov	 DWORD PTR _result$[ebp+4], ecx

; 171  :         result.vertical = true;

  001a3	c6 45 b8 01	 mov	 BYTE PTR _result$[ebp+8], 1
$LN11@LocatePenu:

; 172  :       };
; 173  :       point.y++; point.x--;

  001a7	8b 55 f4	 mov	 edx, DWORD PTR _point$[ebp+4]
  001aa	83 c2 01	 add	 edx, 1
  001ad	89 55 f4	 mov	 DWORD PTR _point$[ebp+4], edx
  001b0	8b 45 f0	 mov	 eax, DWORD PTR _point$[ebp]
  001b3	83 e8 01	 sub	 eax, 1
  001b6	89 45 f0	 mov	 DWORD PTR _point$[ebp], eax

; 174  :       if (pGame->HLineType(point) == LINE_NONE)

  001b9	8d 4d f0	 lea	 ecx, DWORD PTR _point$[ebp]
  001bc	51		 push	 ecx
  001bd	8b 4d 0c	 mov	 ecx, DWORD PTR _pGame$[ebp]
  001c0	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::HLineType
  001c5	85 c0		 test	 eax, eax
  001c7	75 19		 jne	 SHORT $LN12@LocatePenu

; 175  :       {
; 176  :         n++;

  001c9	8b 55 a8	 mov	 edx, DWORD PTR _n$[ebp]
  001cc	83 c2 01	 add	 edx, 1
  001cf	89 55 a8	 mov	 DWORD PTR _n$[ebp], edx

; 177  :         result.dotNum = point;

  001d2	8b 45 f0	 mov	 eax, DWORD PTR _point$[ebp]
  001d5	8b 4d f4	 mov	 ecx, DWORD PTR _point$[ebp+4]
  001d8	89 45 b0	 mov	 DWORD PTR _result$[ebp], eax
  001db	89 4d b4	 mov	 DWORD PTR _result$[ebp+4], ecx

; 178  :         result.vertical = false;

  001de	c6 45 b8 00	 mov	 BYTE PTR _result$[ebp+8], 0
$LN12@LocatePenu:

; 179  :       };
; 180  :       if (n==1) return result;

  001e2	83 7d a8 01	 cmp	 DWORD PTR _n$[ebp], 1
  001e6	75 15		 jne	 SHORT $LN9@LocatePenu
  001e8	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  001ed	8d 75 b0	 lea	 esi, DWORD PTR _result$[ebp]
  001f0	8b 7d 08	 mov	 edi, DWORD PTR __$ReturnAddress$[ebp]
  001f3	f3 a5		 rep movsd
  001f5	8b 45 08	 mov	 eax, DWORD PTR __$ReturnAddress$[ebp]
  001f8	e9 b4 01 00 00	 jmp	 $LN1@LocatePenu
$LN9@LocatePenu:

; 181  :     };
; 182  :   }

  001fd	e9 9f 01 00 00	 jmp	 $LN3@LocatePenu
$LN2@LocatePenu:

; 183  :   else
; 184  :   {
; 185  :     //Look at the boxes above and below.
; 186  :     if (pMove->dotNum.y > 0)

  00202	8b 55 10	 mov	 edx, DWORD PTR _pMove$[ebp]
  00205	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00209	0f 8e bd 00 00
	00		 jle	 $LN14@LocatePenu

; 187  :     { //Look above
; 188  :       n = 0;

  0020f	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 189  :       point = pMove->dotNum;

  00216	8b 45 10	 mov	 eax, DWORD PTR _pMove$[ebp]
  00219	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0021e	89 4d f0	 mov	 DWORD PTR _point$[ebp], ecx
  00221	89 55 f4	 mov	 DWORD PTR _point$[ebp+4], edx

; 190  :       point.y--;

  00224	8b 45 f4	 mov	 eax, DWORD PTR _point$[ebp+4]
  00227	83 e8 01	 sub	 eax, 1
  0022a	89 45 f4	 mov	 DWORD PTR _point$[ebp+4], eax

; 191  :       if (pGame->HLineType(point) == LINE_NONE)

  0022d	8d 4d f0	 lea	 ecx, DWORD PTR _point$[ebp]
  00230	51		 push	 ecx
  00231	8b 4d 0c	 mov	 ecx, DWORD PTR _pGame$[ebp]
  00234	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::HLineType
  00239	85 c0		 test	 eax, eax
  0023b	75 19		 jne	 SHORT $LN15@LocatePenu

; 192  :       {
; 193  :         n++;

  0023d	8b 55 a8	 mov	 edx, DWORD PTR _n$[ebp]
  00240	83 c2 01	 add	 edx, 1
  00243	89 55 a8	 mov	 DWORD PTR _n$[ebp], edx

; 194  :         result.dotNum = point;

  00246	8b 45 f0	 mov	 eax, DWORD PTR _point$[ebp]
  00249	8b 4d f4	 mov	 ecx, DWORD PTR _point$[ebp+4]
  0024c	89 45 b0	 mov	 DWORD PTR _result$[ebp], eax
  0024f	89 4d b4	 mov	 DWORD PTR _result$[ebp+4], ecx

; 195  :         result.vertical = false;

  00252	c6 45 b8 00	 mov	 BYTE PTR _result$[ebp+8], 0
$LN15@LocatePenu:

; 196  :       };
; 197  :       if (pGame->VLineType(point) == LINE_NONE)

  00256	8d 55 f0	 lea	 edx, DWORD PTR _point$[ebp]
  00259	52		 push	 edx
  0025a	8b 4d 0c	 mov	 ecx, DWORD PTR _pGame$[ebp]
  0025d	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::VLineType
  00262	85 c0		 test	 eax, eax
  00264	75 19		 jne	 SHORT $LN16@LocatePenu

; 198  :       {
; 199  :         n++;

  00266	8b 45 a8	 mov	 eax, DWORD PTR _n$[ebp]
  00269	83 c0 01	 add	 eax, 1
  0026c	89 45 a8	 mov	 DWORD PTR _n$[ebp], eax

; 200  :         result.dotNum = point;

  0026f	8b 4d f0	 mov	 ecx, DWORD PTR _point$[ebp]
  00272	8b 55 f4	 mov	 edx, DWORD PTR _point$[ebp+4]
  00275	89 4d b0	 mov	 DWORD PTR _result$[ebp], ecx
  00278	89 55 b4	 mov	 DWORD PTR _result$[ebp+4], edx

; 201  :         result.vertical = true;

  0027b	c6 45 b8 01	 mov	 BYTE PTR _result$[ebp+8], 1
$LN16@LocatePenu:

; 202  :       };
; 203  :       point.x++;

  0027f	8b 45 f0	 mov	 eax, DWORD PTR _point$[ebp]
  00282	83 c0 01	 add	 eax, 1
  00285	89 45 f0	 mov	 DWORD PTR _point$[ebp], eax

; 204  :       if (pGame->VLineType(point) == LINE_NONE)

  00288	8d 4d f0	 lea	 ecx, DWORD PTR _point$[ebp]
  0028b	51		 push	 ecx
  0028c	8b 4d 0c	 mov	 ecx, DWORD PTR _pGame$[ebp]
  0028f	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::VLineType
  00294	85 c0		 test	 eax, eax
  00296	75 19		 jne	 SHORT $LN17@LocatePenu

; 205  :       {
; 206  :         n++;

  00298	8b 55 a8	 mov	 edx, DWORD PTR _n$[ebp]
  0029b	83 c2 01	 add	 edx, 1
  0029e	89 55 a8	 mov	 DWORD PTR _n$[ebp], edx

; 207  :         result.dotNum = point;

  002a1	8b 45 f0	 mov	 eax, DWORD PTR _point$[ebp]
  002a4	8b 4d f4	 mov	 ecx, DWORD PTR _point$[ebp+4]
  002a7	89 45 b0	 mov	 DWORD PTR _result$[ebp], eax
  002aa	89 4d b4	 mov	 DWORD PTR _result$[ebp+4], ecx

; 208  :         result.vertical = true;

  002ad	c6 45 b8 01	 mov	 BYTE PTR _result$[ebp+8], 1
$LN17@LocatePenu:

; 209  :       };
; 210  :       if (n==1) return result;

  002b1	83 7d a8 01	 cmp	 DWORD PTR _n$[ebp], 1
  002b5	75 15		 jne	 SHORT $LN14@LocatePenu
  002b7	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  002bc	8d 75 b0	 lea	 esi, DWORD PTR _result$[ebp]
  002bf	8b 7d 08	 mov	 edi, DWORD PTR __$ReturnAddress$[ebp]
  002c2	f3 a5		 rep movsd
  002c4	8b 45 08	 mov	 eax, DWORD PTR __$ReturnAddress$[ebp]
  002c7	e9 e5 00 00 00	 jmp	 $LN1@LocatePenu
$LN14@LocatePenu:

; 211  :     };
; 212  :     if (pMove->dotNum.y < size.y-1)

  002cc	8b 55 a0	 mov	 edx, DWORD PTR _size$[ebp+4]
  002cf	83 ea 01	 sub	 edx, 1
  002d2	8b 45 10	 mov	 eax, DWORD PTR _pMove$[ebp]
  002d5	39 50 04	 cmp	 DWORD PTR [eax+4], edx
  002d8	0f 8d c3 00 00
	00		 jge	 $LN3@LocatePenu

; 213  :     { //Look below
; 214  :       n = 0;

  002de	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 215  :       point = pMove->dotNum;

  002e5	8b 4d 10	 mov	 ecx, DWORD PTR _pMove$[ebp]
  002e8	8b 11		 mov	 edx, DWORD PTR [ecx]
  002ea	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  002ed	89 55 f0	 mov	 DWORD PTR _point$[ebp], edx
  002f0	89 45 f4	 mov	 DWORD PTR _point$[ebp+4], eax

; 216  :       if (pGame->VLineType(point) == LINE_NONE)

  002f3	8d 4d f0	 lea	 ecx, DWORD PTR _point$[ebp]
  002f6	51		 push	 ecx
  002f7	8b 4d 0c	 mov	 ecx, DWORD PTR _pGame$[ebp]
  002fa	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::VLineType
  002ff	85 c0		 test	 eax, eax
  00301	75 19		 jne	 SHORT $LN20@LocatePenu

; 217  :       {
; 218  :         n++;

  00303	8b 55 a8	 mov	 edx, DWORD PTR _n$[ebp]
  00306	83 c2 01	 add	 edx, 1
  00309	89 55 a8	 mov	 DWORD PTR _n$[ebp], edx

; 219  :         result.dotNum = point;

  0030c	8b 45 f0	 mov	 eax, DWORD PTR _point$[ebp]
  0030f	8b 4d f4	 mov	 ecx, DWORD PTR _point$[ebp+4]
  00312	89 45 b0	 mov	 DWORD PTR _result$[ebp], eax
  00315	89 4d b4	 mov	 DWORD PTR _result$[ebp+4], ecx

; 220  :         result.vertical = true;

  00318	c6 45 b8 01	 mov	 BYTE PTR _result$[ebp+8], 1
$LN20@LocatePenu:

; 221  :       };
; 222  :       point.x++;

  0031c	8b 55 f0	 mov	 edx, DWORD PTR _point$[ebp]
  0031f	83 c2 01	 add	 edx, 1
  00322	89 55 f0	 mov	 DWORD PTR _point$[ebp], edx

; 223  :       if (pGame->VLineType(point) == LINE_NONE)

  00325	8d 45 f0	 lea	 eax, DWORD PTR _point$[ebp]
  00328	50		 push	 eax
  00329	8b 4d 0c	 mov	 ecx, DWORD PTR _pGame$[ebp]
  0032c	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::VLineType
  00331	85 c0		 test	 eax, eax
  00333	75 19		 jne	 SHORT $LN21@LocatePenu

; 224  :       {
; 225  :         n++;

  00335	8b 4d a8	 mov	 ecx, DWORD PTR _n$[ebp]
  00338	83 c1 01	 add	 ecx, 1
  0033b	89 4d a8	 mov	 DWORD PTR _n$[ebp], ecx

; 226  :         result.dotNum = point;

  0033e	8b 55 f0	 mov	 edx, DWORD PTR _point$[ebp]
  00341	8b 45 f4	 mov	 eax, DWORD PTR _point$[ebp+4]
  00344	89 55 b0	 mov	 DWORD PTR _result$[ebp], edx
  00347	89 45 b4	 mov	 DWORD PTR _result$[ebp+4], eax

; 227  :         result.vertical = true;

  0034a	c6 45 b8 01	 mov	 BYTE PTR _result$[ebp+8], 1
$LN21@LocatePenu:

; 228  :       };
; 229  :       point.y++; point.x--;

  0034e	8b 4d f4	 mov	 ecx, DWORD PTR _point$[ebp+4]
  00351	83 c1 01	 add	 ecx, 1
  00354	89 4d f4	 mov	 DWORD PTR _point$[ebp+4], ecx
  00357	8b 55 f0	 mov	 edx, DWORD PTR _point$[ebp]
  0035a	83 ea 01	 sub	 edx, 1
  0035d	89 55 f0	 mov	 DWORD PTR _point$[ebp], edx

; 230  :       if (pGame->HLineType(point) == LINE_NONE)

  00360	8d 45 f0	 lea	 eax, DWORD PTR _point$[ebp]
  00363	50		 push	 eax
  00364	8b 4d 0c	 mov	 ecx, DWORD PTR _pGame$[ebp]
  00367	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::HLineType
  0036c	85 c0		 test	 eax, eax
  0036e	75 19		 jne	 SHORT $LN22@LocatePenu

; 231  :       {
; 232  :         n++;

  00370	8b 4d a8	 mov	 ecx, DWORD PTR _n$[ebp]
  00373	83 c1 01	 add	 ecx, 1
  00376	89 4d a8	 mov	 DWORD PTR _n$[ebp], ecx

; 233  :         result.dotNum = point;

  00379	8b 55 f0	 mov	 edx, DWORD PTR _point$[ebp]
  0037c	8b 45 f4	 mov	 eax, DWORD PTR _point$[ebp+4]
  0037f	89 55 b0	 mov	 DWORD PTR _result$[ebp], edx
  00382	89 45 b4	 mov	 DWORD PTR _result$[ebp+4], eax

; 234  :         result.vertical = false;

  00385	c6 45 b8 00	 mov	 BYTE PTR _result$[ebp+8], 0
$LN22@LocatePenu:

; 235  :       };
; 236  :       if (n==1) return result;

  00389	83 7d a8 01	 cmp	 DWORD PTR _n$[ebp], 1
  0038d	75 12		 jne	 SHORT $LN3@LocatePenu
  0038f	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  00394	8d 75 b0	 lea	 esi, DWORD PTR _result$[ebp]
  00397	8b 7d 08	 mov	 edi, DWORD PTR __$ReturnAddress$[ebp]
  0039a	f3 a5		 rep movsd
  0039c	8b 45 08	 mov	 eax, DWORD PTR __$ReturnAddress$[ebp]
  0039f	eb 10		 jmp	 SHORT $LN1@LocatePenu
$LN3@LocatePenu:

; 237  :     };
; 238  :   };
; 239  :   return *pMove;

  003a1	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  003a6	8b 75 10	 mov	 esi, DWORD PTR _pMove$[ebp]
  003a9	8b 7d 08	 mov	 edi, DWORD PTR __$ReturnAddress$[ebp]
  003ac	f3 a5		 rep movsd
  003ae	8b 45 08	 mov	 eax, DWORD PTR __$ReturnAddress$[ebp]
$LN1@LocatePenu:

; 240  : }

  003b1	52		 push	 edx
  003b2	8b cd		 mov	 ecx, ebp
  003b4	50		 push	 eax
  003b5	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN29@LocatePenu
  003bb	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003c0	58		 pop	 eax
  003c1	5a		 pop	 edx
  003c2	5f		 pop	 edi
  003c3	5e		 pop	 esi
  003c4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c7	33 cd		 xor	 ecx, ebp
  003c9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003ce	83 c4 70	 add	 esp, 112		; 00000070H
  003d1	3b ec		 cmp	 ebp, esp
  003d3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003d8	8b e5		 mov	 esp, ebp
  003da	5d		 pop	 ebp
  003db	c3		 ret	 0
$LN29@LocatePenu:
  003dc	03 00 00 00	 DD	 3
  003e0	00 00 00 00	 DD	 $LN28@LocatePenu
$LN28@LocatePenu:
  003e4	f0 ff ff ff	 DD	 -16			; fffffff0H
  003e8	08 00 00 00	 DD	 8
  003ec	00 00 00 00	 DD	 $LN25@LocatePenu
  003f0	b0 ff ff ff	 DD	 -80			; ffffffb0H
  003f4	38 00 00 00	 DD	 56			; 00000038H
  003f8	00 00 00 00	 DD	 $LN26@LocatePenu
  003fc	9c ff ff ff	 DD	 -100			; ffffff9cH
  00400	08 00 00 00	 DD	 8
  00404	00 00 00 00	 DD	 $LN27@LocatePenu
$LN27@LocatePenu:
  00408	73		 DB	 115			; 00000073H
  00409	69		 DB	 105			; 00000069H
  0040a	7a		 DB	 122			; 0000007aH
  0040b	65		 DB	 101			; 00000065H
  0040c	00		 DB	 0
$LN26@LocatePenu:
  0040d	72		 DB	 114			; 00000072H
  0040e	65		 DB	 101			; 00000065H
  0040f	73		 DB	 115			; 00000073H
  00410	75		 DB	 117			; 00000075H
  00411	6c		 DB	 108			; 0000006cH
  00412	74		 DB	 116			; 00000074H
  00413	00		 DB	 0
$LN25@LocatePenu:
  00414	70		 DB	 112			; 00000070H
  00415	6f		 DB	 111			; 0000006fH
  00416	69		 DB	 105			; 00000069H
  00417	6e		 DB	 110			; 0000006eH
  00418	74		 DB	 116			; 00000074H
  00419	00		 DB	 0
?LocatePenultimateLine@@YA?AUMOVE@@PAVDOTS_AND_BOXES@@PAU1@@Z ENDP ; LocatePenultimateLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\DeduceMove.cpp
_TEXT	SEGMENT
$T1 = -596						; size = 56
$T2 = -540						; size = 56
$T3 = -484						; size = 56
$T4 = -428						; size = 56
$T5 = -372						; size = 56
$T6 = -316						; size = 56
$T7 = -260						; size = 56
$T8 = -204						; size = 56
_thisBox$ = -144					; size = 8
_thisLine$ = -128					; size = 56
_move$ = -64						; size = 56
__$ArrayPad$ = -4					; size = 4
_pGame$ = 8						; size = 4
_pMove$ = 12						; size = 4
_computerMove$ = 16					; size = 4
?LocateChainEnds@@YAXPAVDOTS_AND_BOXES@@PAUMOVE@@H@Z PROC ; LocateChainEnds

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 54 02 00
	00		 sub	 esp, 596		; 00000254H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd ac fd ff
	ff		 lea	 edi, DWORD PTR [ebp-596]
  00011	b9 95 00 00 00	 mov	 ecx, 149		; 00000095H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 85   :   MOVE move;

  00027	8d 4d c0	 lea	 ecx, DWORD PTR _move$[ebp]
  0002a	e8 00 00 00 00	 call	 ??0MOVE@@QAE@XZ

; 86   :   MOVE thisLine;

  0002f	8d 4d 80	 lea	 ecx, DWORD PTR _thisLine$[ebp]
  00032	e8 00 00 00 00	 call	 ??0MOVE@@QAE@XZ

; 87   :   VECTOR thisBox;

  00037	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _thisBox$[ebp]
  0003d	e8 00 00 00 00	 call	 ??0VECTOR@@QAE@XZ	; VECTOR::VECTOR

; 88   :   move.ConstructFromLineNumber(computerMove);

  00042	8b 45 10	 mov	 eax, DWORD PTR _computerMove$[ebp]
  00045	50		 push	 eax
  00046	8d 4d c0	 lea	 ecx, DWORD PTR _move$[ebp]
  00049	e8 00 00 00 00	 call	 ?ConstructFromLineNumber@MOVE@@QAEXH@Z ; MOVE::ConstructFromLineNumber

; 89   :   move.oldLineType = LINE_NONE;

  0004e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _move$[ebp+44], 0

; 90   :   move.newLineType = LINE_COMPUTER;

  00055	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _move$[ebp+48], 1

; 91   :   thisLine.oldLineType = LINE_NONE;

  0005c	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _thisLine$[ebp+44], 0

; 92   :   thisLine.newLineType = LINE_COMPUTER;

  00063	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _thisLine$[ebp+48], 1

; 93   :   if (move.vertical)

  0006a	0f b6 4d c8	 movzx	 ecx, BYTE PTR _move$[ebp+8]
  0006e	85 c9		 test	 ecx, ecx
  00070	0f 84 e1 00 00
	00		 je	 $LN2@LocateChai

; 94   :   {
; 95   :     thisBox = move.dotNum;

  00076	8b 55 c0	 mov	 edx, DWORD PTR _move$[ebp]
  00079	8b 45 c4	 mov	 eax, DWORD PTR _move$[ebp+4]
  0007c	89 95 70 ff ff
	ff		 mov	 DWORD PTR _thisBox$[ebp], edx
  00082	89 85 74 ff ff
	ff		 mov	 DWORD PTR _thisBox$[ebp+4], eax

; 96   :     thisLine = move;

  00088	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  0008d	8d 75 c0	 lea	 esi, DWORD PTR _move$[ebp]
  00090	8d 7d 80	 lea	 edi, DWORD PTR _thisLine$[ebp]
  00093	f3 a5		 rep movsd

; 97   :     pMove[0] = FollowChain(pGame, thisBox, thisLine);

  00095	83 ec 38	 sub	 esp, 56			; 00000038H
  00098	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  0009d	8d 75 80	 lea	 esi, DWORD PTR _thisLine$[ebp]
  000a0	8b fc		 mov	 edi, esp
  000a2	f3 a5		 rep movsd
  000a4	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _thisBox$[ebp+4]
  000aa	51		 push	 ecx
  000ab	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _thisBox$[ebp]
  000b1	52		 push	 edx
  000b2	8b 45 08	 mov	 eax, DWORD PTR _pGame$[ebp]
  000b5	50		 push	 eax
  000b6	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  000bc	51		 push	 ecx
  000bd	e8 00 00 00 00	 call	 ?FollowChain@@YA?AUMOVE@@PAVDOTS_AND_BOXES@@VVECTOR@@U1@@Z ; FollowChain
  000c2	83 c4 48	 add	 esp, 72			; 00000048H
  000c5	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  000ca	8b f0		 mov	 esi, eax
  000cc	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR $T8[ebp]
  000d2	f3 a5		 rep movsd
  000d4	ba 38 00 00 00	 mov	 edx, 56			; 00000038H
  000d9	6b fa 00	 imul	 edi, edx, 0
  000dc	03 7d 0c	 add	 edi, DWORD PTR _pMove$[ebp]
  000df	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  000e4	8d b5 34 ff ff
	ff		 lea	 esi, DWORD PTR $T8[ebp]
  000ea	f3 a5		 rep movsd

; 98   :     thisBox.x--;

  000ec	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _thisBox$[ebp]
  000f2	83 e8 01	 sub	 eax, 1
  000f5	89 85 70 ff ff
	ff		 mov	 DWORD PTR _thisBox$[ebp], eax

; 99   :     pMove[1] = FollowChain(pGame, thisBox, thisLine);

  000fb	83 ec 38	 sub	 esp, 56			; 00000038H
  000fe	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  00103	8d 75 80	 lea	 esi, DWORD PTR _thisLine$[ebp]
  00106	8b fc		 mov	 edi, esp
  00108	f3 a5		 rep movsd
  0010a	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _thisBox$[ebp+4]
  00110	51		 push	 ecx
  00111	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _thisBox$[ebp]
  00117	52		 push	 edx
  00118	8b 45 08	 mov	 eax, DWORD PTR _pGame$[ebp]
  0011b	50		 push	 eax
  0011c	8d 8d 1c fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00122	51		 push	 ecx
  00123	e8 00 00 00 00	 call	 ?FollowChain@@YA?AUMOVE@@PAVDOTS_AND_BOXES@@VVECTOR@@U1@@Z ; FollowChain
  00128	83 c4 48	 add	 esp, 72			; 00000048H
  0012b	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  00130	8b f0		 mov	 esi, eax
  00132	8d bd fc fe ff
	ff		 lea	 edi, DWORD PTR $T7[ebp]
  00138	f3 a5		 rep movsd
  0013a	bf 38 00 00 00	 mov	 edi, 56			; 00000038H
  0013f	c1 e7 00	 shl	 edi, 0
  00142	03 7d 0c	 add	 edi, DWORD PTR _pMove$[ebp]
  00145	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  0014a	8d b5 fc fe ff
	ff		 lea	 esi, DWORD PTR $T7[ebp]
  00150	f3 a5		 rep movsd

; 100  :   }

  00152	e9 dc 00 00 00	 jmp	 $LN1@LocateChai
$LN2@LocateChai:

; 101  :   else
; 102  :   {
; 103  :     thisBox = move.dotNum;

  00157	8b 55 c0	 mov	 edx, DWORD PTR _move$[ebp]
  0015a	8b 45 c4	 mov	 eax, DWORD PTR _move$[ebp+4]
  0015d	89 95 70 ff ff
	ff		 mov	 DWORD PTR _thisBox$[ebp], edx
  00163	89 85 74 ff ff
	ff		 mov	 DWORD PTR _thisBox$[ebp+4], eax

; 104  :     thisLine = move;

  00169	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  0016e	8d 75 c0	 lea	 esi, DWORD PTR _move$[ebp]
  00171	8d 7d 80	 lea	 edi, DWORD PTR _thisLine$[ebp]
  00174	f3 a5		 rep movsd

; 105  :     pMove[0] = FollowChain(pGame, thisBox, thisLine);

  00176	83 ec 38	 sub	 esp, 56			; 00000038H
  00179	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  0017e	8d 75 80	 lea	 esi, DWORD PTR _thisLine$[ebp]
  00181	8b fc		 mov	 edi, esp
  00183	f3 a5		 rep movsd
  00185	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _thisBox$[ebp+4]
  0018b	51		 push	 ecx
  0018c	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _thisBox$[ebp]
  00192	52		 push	 edx
  00193	8b 45 08	 mov	 eax, DWORD PTR _pGame$[ebp]
  00196	50		 push	 eax
  00197	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0019d	51		 push	 ecx
  0019e	e8 00 00 00 00	 call	 ?FollowChain@@YA?AUMOVE@@PAVDOTS_AND_BOXES@@VVECTOR@@U1@@Z ; FollowChain
  001a3	83 c4 48	 add	 esp, 72			; 00000048H
  001a6	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  001ab	8b f0		 mov	 esi, eax
  001ad	8d bd c4 fe ff
	ff		 lea	 edi, DWORD PTR $T6[ebp]
  001b3	f3 a5		 rep movsd
  001b5	ba 38 00 00 00	 mov	 edx, 56			; 00000038H
  001ba	6b fa 00	 imul	 edi, edx, 0
  001bd	03 7d 0c	 add	 edi, DWORD PTR _pMove$[ebp]
  001c0	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  001c5	8d b5 c4 fe ff
	ff		 lea	 esi, DWORD PTR $T6[ebp]
  001cb	f3 a5		 rep movsd

; 106  :     thisBox.y--;

  001cd	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _thisBox$[ebp+4]
  001d3	83 e8 01	 sub	 eax, 1
  001d6	89 85 74 ff ff
	ff		 mov	 DWORD PTR _thisBox$[ebp+4], eax

; 107  :     pMove[1] = FollowChain(pGame, thisBox, thisLine);

  001dc	83 ec 38	 sub	 esp, 56			; 00000038H
  001df	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  001e4	8d 75 80	 lea	 esi, DWORD PTR _thisLine$[ebp]
  001e7	8b fc		 mov	 edi, esp
  001e9	f3 a5		 rep movsd
  001eb	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _thisBox$[ebp+4]
  001f1	51		 push	 ecx
  001f2	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _thisBox$[ebp]
  001f8	52		 push	 edx
  001f9	8b 45 08	 mov	 eax, DWORD PTR _pGame$[ebp]
  001fc	50		 push	 eax
  001fd	8d 8d ac fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00203	51		 push	 ecx
  00204	e8 00 00 00 00	 call	 ?FollowChain@@YA?AUMOVE@@PAVDOTS_AND_BOXES@@VVECTOR@@U1@@Z ; FollowChain
  00209	83 c4 48	 add	 esp, 72			; 00000048H
  0020c	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  00211	8b f0		 mov	 esi, eax
  00213	8d bd 8c fe ff
	ff		 lea	 edi, DWORD PTR $T5[ebp]
  00219	f3 a5		 rep movsd
  0021b	bf 38 00 00 00	 mov	 edi, 56			; 00000038H
  00220	c1 e7 00	 shl	 edi, 0
  00223	03 7d 0c	 add	 edi, DWORD PTR _pMove$[ebp]
  00226	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  0022b	8d b5 8c fe ff
	ff		 lea	 esi, DWORD PTR $T5[ebp]
  00231	f3 a5		 rep movsd
$LN1@LocateChai:

; 108  :   };
; 109  : }

  00233	52		 push	 edx
  00234	8b cd		 mov	 ecx, ebp
  00236	50		 push	 eax
  00237	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@LocateChai
  0023d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00242	58		 pop	 eax
  00243	5a		 pop	 edx
  00244	5f		 pop	 edi
  00245	5e		 pop	 esi
  00246	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00249	33 cd		 xor	 ecx, ebp
  0024b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00250	81 c4 54 02 00
	00		 add	 esp, 596		; 00000254H
  00256	3b ec		 cmp	 ebp, esp
  00258	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0025d	8b e5		 mov	 esp, ebp
  0025f	5d		 pop	 ebp
  00260	c3		 ret	 0
  00261	0f 1f 00	 npad	 3
$LN9@LocateChai:
  00264	03 00 00 00	 DD	 3
  00268	00 00 00 00	 DD	 $LN8@LocateChai
$LN8@LocateChai:
  0026c	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00270	38 00 00 00	 DD	 56			; 00000038H
  00274	00 00 00 00	 DD	 $LN5@LocateChai
  00278	80 ff ff ff	 DD	 -128			; ffffff80H
  0027c	38 00 00 00	 DD	 56			; 00000038H
  00280	00 00 00 00	 DD	 $LN6@LocateChai
  00284	70 ff ff ff	 DD	 -144			; ffffff70H
  00288	08 00 00 00	 DD	 8
  0028c	00 00 00 00	 DD	 $LN7@LocateChai
$LN7@LocateChai:
  00290	74		 DB	 116			; 00000074H
  00291	68		 DB	 104			; 00000068H
  00292	69		 DB	 105			; 00000069H
  00293	73		 DB	 115			; 00000073H
  00294	42		 DB	 66			; 00000042H
  00295	6f		 DB	 111			; 0000006fH
  00296	78		 DB	 120			; 00000078H
  00297	00		 DB	 0
$LN6@LocateChai:
  00298	74		 DB	 116			; 00000074H
  00299	68		 DB	 104			; 00000068H
  0029a	69		 DB	 105			; 00000069H
  0029b	73		 DB	 115			; 00000073H
  0029c	4c		 DB	 76			; 0000004cH
  0029d	69		 DB	 105			; 00000069H
  0029e	6e		 DB	 110			; 0000006eH
  0029f	65		 DB	 101			; 00000065H
  002a0	00		 DB	 0
$LN5@LocateChai:
  002a1	6d		 DB	 109			; 0000006dH
  002a2	6f		 DB	 111			; 0000006fH
  002a3	76		 DB	 118			; 00000076H
  002a4	65		 DB	 101			; 00000065H
  002a5	00		 DB	 0
?LocateChainEnds@@YAXPAVDOTS_AND_BOXES@@PAUMOVE@@H@Z ENDP ; LocateChainEnds
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\DeduceMove.cpp
_TEXT	SEGMENT
$T1 = -192						; size = 8
_origLine$ = -180					; size = 56
_nextLine$ = -116					; size = 56
_numSide$ = -56						; size = 4
_nextBox$ = -48						; size = 8
_point$ = -32						; size = 8
_size$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
__$ReturnAddress$ = 8					; size = 4
_pGame$ = 12						; size = 4
_box$ = 16						; size = 8
_prevLine$ = 24						; size = 56
?FollowChain@@YA?AUMOVE@@PAVDOTS_AND_BOXES@@VVECTOR@@U1@@Z PROC ; FollowChain

; 8    : {// Keep following the chain of boxes until we find the

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00011	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 9    :  // last possible line that we can draw in the chain.
; 10   :   VECTOR size, point, nextBox;

  00027	8d 4d f0	 lea	 ecx, DWORD PTR _size$[ebp]
  0002a	e8 00 00 00 00	 call	 ??0VECTOR@@QAE@XZ	; VECTOR::VECTOR
  0002f	8d 4d e0	 lea	 ecx, DWORD PTR _point$[ebp]
  00032	e8 00 00 00 00	 call	 ??0VECTOR@@QAE@XZ	; VECTOR::VECTOR
  00037	8d 4d d0	 lea	 ecx, DWORD PTR _nextBox$[ebp]
  0003a	e8 00 00 00 00	 call	 ??0VECTOR@@QAE@XZ	; VECTOR::VECTOR

; 11   :   int numSide;
; 12   :   MOVE nextLine, origLine;

  0003f	8d 4d 8c	 lea	 ecx, DWORD PTR _nextLine$[ebp]
  00042	e8 00 00 00 00	 call	 ??0MOVE@@QAE@XZ
  00047	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _origLine$[ebp]
  0004d	e8 00 00 00 00	 call	 ??0MOVE@@QAE@XZ

; 13   :   origLine.dotNum = prevLine.dotNum;

  00052	8b 45 18	 mov	 eax, DWORD PTR _prevLine$[ebp]
  00055	8b 4d 1c	 mov	 ecx, DWORD PTR _prevLine$[ebp+4]
  00058	89 85 4c ff ff
	ff		 mov	 DWORD PTR _origLine$[ebp], eax
  0005e	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _origLine$[ebp+4], ecx

; 14   :   origLine.vertical = prevLine.vertical;

  00064	8a 55 20	 mov	 dl, BYTE PTR _prevLine$[ebp+8]
  00067	88 95 54 ff ff
	ff		 mov	 BYTE PTR _origLine$[ebp+8], dl

; 15   :   nextLine.oldLineType = prevLine.oldLineType;

  0006d	8b 45 44	 mov	 eax, DWORD PTR _prevLine$[ebp+44]
  00070	89 45 b8	 mov	 DWORD PTR _nextLine$[ebp+44], eax

; 16   :   nextLine.newLineType = prevLine.newLineType;

  00073	8b 4d 48	 mov	 ecx, DWORD PTR _prevLine$[ebp+48]
  00076	89 4d bc	 mov	 DWORD PTR _nextLine$[ebp+48], ecx

; 17   :   size = pGame->Size();

  00079	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  0007f	52		 push	 edx
  00080	8b 4d 0c	 mov	 ecx, DWORD PTR _pGame$[ebp]
  00083	e8 00 00 00 00	 call	 ?Size@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ ; DOTS_AND_BOXES::Size
  00088	50		 push	 eax
  00089	8d 4d f0	 lea	 ecx, DWORD PTR _size$[ebp]
  0008c	e8 00 00 00 00	 call	 ??4VECTOR@@QAEAAV0@ABUtagPOINT@@@Z ; VECTOR::operator=
$LN4@FollowChai:

; 18   :   for (;;)
; 19   :   {
; 20   :     if (   (box.x < 0)
; 21   :         || (box.y < 0) 
; 22   :         || (box.x >= size.x-1)
; 23   :         || (box.y >= size.y-1)) break; // The previous line is the last

  00091	83 7d 10 00	 cmp	 DWORD PTR _box$[ebp], 0
  00095	7c 1c		 jl	 SHORT $LN6@FollowChai
  00097	83 7d 14 00	 cmp	 DWORD PTR _box$[ebp+4], 0
  0009b	7c 16		 jl	 SHORT $LN6@FollowChai
  0009d	8b 45 f0	 mov	 eax, DWORD PTR _size$[ebp]
  000a0	83 e8 01	 sub	 eax, 1
  000a3	39 45 10	 cmp	 DWORD PTR _box$[ebp], eax
  000a6	7d 0b		 jge	 SHORT $LN6@FollowChai
  000a8	8b 4d f4	 mov	 ecx, DWORD PTR _size$[ebp+4]
  000ab	83 e9 01	 sub	 ecx, 1
  000ae	39 4d 14	 cmp	 DWORD PTR _box$[ebp+4], ecx
  000b1	7c 05		 jl	 SHORT $LN5@FollowChai
$LN6@FollowChai:
  000b3	e9 cd 01 00 00	 jmp	 $LN3@FollowChai
$LN5@FollowChai:

; 24   :     // See if the box has an other empty sides.  If so, loop
; 25   :     // back and continue to follow the chain.
; 26   :     // 
; 27   :     // This box has four sides.  If it has 
; 28   :     // two empty sides then we keep going.
; 29   :     // If it has zero, one, three, or four empty
; 30   :     // sides then we are at the end of the chain.
; 31   :     numSide = 0;

  000b8	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _numSide$[ebp], 0

; 32   :     point = box;

  000bf	8b 55 10	 mov	 edx, DWORD PTR _box$[ebp]
  000c2	8b 45 14	 mov	 eax, DWORD PTR _box$[ebp+4]
  000c5	89 55 e0	 mov	 DWORD PTR _point$[ebp], edx
  000c8	89 45 e4	 mov	 DWORD PTR _point$[ebp+4], eax

; 33   :     if (pGame->HLineType(point) == LINE_NONE)

  000cb	8d 4d e0	 lea	 ecx, DWORD PTR _point$[ebp]
  000ce	51		 push	 ecx
  000cf	8b 4d 0c	 mov	 ecx, DWORD PTR _pGame$[ebp]
  000d2	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::HLineType
  000d7	85 c0		 test	 eax, eax
  000d9	75 49		 jne	 SHORT $LN7@FollowChai

; 34   :     {
; 35   :       numSide++;

  000db	8b 55 c8	 mov	 edx, DWORD PTR _numSide$[ebp]
  000de	83 c2 01	 add	 edx, 1
  000e1	89 55 c8	 mov	 DWORD PTR _numSide$[ebp], edx

; 36   :       if (prevLine.vertical || (prevLine.dotNum!=point))

  000e4	0f b6 45 20	 movzx	 eax, BYTE PTR _prevLine$[ebp+8]
  000e8	85 c0		 test	 eax, eax
  000ea	75 13		 jne	 SHORT $LN9@FollowChai
  000ec	8d 4d e0	 lea	 ecx, DWORD PTR _point$[ebp]
  000ef	51		 push	 ecx
  000f0	8d 4d 18	 lea	 ecx, DWORD PTR _prevLine$[ebp]
  000f3	e8 00 00 00 00	 call	 ??9VECTOR@@QAE_NABV0@@Z	; VECTOR::operator!=
  000f8	0f b6 d0	 movzx	 edx, al
  000fb	85 d2		 test	 edx, edx
  000fd	74 25		 je	 SHORT $LN7@FollowChai
$LN9@FollowChai:

; 37   :       {
; 38   :         nextLine.dotNum = point; nextBox = point; nextBox.y--;

  000ff	8b 45 e0	 mov	 eax, DWORD PTR _point$[ebp]
  00102	8b 4d e4	 mov	 ecx, DWORD PTR _point$[ebp+4]
  00105	89 45 8c	 mov	 DWORD PTR _nextLine$[ebp], eax
  00108	89 4d 90	 mov	 DWORD PTR _nextLine$[ebp+4], ecx
  0010b	8b 55 e0	 mov	 edx, DWORD PTR _point$[ebp]
  0010e	8b 45 e4	 mov	 eax, DWORD PTR _point$[ebp+4]
  00111	89 55 d0	 mov	 DWORD PTR _nextBox$[ebp], edx
  00114	89 45 d4	 mov	 DWORD PTR _nextBox$[ebp+4], eax
  00117	8b 4d d4	 mov	 ecx, DWORD PTR _nextBox$[ebp+4]
  0011a	83 e9 01	 sub	 ecx, 1
  0011d	89 4d d4	 mov	 DWORD PTR _nextBox$[ebp+4], ecx

; 39   :         nextLine.vertical = false;

  00120	c6 45 94 00	 mov	 BYTE PTR _nextLine$[ebp+8], 0
$LN7@FollowChai:

; 40   :       };
; 41   :     };
; 42   :     if (pGame->VLineType(point) == LINE_NONE)

  00124	8d 55 e0	 lea	 edx, DWORD PTR _point$[ebp]
  00127	52		 push	 edx
  00128	8b 4d 0c	 mov	 ecx, DWORD PTR _pGame$[ebp]
  0012b	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::VLineType
  00130	85 c0		 test	 eax, eax
  00132	75 49		 jne	 SHORT $LN10@FollowChai

; 43   :     {
; 44   :       numSide++;

  00134	8b 45 c8	 mov	 eax, DWORD PTR _numSide$[ebp]
  00137	83 c0 01	 add	 eax, 1
  0013a	89 45 c8	 mov	 DWORD PTR _numSide$[ebp], eax

; 45   :       if (!prevLine.vertical || (prevLine.dotNum!=point))

  0013d	0f b6 4d 20	 movzx	 ecx, BYTE PTR _prevLine$[ebp+8]
  00141	85 c9		 test	 ecx, ecx
  00143	74 13		 je	 SHORT $LN12@FollowChai
  00145	8d 55 e0	 lea	 edx, DWORD PTR _point$[ebp]
  00148	52		 push	 edx
  00149	8d 4d 18	 lea	 ecx, DWORD PTR _prevLine$[ebp]
  0014c	e8 00 00 00 00	 call	 ??9VECTOR@@QAE_NABV0@@Z	; VECTOR::operator!=
  00151	0f b6 c0	 movzx	 eax, al
  00154	85 c0		 test	 eax, eax
  00156	74 25		 je	 SHORT $LN10@FollowChai
$LN12@FollowChai:

; 46   :       {
; 47   :         nextLine.dotNum = point; nextBox = point; nextBox.x--;

  00158	8b 4d e0	 mov	 ecx, DWORD PTR _point$[ebp]
  0015b	8b 55 e4	 mov	 edx, DWORD PTR _point$[ebp+4]
  0015e	89 4d 8c	 mov	 DWORD PTR _nextLine$[ebp], ecx
  00161	89 55 90	 mov	 DWORD PTR _nextLine$[ebp+4], edx
  00164	8b 45 e0	 mov	 eax, DWORD PTR _point$[ebp]
  00167	8b 4d e4	 mov	 ecx, DWORD PTR _point$[ebp+4]
  0016a	89 45 d0	 mov	 DWORD PTR _nextBox$[ebp], eax
  0016d	89 4d d4	 mov	 DWORD PTR _nextBox$[ebp+4], ecx
  00170	8b 55 d0	 mov	 edx, DWORD PTR _nextBox$[ebp]
  00173	83 ea 01	 sub	 edx, 1
  00176	89 55 d0	 mov	 DWORD PTR _nextBox$[ebp], edx

; 48   :         nextLine.vertical = true;

  00179	c6 45 94 01	 mov	 BYTE PTR _nextLine$[ebp+8], 1
$LN10@FollowChai:

; 49   :       };
; 50   :     };
; 51   :     point.x++;

  0017d	8b 45 e0	 mov	 eax, DWORD PTR _point$[ebp]
  00180	83 c0 01	 add	 eax, 1
  00183	89 45 e0	 mov	 DWORD PTR _point$[ebp], eax

; 52   :     if (pGame->VLineType(point) == LINE_NONE)

  00186	8d 4d e0	 lea	 ecx, DWORD PTR _point$[ebp]
  00189	51		 push	 ecx
  0018a	8b 4d 0c	 mov	 ecx, DWORD PTR _pGame$[ebp]
  0018d	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::VLineType
  00192	85 c0		 test	 eax, eax
  00194	75 40		 jne	 SHORT $LN13@FollowChai

; 53   :     {
; 54   :       numSide++;

  00196	8b 55 c8	 mov	 edx, DWORD PTR _numSide$[ebp]
  00199	83 c2 01	 add	 edx, 1
  0019c	89 55 c8	 mov	 DWORD PTR _numSide$[ebp], edx

; 55   :       if (!prevLine.vertical || (prevLine.dotNum!=point))

  0019f	0f b6 45 20	 movzx	 eax, BYTE PTR _prevLine$[ebp+8]
  001a3	85 c0		 test	 eax, eax
  001a5	74 13		 je	 SHORT $LN15@FollowChai
  001a7	8d 4d e0	 lea	 ecx, DWORD PTR _point$[ebp]
  001aa	51		 push	 ecx
  001ab	8d 4d 18	 lea	 ecx, DWORD PTR _prevLine$[ebp]
  001ae	e8 00 00 00 00	 call	 ??9VECTOR@@QAE_NABV0@@Z	; VECTOR::operator!=
  001b3	0f b6 d0	 movzx	 edx, al
  001b6	85 d2		 test	 edx, edx
  001b8	74 1c		 je	 SHORT $LN13@FollowChai
$LN15@FollowChai:

; 56   :       {
; 57   :         nextLine.dotNum = point; nextBox = point;

  001ba	8b 45 e0	 mov	 eax, DWORD PTR _point$[ebp]
  001bd	8b 4d e4	 mov	 ecx, DWORD PTR _point$[ebp+4]
  001c0	89 45 8c	 mov	 DWORD PTR _nextLine$[ebp], eax
  001c3	89 4d 90	 mov	 DWORD PTR _nextLine$[ebp+4], ecx
  001c6	8b 55 e0	 mov	 edx, DWORD PTR _point$[ebp]
  001c9	8b 45 e4	 mov	 eax, DWORD PTR _point$[ebp+4]
  001cc	89 55 d0	 mov	 DWORD PTR _nextBox$[ebp], edx
  001cf	89 45 d4	 mov	 DWORD PTR _nextBox$[ebp+4], eax

; 58   :         nextLine.vertical = true;

  001d2	c6 45 94 01	 mov	 BYTE PTR _nextLine$[ebp+8], 1
$LN13@FollowChai:

; 59   :       };
; 60   :     };
; 61   :     point.x--;

  001d6	8b 4d e0	 mov	 ecx, DWORD PTR _point$[ebp]
  001d9	83 e9 01	 sub	 ecx, 1
  001dc	89 4d e0	 mov	 DWORD PTR _point$[ebp], ecx

; 62   :     point.y++;

  001df	8b 55 e4	 mov	 edx, DWORD PTR _point$[ebp+4]
  001e2	83 c2 01	 add	 edx, 1
  001e5	89 55 e4	 mov	 DWORD PTR _point$[ebp+4], edx

; 63   :     if (pGame->HLineType(point) == LINE_NONE)

  001e8	8d 45 e0	 lea	 eax, DWORD PTR _point$[ebp]
  001eb	50		 push	 eax
  001ec	8b 4d 0c	 mov	 ecx, DWORD PTR _pGame$[ebp]
  001ef	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::HLineType
  001f4	85 c0		 test	 eax, eax
  001f6	75 40		 jne	 SHORT $LN16@FollowChai

; 64   :     {
; 65   :       numSide++;

  001f8	8b 4d c8	 mov	 ecx, DWORD PTR _numSide$[ebp]
  001fb	83 c1 01	 add	 ecx, 1
  001fe	89 4d c8	 mov	 DWORD PTR _numSide$[ebp], ecx

; 66   :       if (prevLine.vertical || (prevLine.dotNum!=point))

  00201	0f b6 55 20	 movzx	 edx, BYTE PTR _prevLine$[ebp+8]
  00205	85 d2		 test	 edx, edx
  00207	75 13		 jne	 SHORT $LN18@FollowChai
  00209	8d 45 e0	 lea	 eax, DWORD PTR _point$[ebp]
  0020c	50		 push	 eax
  0020d	8d 4d 18	 lea	 ecx, DWORD PTR _prevLine$[ebp]
  00210	e8 00 00 00 00	 call	 ??9VECTOR@@QAE_NABV0@@Z	; VECTOR::operator!=
  00215	0f b6 c8	 movzx	 ecx, al
  00218	85 c9		 test	 ecx, ecx
  0021a	74 1c		 je	 SHORT $LN16@FollowChai
$LN18@FollowChai:

; 67   :       {
; 68   :         nextLine.dotNum = point; nextBox = point;

  0021c	8b 55 e0	 mov	 edx, DWORD PTR _point$[ebp]
  0021f	8b 45 e4	 mov	 eax, DWORD PTR _point$[ebp+4]
  00222	89 55 8c	 mov	 DWORD PTR _nextLine$[ebp], edx
  00225	89 45 90	 mov	 DWORD PTR _nextLine$[ebp+4], eax
  00228	8b 4d e0	 mov	 ecx, DWORD PTR _point$[ebp]
  0022b	8b 55 e4	 mov	 edx, DWORD PTR _point$[ebp+4]
  0022e	89 4d d0	 mov	 DWORD PTR _nextBox$[ebp], ecx
  00231	89 55 d4	 mov	 DWORD PTR _nextBox$[ebp+4], edx

; 69   :         nextLine.vertical = false;

  00234	c6 45 94 00	 mov	 BYTE PTR _nextLine$[ebp+8], 0
$LN16@FollowChai:

; 70   :       };
; 71   :     };
; 72   :     if (numSide != 2) break;

  00238	83 7d c8 02	 cmp	 DWORD PTR _numSide$[ebp], 2
  0023c	74 02		 je	 SHORT $LN19@FollowChai
  0023e	eb 45		 jmp	 SHORT $LN3@FollowChai
$LN19@FollowChai:

; 73   :     prevLine = nextLine;

  00240	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  00245	8d 75 8c	 lea	 esi, DWORD PTR _nextLine$[ebp]
  00248	8d 7d 18	 lea	 edi, DWORD PTR _prevLine$[ebp]
  0024b	f3 a5		 rep movsd

; 74   :     box = nextBox;

  0024d	8b 45 d0	 mov	 eax, DWORD PTR _nextBox$[ebp]
  00250	8b 4d d4	 mov	 ecx, DWORD PTR _nextBox$[ebp+4]
  00253	89 45 10	 mov	 DWORD PTR _box$[ebp], eax
  00256	89 4d 14	 mov	 DWORD PTR _box$[ebp+4], ecx

; 75   :     if (    (prevLine.dotNum.x == origLine.dotNum.x) 
; 76   :          && (prevLine.dotNum.y == origLine.dotNum.y)
; 77   :          && (prevLine.vertical == origLine.vertical)) break;

  00259	8b 55 18	 mov	 edx, DWORD PTR _prevLine$[ebp]
  0025c	3b 95 4c ff ff
	ff		 cmp	 edx, DWORD PTR _origLine$[ebp]
  00262	75 1c		 jne	 SHORT $LN20@FollowChai
  00264	8b 45 1c	 mov	 eax, DWORD PTR _prevLine$[ebp+4]
  00267	3b 85 50 ff ff
	ff		 cmp	 eax, DWORD PTR _origLine$[ebp+4]
  0026d	75 11		 jne	 SHORT $LN20@FollowChai
  0026f	0f b6 4d 20	 movzx	 ecx, BYTE PTR _prevLine$[ebp+8]
  00273	0f b6 95 54 ff
	ff ff		 movzx	 edx, BYTE PTR _origLine$[ebp+8]
  0027a	3b ca		 cmp	 ecx, edx
  0027c	75 02		 jne	 SHORT $LN20@FollowChai
  0027e	eb 05		 jmp	 SHORT $LN3@FollowChai
$LN20@FollowChai:

; 78   :   };

  00280	e9 0c fe ff ff	 jmp	 $LN4@FollowChai
$LN3@FollowChai:

; 79   :   prevLine.FindCaptures(pGame);

  00285	8b 45 0c	 mov	 eax, DWORD PTR _pGame$[ebp]
  00288	50		 push	 eax
  00289	8d 4d 18	 lea	 ecx, DWORD PTR _prevLine$[ebp]
  0028c	e8 00 00 00 00	 call	 ?FindCaptures@MOVE@@QAEXPAVDOTS_AND_BOXES@@@Z ; MOVE::FindCaptures

; 80   :   return prevLine;

  00291	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  00296	8d 75 18	 lea	 esi, DWORD PTR _prevLine$[ebp]
  00299	8b 7d 08	 mov	 edi, DWORD PTR __$ReturnAddress$[ebp]
  0029c	f3 a5		 rep movsd
  0029e	8b 45 08	 mov	 eax, DWORD PTR __$ReturnAddress$[ebp]

; 81   : }

  002a1	52		 push	 edx
  002a2	8b cd		 mov	 ecx, ebp
  002a4	50		 push	 eax
  002a5	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN28@FollowChai
  002ab	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002b0	58		 pop	 eax
  002b1	5a		 pop	 edx
  002b2	5f		 pop	 edi
  002b3	5e		 pop	 esi
  002b4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b7	33 cd		 xor	 ecx, ebp
  002b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002be	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  002c4	3b ec		 cmp	 ebp, esp
  002c6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002cb	8b e5		 mov	 esp, ebp
  002cd	5d		 pop	 ebp
  002ce	c3		 ret	 0
  002cf	90		 npad	 1
$LN28@FollowChai:
  002d0	05 00 00 00	 DD	 5
  002d4	00 00 00 00	 DD	 $LN27@FollowChai
$LN27@FollowChai:
  002d8	f0 ff ff ff	 DD	 -16			; fffffff0H
  002dc	08 00 00 00	 DD	 8
  002e0	00 00 00 00	 DD	 $LN22@FollowChai
  002e4	e0 ff ff ff	 DD	 -32			; ffffffe0H
  002e8	08 00 00 00	 DD	 8
  002ec	00 00 00 00	 DD	 $LN23@FollowChai
  002f0	d0 ff ff ff	 DD	 -48			; ffffffd0H
  002f4	08 00 00 00	 DD	 8
  002f8	00 00 00 00	 DD	 $LN24@FollowChai
  002fc	8c ff ff ff	 DD	 -116			; ffffff8cH
  00300	38 00 00 00	 DD	 56			; 00000038H
  00304	00 00 00 00	 DD	 $LN25@FollowChai
  00308	4c ff ff ff	 DD	 -180			; ffffff4cH
  0030c	38 00 00 00	 DD	 56			; 00000038H
  00310	00 00 00 00	 DD	 $LN26@FollowChai
$LN26@FollowChai:
  00314	6f		 DB	 111			; 0000006fH
  00315	72		 DB	 114			; 00000072H
  00316	69		 DB	 105			; 00000069H
  00317	67		 DB	 103			; 00000067H
  00318	4c		 DB	 76			; 0000004cH
  00319	69		 DB	 105			; 00000069H
  0031a	6e		 DB	 110			; 0000006eH
  0031b	65		 DB	 101			; 00000065H
  0031c	00		 DB	 0
$LN25@FollowChai:
  0031d	6e		 DB	 110			; 0000006eH
  0031e	65		 DB	 101			; 00000065H
  0031f	78		 DB	 120			; 00000078H
  00320	74		 DB	 116			; 00000074H
  00321	4c		 DB	 76			; 0000004cH
  00322	69		 DB	 105			; 00000069H
  00323	6e		 DB	 110			; 0000006eH
  00324	65		 DB	 101			; 00000065H
  00325	00		 DB	 0
$LN24@FollowChai:
  00326	6e		 DB	 110			; 0000006eH
  00327	65		 DB	 101			; 00000065H
  00328	78		 DB	 120			; 00000078H
  00329	74		 DB	 116			; 00000074H
  0032a	42		 DB	 66			; 00000042H
  0032b	6f		 DB	 111			; 0000006fH
  0032c	78		 DB	 120			; 00000078H
  0032d	00		 DB	 0
$LN23@FollowChai:
  0032e	70		 DB	 112			; 00000070H
  0032f	6f		 DB	 111			; 0000006fH
  00330	69		 DB	 105			; 00000069H
  00331	6e		 DB	 110			; 0000006eH
  00332	74		 DB	 116			; 00000074H
  00333	00		 DB	 0
$LN22@FollowChai:
  00334	73		 DB	 115			; 00000073H
  00335	69		 DB	 105			; 00000069H
  00336	7a		 DB	 122			; 0000007aH
  00337	65		 DB	 101			; 00000065H
  00338	00		 DB	 0
?FollowChain@@YA?AUMOVE@@PAVDOTS_AND_BOXES@@VVECTOR@@U1@@Z ENDP ; FollowChain
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\DeduceMove.cpp
_TEXT	SEGMENT
_move$ = -120						; size = 112
__$ArrayPad$ = -4					; size = 4
__$ReturnAddress$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
?DeduceMove@@YA?AUMOVE@@PAVDOTS_AND_BOXES@@PBVCON@@W4MOVE_TYPE@@@Z PROC ; DeduceMove

; 257  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d 84	 lea	 edi, DWORD PTR [ebp-124]
  0000b	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 258  :   MOVE move[2];// For the two end of the chain

  00021	68 00 00 00 00	 push	 OFFSET ??0MOVE@@QAE@XZ
  00026	6a 02		 push	 2
  00028	6a 38		 push	 56			; 00000038H
  0002a	8d 45 88	 lea	 eax, DWORD PTR _move$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??_H@YGXPAXIIP6EPAX0@Z@Z

; 259  :   NotImplemented("Deduce Move");

  00033	68 00 00 00 00	 push	 OFFSET $SG225979
  00038	e8 00 00 00 00	 call	 ?NotImplemented@@YAXPAD@Z ; NotImplemented
  0003d	83 c4 04	 add	 esp, 4

; 260  :   return move[0];

  00040	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00045	6b d1 00	 imul	 edx, ecx, 0
  00048	8d 74 15 88	 lea	 esi, DWORD PTR _move$[ebp+edx]
  0004c	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  00051	8b 7d 08	 mov	 edi, DWORD PTR __$ReturnAddress$[ebp]
  00054	f3 a5		 rep movsd
  00056	8b 45 08	 mov	 eax, DWORD PTR __$ReturnAddress$[ebp]

; 261  :   /*
; 262  :   move[0].oldLineType = LINE_NONE;
; 263  :   move[0].newLineType = LINE_COMPUTER;
; 264  :   move[1].oldLineType = LINE_NONE;
; 265  :   move[1].newLineType = LINE_COMPUTER;
; 266  :   switch (mt)
; 267  :   {
; 268  :   case MT_OBVIOUSCAPTURE:
; 269  :   case MT_GRABANYTHING:
; 270  :   case MT_SIMPLEWINCAPTURE:
; 271  :     // This will always be the forth line of a box
; 272  :     // containing three lines.
; 273  :     // We need to search boxes both ways from the
; 274  :     // given line number to find one we can capture.
; 275  :     LocateChainEnds(pGame, move, computerMove);
; 276  :     move[0].moveType = mt;
; 277  :     move[1].moveType = mt;
; 278  :     if (move[0].boxesCaptured[0].x >= 0) return move[0];
; 279  :     if (move[1].boxesCaptured[0].x >= 0) return move[1];
; 280  :     if (move[0].boxesCaptured[1].x >= 0) return move[0];
; 281  :     if (move[1].boxesCaptured[1].x >= 0) return move[1];
; 282  :     die ("MT_OBVIOUSCAPTURE cannot find capture");
; 283  :     break;
; 284  :   case MT_SIMPLEWINDECLINE:
; 285  :     LocateChainEnds(pGame, move, computerMove);
; 286  :     move[0].moveType = mt;
; 287  :     move[1].moveType = mt;
; 288  :     if ((move[0].boxesCaptured[0].x < 0)&&(move[0].boxesCaptured[1].x < 0)) 
; 289  :     {
; 290  :       return move[0];
; 291  :     }
; 292  :     else return move[1];
; 293  :     break;
; 294  :   case MT_SIMPLEWIN:
; 295  :     //This is a non-capturing move.  We broke a link
; 296  :     //between two stops.  There is only one special case
; 297  :     //and that is when the link is two nodes long.  We want
; 298  :     //to play a hard-hearted handout.  We can always play
; 299  :     //one away from the end.
; 300  :     LocateChainEnds(pGame, move, computerMove);
; 301  :     //Choose an end at random;
; 302  :     if (pDoc->MyRandom(2) == 0) move[0] = move[1];
; 303  :     //LocateChainEnds has found the last line in the chain - the
; 304  :     //one separating the chain from the stop.  We want to find
; 305  :     //the next one.  In the case of a zero-length chain then
; 306  :     //there is no next one.
; 307  :     move[1] = LocatePenultimateLine(pGame, &move[0]);
; 308  :     move[1].moveType = mt;
; 309  :     return move[1];
; 310  :   case MT_GIVELITTLE:
; 311  :     move[0].ConstructFromLineNumber(computerMove);
; 312  :     move[0].moveType = mt;
; 313  :     return move[0];
; 314  :   default: die("DeduceMove unexpected MOVE_TYPE");
; 315  :   };
; 316  :   return move[0];
; 317  :   */
; 318  : };

  00059	52		 push	 edx
  0005a	8b cd		 mov	 ecx, ebp
  0005c	50		 push	 eax
  0005d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@DeduceMove
  00063	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00068	58		 pop	 eax
  00069	5a		 pop	 edx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006f	33 cd		 xor	 ecx, ebp
  00071	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00076	83 c4 7c	 add	 esp, 124		; 0000007cH
  00079	3b ec		 cmp	 ebp, esp
  0007b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
$LN5@DeduceMove:
  00084	01 00 00 00	 DD	 1
  00088	00 00 00 00	 DD	 $LN4@DeduceMove
$LN4@DeduceMove:
  0008c	88 ff ff ff	 DD	 -120			; ffffff88H
  00090	70 00 00 00	 DD	 112			; 00000070H
  00094	00 00 00 00	 DD	 $LN3@DeduceMove
$LN3@DeduceMove:
  00098	6d		 DB	 109			; 0000006dH
  00099	6f		 DB	 111			; 0000006fH
  0009a	76		 DB	 118			; 00000076H
  0009b	65		 DB	 101			; 00000065H
  0009c	00		 DB	 0
?DeduceMove@@YA?AUMOVE@@PAVDOTS_AND_BOXES@@PBVCON@@W4MOVE_TYPE@@@Z ENDP ; DeduceMove
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0MOVE@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0MOVE@@QAE@XZ PROC					; MOVE::MOVE, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0VECTOR@@QAE@XZ	; VECTOR::VECTOR
  00016	68 00 00 00 00	 push	 OFFSET ??0VECTOR@@QAE@XZ ; VECTOR::VECTOR
  0001b	6a 02		 push	 2
  0001d	6a 08		 push	 8
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	83 c0 0c	 add	 eax, 12			; 0000000cH
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ??_H@YGXPAXIIP6EPAX0@Z@Z
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 c4 04	 add	 esp, 4
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??0MOVE@@QAE@XZ ENDP					; MOVE::MOVE
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dotNum$ = 8						; size = 4
?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z PROC ; DOTS_AND_BOXES::HLineType, COMDAT
; _this$ = ecx

; 102  :   INLINE LINE_TYPE HLineType(const POINT& dotNum)const{return HLineType(dotNum.x, dotNum.y);};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _dotNum$[ebp]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	51		 push	 ecx
  00015	8b 55 08	 mov	 edx, DWORD PTR _dotNum$[ebp]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  00023	83 c4 04	 add	 esp, 4
  00026	3b ec		 cmp	 ebp, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ENDP ; DOTS_AND_BOXES::HLineType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_col$ = 8						; size = 4
_row$ = 12						; size = 4
?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z PROC	; DOTS_AND_BOXES::HLineType, COMDAT
; _this$ = ecx

; 101  :   INLINE LINE_TYPE HLineType(int col, int row)const{return (LINE_TYPE)m_hlines[row*(m_width-1) + col];};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000d	83 e9 01	 sub	 ecx, 1
  00010	0f af 4d 0c	 imul	 ecx, DWORD PTR _row$[ebp]
  00014	03 4d 08	 add	 ecx, DWORD PTR _col$[ebp]
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001d	0f b6 04 08	 movzx	 eax, BYTE PTR [eax+ecx]
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ENDP	; DOTS_AND_BOXES::HLineType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dotNum$ = 8						; size = 4
?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z PROC ; DOTS_AND_BOXES::VLineType, COMDAT
; _this$ = ecx

; 98   :   INLINE LINE_TYPE VLineType(const POINT& dotNum)const{return VLineType(dotNum.x, dotNum.y);};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _dotNum$[ebp]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	51		 push	 ecx
  00015	8b 55 08	 mov	 edx, DWORD PTR _dotNum$[ebp]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  00023	83 c4 04	 add	 esp, 4
  00026	3b ec		 cmp	 ebp, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ENDP ; DOTS_AND_BOXES::VLineType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_col$ = 8						; size = 4
_row$ = 12						; size = 4
?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z PROC	; DOTS_AND_BOXES::VLineType, COMDAT
; _this$ = ecx

; 97   :   INLINE LINE_TYPE VLineType(int col, int row)const{return (LINE_TYPE)m_vlines[row*m_width + col];};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _row$[ebp]
  0000d	0f af 48 10	 imul	 ecx, DWORD PTR [eax+16]
  00011	03 4d 08	 add	 ecx, DWORD PTR _col$[ebp]
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0001a	0f b6 04 08	 movzx	 eax, BYTE PTR [eax+ecx]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ENDP	; DOTS_AND_BOXES::VLineType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?Size@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ
_TEXT	SEGMENT
_p$ = -16						; size = 8
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Size@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ PROC		; DOTS_AND_BOXES::Size, COMDAT
; _this$ = ecx

; 95   :   INLINE POINT Size(void) const {POINT p; p.x=m_width; p.y=m_height; return p;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00023	89 4d f0	 mov	 DWORD PTR _p$[ebp], ecx
  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0002c	89 45 f4	 mov	 DWORD PTR _p$[ebp+4], eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00032	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  00035	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp+4]
  00038	89 11		 mov	 DWORD PTR [ecx], edx
  0003a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0003d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00040	52		 push	 edx
  00041	8b cd		 mov	 ecx, ebp
  00043	50		 push	 eax
  00044	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Size
  0004a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0004f	58		 pop	 eax
  00050	5a		 pop	 edx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
  00057	90		 npad	 1
$LN5@Size:
  00058	01 00 00 00	 DD	 1
  0005c	00 00 00 00	 DD	 $LN4@Size
$LN4@Size:
  00060	f0 ff ff ff	 DD	 -16			; fffffff0H
  00064	08 00 00 00	 DD	 8
  00068	00 00 00 00	 DD	 $LN3@Size
$LN3@Size:
  0006c	70		 DB	 112			; 00000070H
  0006d	00		 DB	 0
?Size@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ ENDP		; DOTS_AND_BOXES::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\stdafx.h
;	COMDAT ??9VECTOR@@QAE_NABV0@@Z
_TEXT	SEGMENT
tv86 = -8						; size = 4
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??9VECTOR@@QAE_NABV0@@Z PROC				; VECTOR::operator!=, COMDAT
; _this$ = ecx

; 67   :   bool    operator != (const VECTOR& v){return (x!=v.x) || (y!=v.y);};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00013	75 17		 jne	 SHORT $LN3@operator
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0001b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001e	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00021	75 09		 jne	 SHORT $LN3@operator
  00023	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
  0002a	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0002c	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv86[ebp], 1
$LN4@operator:
  00033	0f b6 45 f8	 movzx	 eax, BYTE PTR tv86[ebp]
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??9VECTOR@@QAE_NABV0@@Z ENDP				; VECTOR::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\stdafx.h
;	COMDAT ??4VECTOR@@QAEAAV0@ABUtagPOINT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_point$ = 8						; size = 4
??4VECTOR@@QAEAAV0@ABUtagPOINT@@@Z PROC			; VECTOR::operator=, COMDAT
; _this$ = ecx

; 63   :   VECTOR& operator =(const POINT& point){x=point.x;y=point.y;return *this;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _point$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _point$[ebp]
  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??4VECTOR@@QAEAAV0@ABUtagPOINT@@@Z ENDP			; VECTOR::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\stdafx.h
;	COMDAT ??0VECTOR@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VECTOR@@QAE@XZ PROC					; VECTOR::VECTOR, COMDAT
; _this$ = ecx

; 61   :   VECTOR(void){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0VECTOR@@QAE@XZ ENDP					; VECTOR::VECTOR
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\DeduceMove.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\DeduceMove.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv67 = -8						; size = 4
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
$LN2@vector:
  00015	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00018	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0001b	8b 4d 10	 mov	 ecx, DWORD PTR ___n$[ebp]
  0001e	83 e9 01	 sub	 ecx, 1
  00021	89 4d 10	 mov	 DWORD PTR ___n$[ebp], ecx
  00024	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00028	76 09		 jbe	 SHORT $LN5@vector
  0002a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  00031	eb 07		 jmp	 SHORT $LN6@vector
$LN5@vector:
  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN6@vector:
  0003a	83 7d f8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003e	74 1a		 je	 SHORT $LN1@vector
  00040	8b f4		 mov	 esi, esp
  00042	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00045	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  00048	3b f4		 cmp	 esi, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b 55 08	 mov	 edx, DWORD PTR ___t$[ebp]
  00052	03 55 0c	 add	 edx, DWORD PTR ___s$[ebp]
  00055	89 55 08	 mov	 DWORD PTR ___t$[ebp], edx
  00058	eb bb		 jmp	 SHORT $LN2@vector
$LN1@vector:
  0005a	5e		 pop	 esi
  0005b	83 c4 08	 add	 esp, 8
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
