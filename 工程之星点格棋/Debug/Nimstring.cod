; Listing generated by Microsoft (R) Optimizing Compiler Version 19.35.32217.1 

	TITLE	C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\Debug\Nimstring.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?searchDepth@@3HA				; searchDepth
_DATA	SEGMENT
?searchDepth@@3HA DD 02H				; searchDepth
_DATA	ENDS
CONST	SEGMENT
$SG225462 DB	'C:\Users\15485\Desktop\', 0b9H, 0a4H, 0b3H, 0ccH, 0d6H, 0aeH
	DB	0d0H, 0c7H, 0b5H, 0e3H, 0b8H, 0f1H, 0c6H, 0e5H, '\DotBoxLib\Ni'
	DB	'mstring.cpp', 00H
	ORG $+2
$SG225470 DB	'Check to set length to zero', 00H
$SG225471 DB	'C:\Users\15485\Desktop\', 0b9H, 0a4H, 0b3H, 0ccH, 0d6H, 0aeH
	DB	0d0H, 0c7H, 0b5H, 0e3H, 0b8H, 0f1H, 0c6H, 0e5H, '\DotBoxLib\Ni'
	DB	'mstring.cpp', 00H
	ORG $+2
$SG225479 DB	'C:\Users\15485\Desktop\', 0b9H, 0a4H, 0b3H, 0ccH, 0d6H, 0aeH
	DB	0d0H, 0c7H, 0b5H, 0e3H, 0b8H, 0f1H, 0c6H, 0e5H, '\DotBoxLib\Ni'
	DB	'mstring.cpp', 00H
	ORG $+2
$SG225512 DB	'Deleting looping edge', 00H
	ORG $+2
$SG225599 DB	'C:\Users\15485\Desktop\', 0b9H, 0a4H, 0b3H, 0ccH, 0d6H, 0aeH
	DB	0d0H, 0c7H, 0b5H, 0e3H, 0b8H, 0f1H, 0c6H, 0e5H, '\DotBoxLib\Ni'
	DB	'mstring.cpp', 00H
	ORG $+2
$SG225600 DB	'C:\Users\15485\Desktop\', 0b9H, 0a4H, 0b3H, 0ccH, 0d6H, 0aeH
	DB	0d0H, 0c7H, 0b5H, 0e3H, 0b8H, 0f1H, 0c6H, 0e5H, '\DotBoxLib\Ni'
	DB	'mstring.cpp', 00H
	ORG $+2
$SG225603 DB	'C:\Users\15485\Desktop\', 0b9H, 0a4H, 0b3H, 0ccH, 0d6H, 0aeH
	DB	0d0H, 0c7H, 0b5H, 0e3H, 0b8H, 0f1H, 0c6H, 0e5H, '\DotBoxLib\Ni'
	DB	'mstring.cpp', 00H
	ORG $+2
$SG225614 DB	'Nim of non-GND_GND isolated string', 00H
	ORG $+1
$SG225622 DB	'C:\Users\15485\Desktop\', 0b9H, 0a4H, 0b3H, 0ccH, 0d6H, 0aeH
	DB	0d0H, 0c7H, 0b5H, 0e3H, 0b8H, 0f1H, 0c6H, 0e5H, '\DotBoxLib\Ni'
	DB	'mstring.cpp', 00H
	ORG $+2
$SG225627 DB	'C:\Users\15485\Desktop\', 0b9H, 0a4H, 0b3H, 0ccH, 0d6H, 0aeH
	DB	0d0H, 0c7H, 0b5H, 0e3H, 0b8H, 0f1H, 0c6H, 0e5H, '\DotBoxLib\Ni'
	DB	'mstring.cpp', 00H
	ORG $+2
$SG225680 DB	'Illegal Capturable configuration', 00H
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?AfxAssertFailedLine@@YGHPBDH@Z			; AfxAssertFailedLine
PUBLIC	?GetValue@NIMHASHTABLE@@QBEIH@Z			; NIMHASHTABLE::GetValue
PUBLIC	??4EDGE@@QAEXABU0@@Z				; EDGE::operator=
PUBLIC	?Clear@EDGE@@QAEXXZ				; EDGE::Clear
PUBLIC	??4EDGEDATA@@QAEXABU0@@Z			; EDGEDATA::operator=
PUBLIC	?Clear@STOPDATA@@QAEXXZ				; STOPDATA::Clear
PUBLIC	?MoveEdge@CON@@QAEXHHH@Z			; CON::MoveEdge
PUBLIC	?NimVal@NIMCON@@QAEHPBVCON@@@Z			; NIMCON::NimVal
PUBLIC	?NimVal@NIMCON@@QAEHHH@Z			; NIMCON::NimVal
PUBLIC	??4NIMCON@@QAEAAV0@PBVCON@@@Z			; NIMCON::operator=
PUBLIC	?NimHash@NIMCON@@QAE_KHH@Z			; NIMCON::NimHash
PUBLIC	?CombineEdges@NIMCON@@QAE_NH@Z			; NIMCON::CombineEdges
PUBLIC	?DeleteEdge@NIMCON@@QAEXHHPAH@Z			; NIMCON::DeleteEdge
PUBLIC	?DeleteNode@NIMCON@@QAEXHPAH@Z			; NIMCON::DeleteNode
PUBLIC	??0NIMCON@@QAE@XZ				; NIMCON::NIMCON
PUBLIC	??1NIMCON@@QAE@XZ				; NIMCON::~NIMCON
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	?NotImplemented@@YAXPAD@Z:PROC			; NotImplemented
EXTRN	?ImplementationError@@YAXPBD@Z:PROC		; ImplementationError
EXTRN	?Exists@NIMHASHTABLE@@QAEH_K@Z:PROC		; NIMHASHTABLE::Exists
EXTRN	?EnterValue@NIMHASHTABLE@@QAEX_KE@Z:PROC	; NIMHASHTABLE::EnterValue
EXTRN	??0CON@@QAE@XZ:PROC				; CON::CON
EXTRN	??1CON@@QAE@XZ:PROC				; CON::~CON
EXTRN	?Canon@CON@@QAEXHH@Z:PROC			; CON::Canon
EXTRN	?Simplify@NIMCON@@QAE_NHH@Z:PROC		; NIMCON::Simplify
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__allshl:PROC
EXTRN	__chkstk:PROC
EXTRN	?nimHashTable@@3PAVNIMHASHTABLE@@A:DWORD	; nimHashTable
EXTRN	?currentTime@@3_JA:QWORD			; currentTime
EXTRN	?timeLimit@@3_JA:QWORD				; timeLimit
EXTRN	?stopThinking@@3_NA:BYTE			; stopThinking
EXTRN	?searchAborted@@3_NA:BYTE			; searchAborted
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
_DATA	SEGMENT
?count@@3HA DD	0aH					; count
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__unwindfunclet$?NimVal@NIMCON@@QAEHHH@Z$0
	DD	019H
	DD	026H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?NimVal@NIMCON@@QAEHHH@Z
	DD	038H
	DD	0cbeH
voltbl	ENDS
xdata$x	SEGMENT
__unwindtable$?NimVal@NIMCON@@QAEHHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?NimVal@NIMCON@@QAEHHH@Z$0
__ehfuncinfo$?NimVal@NIMCON@@QAEHHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?NimVal@NIMCON@@QAEHHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1NIMCON@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1NIMCON@@QAE@XZ PROC					; NIMCON::~NIMCON, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1CON@@QAE@XZ		; CON::~CON
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1NIMCON@@QAE@XZ ENDP					; NIMCON::~NIMCON
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0NIMCON@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0NIMCON@@QAE@XZ PROC					; NIMCON::NIMCON, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0CON@@QAE@XZ		; CON::CON
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0NIMCON@@QAE@XZ ENDP					; NIMCON::NIMCON
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Nimstring.cpp
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_nn$ = 8						; size = 4
_nnLast$ = 12						; size = 4
?DeleteNode@NIMCON@@QAEXHPAH@Z PROC			; NIMCON::DeleteNode
; _this$ = ecx

; 274  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 275  :   // You better have arranged that nothing points to
; 276  :   // the node being deleted.
; 277  :   (*nnLast)--;

  0000a	8b 45 0c	 mov	 eax, DWORD PTR _nnLast$[ebp]
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	83 e9 01	 sub	 ecx, 1
  00012	8b 55 0c	 mov	 edx, DWORD PTR _nnLast$[ebp]
  00015	89 0a		 mov	 DWORD PTR [edx], ecx

; 278  :   for (int i=nn; i<*nnLast; i++)

  00017	8b 45 08	 mov	 eax, DWORD PTR _nn$[ebp]
  0001a	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
  0001d	eb 09		 jmp	 SHORT $LN4@DeleteNode
$LN2@DeleteNode:
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  00022	83 c1 01	 add	 ecx, 1
  00025	89 4d f8	 mov	 DWORD PTR _i$1[ebp], ecx
$LN4@DeleteNode:
  00028	8b 55 0c	 mov	 edx, DWORD PTR _nnLast$[ebp]
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0002e	3b 02		 cmp	 eax, DWORD PTR [edx]
  00030	7d 37		 jge	 SHORT $LN1@DeleteNode

; 279  :   {
; 280  :     nd[i].ix = nd[i+1].ix;

  00032	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  00035	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00038	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003b	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  0003e	8a 84 86 17 10
	00 00		 mov	 al, BYTE PTR [esi+eax*4+4119]
  00045	88 84 8a 13 10
	00 00		 mov	 BYTE PTR [edx+ecx*4+4115], al

; 281  :     nd[nd[i].ix].os = (STOPNUM)i;

  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0004f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00052	0f b6 84 8a 13
	10 00 00	 movzx	 eax, BYTE PTR [edx+ecx*4+4115]
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8a 55 f8	 mov	 dl, BYTE PTR _i$1[ebp]
  00060	88 94 81 12 10
	00 00		 mov	 BYTE PTR [ecx+eax*4+4114], dl

; 282  :   };

  00067	eb b6		 jmp	 SHORT $LN2@DeleteNode
$LN1@DeleteNode:

; 283  : }

  00069	5e		 pop	 esi
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 08 00	 ret	 8
?DeleteNode@NIMCON@@QAEXHPAH@Z ENDP			; NIMCON::DeleteNode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Nimstring.cpp
_TEXT	SEGMENT
tv228 = -26						; size = 1
tv164 = -25						; size = 1
_ecB$ = -24						; size = 4
_ecA$ = -20						; size = 4
_edgeB$ = -16						; size = 4
_nnB$ = -12						; size = 4
_nnA$ = -8						; size = 4
_this$ = -4						; size = 4
_nn$ = 8						; size = 4
_en$ = 12						; size = 4
_nnLast$ = 16						; size = 4
?DeleteEdge@NIMCON@@QAEXHHPAH@Z PROC			; NIMCON::DeleteEdge
; _this$ = ecx

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 289  :   //The edge originates at node nn and may terminate
; 290  :   //anywhere: GROUND, DEADEND, another node, or even this node.
; 291  :   int nnA, nnB, edgeB, ecA, ecB;
; 292  :   nnA = nd[nn].ix;

  00023	8b 45 08	 mov	 eax, DWORD PTR _nn$[ebp]
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	0f b6 94 81 13
	10 00 00	 movzx	 edx, BYTE PTR [ecx+eax*4+4115]
  00031	89 55 f8	 mov	 DWORD PTR _nnA$[ebp], edx

; 293  :   nnB = sd[nnA][en].ns;

  00034	8b 45 f8	 mov	 eax, DWORD PTR _nnA$[ebp]
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  00041	8b 45 0c	 mov	 eax, DWORD PTR _en$[ebp]
  00044	0f b6 0c 42	 movzx	 ecx, BYTE PTR [edx+eax*2]
  00048	89 4d f4	 mov	 DWORD PTR _nnB$[ebp], ecx

; 294  :   if (IS_A_NODE(nnB))

  0004b	81 7d f4 f9 00
	00 00		 cmp	 DWORD PTR _nnB$[ebp], 249 ; 000000f9H
  00052	0f 8d 1b 01 00
	00		 jge	 $LN6@DeleteEdge

; 295  :   {
; 296  :     //We will delete it from the far node first.
; 297  :     edgeB = sd[nnA][en].ne;

  00058	8b 55 f8	 mov	 edx, DWORD PTR _nnA$[ebp]
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  00065	8b 55 0c	 mov	 edx, DWORD PTR _en$[ebp]
  00068	0f b6 44 51 01	 movzx	 eax, BYTE PTR [ecx+edx*2+1]
  0006d	89 45 f0	 mov	 DWORD PTR _edgeB$[ebp], eax

; 298  :     if (nnB == nnA)

  00070	8b 4d f4	 mov	 ecx, DWORD PTR _nnB$[ebp]
  00073	3b 4d f8	 cmp	 ecx, DWORD PTR _nnA$[ebp]
  00076	75 46		 jne	 SHORT $LN7@DeleteEdge

; 299  :     {
; 300  :       if (nd[nnA].ec < 4)

  00078	8b 55 f8	 mov	 edx, DWORD PTR _nnA$[ebp]
  0007b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	0f b6 8c 90 10
	10 00 00	 movzx	 ecx, BYTE PTR [eax+edx*4+4112]
  00086	83 f9 04	 cmp	 ecx, 4
  00089	7d 0d		 jge	 SHORT $LN8@DeleteEdge

; 301  :       {
; 302  :         NotImplemented("Deleting looping edge");

  0008b	68 00 00 00 00	 push	 OFFSET $SG225512
  00090	e8 00 00 00 00	 call	 ?NotImplemented@@YAXPAD@Z ; NotImplemented
  00095	83 c4 04	 add	 esp, 4
$LN8@DeleteEdge:

; 303  :       };
; 304  :       if (edgeB < en)

  00098	8b 55 f0	 mov	 edx, DWORD PTR _edgeB$[ebp]
  0009b	3b 55 0c	 cmp	 edx, DWORD PTR _en$[ebp]
  0009e	7d 1e		 jge	 SHORT $LN7@DeleteEdge

; 305  :       {
; 306  :         //swap so the larger edge is deleted first
; 307  :         edgeB = en;

  000a0	8b 45 0c	 mov	 eax, DWORD PTR _en$[ebp]
  000a3	89 45 f0	 mov	 DWORD PTR _edgeB$[ebp], eax

; 308  :         en = sd[nnA][en].ne;

  000a6	8b 4d f8	 mov	 ecx, DWORD PTR _nnA$[ebp]
  000a9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ac	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  000b3	8b 4d 0c	 mov	 ecx, DWORD PTR _en$[ebp]
  000b6	0f b6 54 48 01	 movzx	 edx, BYTE PTR [eax+ecx*2+1]
  000bb	89 55 0c	 mov	 DWORD PTR _en$[ebp], edx
$LN7@DeleteEdge:

; 309  :       };
; 310  :     };
; 311  :     ecB = --nd[nnB].ec;

  000be	8b 45 f4	 mov	 eax, DWORD PTR _nnB$[ebp]
  000c1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	8a 94 81 10 10
	00 00		 mov	 dl, BYTE PTR [ecx+eax*4+4112]
  000cb	80 ea 01	 sub	 dl, 1
  000ce	88 55 e7	 mov	 BYTE PTR tv164[ebp], dl
  000d1	8b 45 f4	 mov	 eax, DWORD PTR _nnB$[ebp]
  000d4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	8a 55 e7	 mov	 dl, BYTE PTR tv164[ebp]
  000da	88 94 81 10 10
	00 00		 mov	 BYTE PTR [ecx+eax*4+4112], dl
  000e1	0f b6 45 e7	 movzx	 eax, BYTE PTR tv164[ebp]
  000e5	89 45 e8	 mov	 DWORD PTR _ecB$[ebp], eax
$LN2@DeleteEdge:

; 312  :     while (edgeB < ecB) 

  000e8	8b 4d f0	 mov	 ecx, DWORD PTR _edgeB$[ebp]
  000eb	3b 4d e8	 cmp	 ecx, DWORD PTR _ecB$[ebp]
  000ee	7d 22		 jge	 SHORT $LN3@DeleteEdge

; 313  :     {
; 314  :       MoveEdge(nnB,edgeB+1,edgeB);

  000f0	8b 55 f0	 mov	 edx, DWORD PTR _edgeB$[ebp]
  000f3	52		 push	 edx
  000f4	8b 45 f0	 mov	 eax, DWORD PTR _edgeB$[ebp]
  000f7	83 c0 01	 add	 eax, 1
  000fa	50		 push	 eax
  000fb	8b 4d f4	 mov	 ecx, DWORD PTR _nnB$[ebp]
  000fe	51		 push	 ecx
  000ff	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00102	e8 00 00 00 00	 call	 ?MoveEdge@CON@@QAEXHHH@Z ; CON::MoveEdge

; 315  :       edgeB++;

  00107	8b 55 f0	 mov	 edx, DWORD PTR _edgeB$[ebp]
  0010a	83 c2 01	 add	 edx, 1
  0010d	89 55 f0	 mov	 DWORD PTR _edgeB$[ebp], edx

; 316  :     };

  00110	eb d6		 jmp	 SHORT $LN2@DeleteEdge
$LN3@DeleteEdge:

; 317  :     ed[nnB].e[ecB].Clear();

  00112	8b 45 f4	 mov	 eax, DWORD PTR _nnB$[ebp]
  00115	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00118	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  0011c	8b 45 e8	 mov	 eax, DWORD PTR _ecB$[ebp]
  0011f	8d 0c 42	 lea	 ecx, DWORD PTR [edx+eax*2]
  00122	e8 00 00 00 00	 call	 ?Clear@EDGE@@QAEXXZ	; EDGE::Clear

; 318  :     sd[nnB][ecB].Clear();

  00127	8b 4d f4	 mov	 ecx, DWORD PTR _nnB$[ebp]
  0012a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0012d	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  00134	8b 4d e8	 mov	 ecx, DWORD PTR _ecB$[ebp]
  00137	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0013a	e8 00 00 00 00	 call	 ?Clear@STOPDATA@@QAEXXZ	; STOPDATA::Clear

; 319  :     if (ecB < 3)

  0013f	83 7d e8 03	 cmp	 DWORD PTR _ecB$[ebp], 3
  00143	7d 2e		 jge	 SHORT $LN6@DeleteEdge

; 320  :     {
; 321  :       if (CombineEdges(nnB))

  00145	8b 55 f4	 mov	 edx, DWORD PTR _nnB$[ebp]
  00148	52		 push	 edx
  00149	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	e8 00 00 00 00	 call	 ?CombineEdges@NIMCON@@QAE_NH@Z ; NIMCON::CombineEdges
  00151	0f b6 c0	 movzx	 eax, al
  00154	85 c0		 test	 eax, eax
  00156	74 1b		 je	 SHORT $LN6@DeleteEdge

; 322  :       {
; 323  :         DeleteNode(nd[nnB].os, nnLast);

  00158	8b 4d 10	 mov	 ecx, DWORD PTR _nnLast$[ebp]
  0015b	51		 push	 ecx
  0015c	8b 55 f4	 mov	 edx, DWORD PTR _nnB$[ebp]
  0015f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00162	0f b6 8c 90 12
	10 00 00	 movzx	 ecx, BYTE PTR [eax+edx*4+4114]
  0016a	51		 push	 ecx
  0016b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0016e	e8 00 00 00 00	 call	 ?DeleteNode@NIMCON@@QAEXHPAH@Z ; NIMCON::DeleteNode
$LN6@DeleteEdge:

; 324  :       };
; 325  :     };
; 326  :   };
; 327  :   //Now delete the edge from the near node.
; 328  :   ecA = --nd[nnA].ec;

  00173	8b 55 f8	 mov	 edx, DWORD PTR _nnA$[ebp]
  00176	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00179	8a 8c 90 10 10
	00 00		 mov	 cl, BYTE PTR [eax+edx*4+4112]
  00180	80 e9 01	 sub	 cl, 1
  00183	88 4d e6	 mov	 BYTE PTR tv228[ebp], cl
  00186	8b 55 f8	 mov	 edx, DWORD PTR _nnA$[ebp]
  00189	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0018c	8a 4d e6	 mov	 cl, BYTE PTR tv228[ebp]
  0018f	88 8c 90 10 10
	00 00		 mov	 BYTE PTR [eax+edx*4+4112], cl
  00196	0f b6 55 e6	 movzx	 edx, BYTE PTR tv228[ebp]
  0019a	89 55 ec	 mov	 DWORD PTR _ecA$[ebp], edx
$LN4@DeleteEdge:

; 329  :   while (en < ecA) 

  0019d	8b 45 0c	 mov	 eax, DWORD PTR _en$[ebp]
  001a0	3b 45 ec	 cmp	 eax, DWORD PTR _ecA$[ebp]
  001a3	7d 22		 jge	 SHORT $LN5@DeleteEdge

; 330  :   {
; 331  :     MoveEdge(nnA,en+1,en);

  001a5	8b 4d 0c	 mov	 ecx, DWORD PTR _en$[ebp]
  001a8	51		 push	 ecx
  001a9	8b 55 0c	 mov	 edx, DWORD PTR _en$[ebp]
  001ac	83 c2 01	 add	 edx, 1
  001af	52		 push	 edx
  001b0	8b 45 f8	 mov	 eax, DWORD PTR _nnA$[ebp]
  001b3	50		 push	 eax
  001b4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b7	e8 00 00 00 00	 call	 ?MoveEdge@CON@@QAEXHHH@Z ; CON::MoveEdge

; 332  :     en++;

  001bc	8b 4d 0c	 mov	 ecx, DWORD PTR _en$[ebp]
  001bf	83 c1 01	 add	 ecx, 1
  001c2	89 4d 0c	 mov	 DWORD PTR _en$[ebp], ecx

; 333  :   };

  001c5	eb d6		 jmp	 SHORT $LN4@DeleteEdge
$LN5@DeleteEdge:

; 334  :   ed[nnA].e[ecA].Clear();

  001c7	8b 55 f8	 mov	 edx, DWORD PTR _nnA$[ebp]
  001ca	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001cd	8d 4c d0 10	 lea	 ecx, DWORD PTR [eax+edx*8+16]
  001d1	8b 55 ec	 mov	 edx, DWORD PTR _ecA$[ebp]
  001d4	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  001d7	e8 00 00 00 00	 call	 ?Clear@EDGE@@QAEXXZ	; EDGE::Clear

; 335  :   sd[nnA][ecA].Clear();

  001dc	8b 45 f8	 mov	 eax, DWORD PTR _nnA$[ebp]
  001df	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001e2	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  001e9	8b 45 ec	 mov	 eax, DWORD PTR _ecA$[ebp]
  001ec	8d 0c 42	 lea	 ecx, DWORD PTR [edx+eax*2]
  001ef	e8 00 00 00 00	 call	 ?Clear@STOPDATA@@QAEXXZ	; STOPDATA::Clear

; 336  :   if (ecA < 3)

  001f4	83 7d ec 03	 cmp	 DWORD PTR _ecA$[ebp], 3
  001f8	7d 2e		 jge	 SHORT $LN1@DeleteEdge

; 337  :   {
; 338  :     if (CombineEdges(nnA))

  001fa	8b 4d f8	 mov	 ecx, DWORD PTR _nnA$[ebp]
  001fd	51		 push	 ecx
  001fe	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00201	e8 00 00 00 00	 call	 ?CombineEdges@NIMCON@@QAE_NH@Z ; NIMCON::CombineEdges
  00206	0f b6 d0	 movzx	 edx, al
  00209	85 d2		 test	 edx, edx
  0020b	74 1b		 je	 SHORT $LN1@DeleteEdge

; 339  :     {
; 340  :       DeleteNode(nd[nnA].os, nnLast);

  0020d	8b 45 10	 mov	 eax, DWORD PTR _nnLast$[ebp]
  00210	50		 push	 eax
  00211	8b 4d f8	 mov	 ecx, DWORD PTR _nnA$[ebp]
  00214	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00217	0f b6 84 8a 12
	10 00 00	 movzx	 eax, BYTE PTR [edx+ecx*4+4114]
  0021f	50		 push	 eax
  00220	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00223	e8 00 00 00 00	 call	 ?DeleteNode@NIMCON@@QAEXHPAH@Z ; NIMCON::DeleteNode
$LN1@DeleteEdge:

; 341  :     };
; 342  :   };
; 343  : }

  00228	83 c4 1c	 add	 esp, 28			; 0000001cH
  0022b	3b ec		 cmp	 ebp, esp
  0022d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00232	8b e5		 mov	 esp, ebp
  00234	5d		 pop	 ebp
  00235	c2 0c 00	 ret	 12			; 0000000cH
?DeleteEdge@NIMCON@@QAEXHHPAH@Z ENDP			; NIMCON::DeleteEdge
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Nimstring.cpp
_TEXT	SEGMENT
_edgeC$1 = -52						; size = 4
_edgeB$2 = -48						; size = 4
_nnC$3 = -44						; size = 4
_nnB$4 = -40						; size = 4
_len$5 = -36						; size = 4
_en$6 = -32						; size = 4
_edgeB$7 = -28						; size = 4
_nnB$8 = -24						; size = 4
_len$9 = -20						; size = 4
_edgeB$10 = -16						; size = 4
_nnB$11 = -12						; size = 4
_len$12 = -8						; size = 4
_this$ = -4						; size = 4
_nnA$ = 8						; size = 4
?CombineEdges@NIMCON@@QAE_NH@Z PROC			; NIMCON::CombineEdges
; _this$ = ecx

; 159  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	57		 push	 edi
  00007	51		 push	 ecx
  00008	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  0000b	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	59		 pop	 ecx
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 160  : //  int len;
; 161  :   ASSERT(nd[nnA].ec == 2);

  0001b	8b 45 08	 mov	 eax, DWORD PTR _nnA$[ebp]
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	0f b6 94 81 10
	10 00 00	 movzx	 edx, BYTE PTR [ecx+eax*4+4112]
  00029	83 fa 02	 cmp	 edx, 2
  0002c	74 14		 je	 SHORT $LN24@CombineEdg
  0002e	68 a1 00 00 00	 push	 161			; 000000a1H
  00033	68 00 00 00 00	 push	 OFFSET $SG225462
  00038	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0003d	85 c0		 test	 eax, eax
  0003f	74 01		 je	 SHORT $LN24@CombineEdg
  00041	cc		 int	 3
$LN24@CombineEdg:

; 162  :   if (sd[nnA][0].ns == GROUND)

  00042	8b 4d 08	 mov	 ecx, DWORD PTR _nnA$[ebp]
  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  0004f	b9 02 00 00 00	 mov	 ecx, 2
  00054	6b d1 00	 imul	 edx, ecx, 0
  00057	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  0005b	3d fa 00 00 00	 cmp	 eax, 250		; 000000faH
  00060	0f 85 ef 01 00
	00		 jne	 $LN5@CombineEdg

; 163  :   {
; 164  :     if (sd[nnA][1].ns == GROUND)

  00066	8b 4d 08	 mov	 ecx, DWORD PTR _nnA$[ebp]
  00069	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006c	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  00073	b9 02 00 00 00	 mov	 ecx, 2
  00078	c1 e1 00	 shl	 ecx, 0
  0007b	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  0007f	81 fa fa 00 00
	00		 cmp	 edx, 250		; 000000faH
  00085	0f 85 e0 00 00
	00		 jne	 $LN7@CombineEdg

; 165  :     {
; 166  :       ed[nnA].e[0].ng = GND_GND;

  0008b	8b 45 08	 mov	 eax, DWORD PTR _nnA$[ebp]
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  00095	b8 02 00 00 00	 mov	 eax, 2
  0009a	6b c8 00	 imul	 ecx, eax, 0
  0009d	c6 04 0a fd	 mov	 BYTE PTR [edx+ecx], 253	; 000000fdH

; 167  :       ed[nnA].e[0].el = (EDGECOUNT)(ed[nnA].e[0].el + ed[nnA].e[1].el + 1);

  000a1	8b 55 08	 mov	 edx, DWORD PTR _nnA$[ebp]
  000a4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a7	8d 4c d0 10	 lea	 ecx, DWORD PTR [eax+edx*8+16]
  000ab	ba 02 00 00 00	 mov	 edx, 2
  000b0	6b c2 00	 imul	 eax, edx, 0
  000b3	0f b6 4c 01 01	 movzx	 ecx, BYTE PTR [ecx+eax+1]
  000b8	8b 55 08	 mov	 edx, DWORD PTR _nnA$[ebp]
  000bb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000be	8d 54 d0 10	 lea	 edx, DWORD PTR [eax+edx*8+16]
  000c2	b8 02 00 00 00	 mov	 eax, 2
  000c7	c1 e0 00	 shl	 eax, 0
  000ca	0f b6 54 02 01	 movzx	 edx, BYTE PTR [edx+eax+1]
  000cf	8d 44 11 01	 lea	 eax, DWORD PTR [ecx+edx+1]
  000d3	8b 4d 08	 mov	 ecx, DWORD PTR _nnA$[ebp]
  000d6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000d9	8d 4c ca 10	 lea	 ecx, DWORD PTR [edx+ecx*8+16]
  000dd	ba 02 00 00 00	 mov	 edx, 2
  000e2	6b d2 00	 imul	 edx, edx, 0
  000e5	88 44 11 01	 mov	 BYTE PTR [ecx+edx+1], al

; 168  :       ed[nnA].e[1].Clear();

  000e9	8b 45 08	 mov	 eax, DWORD PTR _nnA$[ebp]
  000ec	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ef	8d 4c c1 10	 lea	 ecx, DWORD PTR [ecx+eax*8+16]
  000f3	ba 02 00 00 00	 mov	 edx, 2
  000f8	c1 e2 00	 shl	 edx, 0
  000fb	03 ca		 add	 ecx, edx
  000fd	e8 00 00 00 00	 call	 ?Clear@EDGE@@QAEXXZ	; EDGE::Clear

; 169  :       sd[nnA][0].ns = GND_GND;

  00102	8b 45 08	 mov	 eax, DWORD PTR _nnA$[ebp]
  00105	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00108	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  0010f	b8 02 00 00 00	 mov	 eax, 2
  00114	6b c8 00	 imul	 ecx, eax, 0
  00117	c6 04 0a fd	 mov	 BYTE PTR [edx+ecx], 253	; 000000fdH

; 170  :       sd[nnA][1].Clear();

  0011b	8b 55 08	 mov	 edx, DWORD PTR _nnA$[ebp]
  0011e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00121	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  00128	ba 02 00 00 00	 mov	 edx, 2
  0012d	c1 e2 00	 shl	 edx, 0
  00130	03 ca		 add	 ecx, edx
  00132	e8 00 00 00 00	 call	 ?Clear@STOPDATA@@QAEXXZ	; STOPDATA::Clear

; 171  :       sd[nnA][0].ne = UNUSED;

  00137	8b 45 08	 mov	 eax, DWORD PTR _nnA$[ebp]
  0013a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013d	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  00144	b8 02 00 00 00	 mov	 eax, 2
  00149	6b c8 00	 imul	 ecx, eax, 0
  0014c	c6 44 0a 01 ff	 mov	 BYTE PTR [edx+ecx+1], 255 ; 000000ffH

; 172  :       nd[nnA].ec = 0;

  00151	8b 55 08	 mov	 edx, DWORD PTR _nnA$[ebp]
  00154	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00157	c6 84 90 10 10
	00 00 00	 mov	 BYTE PTR [eax+edx*4+4112], 0

; 173  :       return false;

  0015f	32 c0		 xor	 al, al
  00161	e9 0a 05 00 00	 jmp	 $LN1@CombineEdg

; 174  :     }

  00166	e9 e5 00 00 00	 jmp	 $LN8@CombineEdg
$LN7@CombineEdg:

; 175  :     else
; 176  :     {//GROUND to non-GROUND
; 177  :       //Set neighbor[1] edge to GROUND.  Tell Caller to delete this node.
; 178  :       int len, nnB, edgeB;
; 179  :       len = ed[nnA].e[1].el + ed[nnA].e[0].el + 1;

  0016b	8b 4d 08	 mov	 ecx, DWORD PTR _nnA$[ebp]
  0016e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00171	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  00175	b9 02 00 00 00	 mov	 ecx, 2
  0017a	c1 e1 00	 shl	 ecx, 0
  0017d	0f b6 54 08 01	 movzx	 edx, BYTE PTR [eax+ecx+1]
  00182	8b 45 08	 mov	 eax, DWORD PTR _nnA$[ebp]
  00185	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00188	8d 44 c1 10	 lea	 eax, DWORD PTR [ecx+eax*8+16]
  0018c	b9 02 00 00 00	 mov	 ecx, 2
  00191	6b c9 00	 imul	 ecx, ecx, 0
  00194	0f b6 44 08 01	 movzx	 eax, BYTE PTR [eax+ecx+1]
  00199	8d 4c 02 01	 lea	 ecx, DWORD PTR [edx+eax+1]
  0019d	89 4d f8	 mov	 DWORD PTR _len$12[ebp], ecx

; 180  :       if (len > 3) len = 3;

  001a0	83 7d f8 03	 cmp	 DWORD PTR _len$12[ebp], 3
  001a4	7e 07		 jle	 SHORT $LN9@CombineEdg
  001a6	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _len$12[ebp], 3
$LN9@CombineEdg:

; 181  :       nnB = sd[nnA][1].ns;

  001ad	8b 55 08	 mov	 edx, DWORD PTR _nnA$[ebp]
  001b0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001b3	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  001ba	ba 02 00 00 00	 mov	 edx, 2
  001bf	c1 e2 00	 shl	 edx, 0
  001c2	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  001c6	89 45 f4	 mov	 DWORD PTR _nnB$11[ebp], eax

; 182  :       edgeB = sd[nnA][1].ne;

  001c9	8b 4d 08	 mov	 ecx, DWORD PTR _nnA$[ebp]
  001cc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001cf	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  001d6	b9 02 00 00 00	 mov	 ecx, 2
  001db	c1 e1 00	 shl	 ecx, 0
  001de	0f b6 54 08 01	 movzx	 edx, BYTE PTR [eax+ecx+1]
  001e3	89 55 f0	 mov	 DWORD PTR _edgeB$10[ebp], edx

; 183  :       ed[nnB].e[edgeB].ng = GROUND;

  001e6	8b 45 f4	 mov	 eax, DWORD PTR _nnB$11[ebp]
  001e9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ec	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  001f0	8b 45 f0	 mov	 eax, DWORD PTR _edgeB$10[ebp]
  001f3	c6 04 42 fa	 mov	 BYTE PTR [edx+eax*2], 250 ; 000000faH

; 184  :       if (len == 1)

  001f7	83 7d f8 01	 cmp	 DWORD PTR _len$12[ebp], 1
  001fb	75 0f		 jne	 SHORT $LN10@CombineEdg

; 185  :       {
; 186  :         NotImplemented("Check to set length to zero");

  001fd	68 00 00 00 00	 push	 OFFSET $SG225470
  00202	e8 00 00 00 00	 call	 ?NotImplemented@@YAXPAD@Z ; NotImplemented
  00207	83 c4 04	 add	 esp, 4

; 187  :       }

  0020a	eb 14		 jmp	 SHORT $LN11@CombineEdg
$LN10@CombineEdg:

; 188  :       else
; 189  :       {
; 190  :         ed[nnB].e[edgeB].el = (EDGELEN)len;

  0020c	8b 4d f4	 mov	 ecx, DWORD PTR _nnB$11[ebp]
  0020f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00212	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  00216	8b 4d f0	 mov	 ecx, DWORD PTR _edgeB$10[ebp]
  00219	8a 55 f8	 mov	 dl, BYTE PTR _len$12[ebp]
  0021c	88 54 48 01	 mov	 BYTE PTR [eax+ecx*2+1], dl
$LN11@CombineEdg:

; 191  :       };
; 192  :       sd[nnB][edgeB].ns = GROUND;

  00220	8b 45 f4	 mov	 eax, DWORD PTR _nnB$11[ebp]
  00223	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00226	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  0022d	8b 45 f0	 mov	 eax, DWORD PTR _edgeB$10[ebp]
  00230	c6 04 42 fa	 mov	 BYTE PTR [edx+eax*2], 250 ; 000000faH

; 193  :       sd[nnB][edgeB].ne = UNUSED;

  00234	8b 4d f4	 mov	 ecx, DWORD PTR _nnB$11[ebp]
  00237	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0023a	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  00241	8b 4d f0	 mov	 ecx, DWORD PTR _edgeB$10[ebp]
  00244	c6 44 48 01 ff	 mov	 BYTE PTR [eax+ecx*2+1], 255 ; 000000ffH

; 194  :       return true;

  00249	b0 01		 mov	 al, 1
  0024b	e9 20 04 00 00	 jmp	 $LN1@CombineEdg
$LN8@CombineEdg:

; 195  :     };
; 196  :   }

  00250	e9 1b 04 00 00	 jmp	 $LN1@CombineEdg
$LN5@CombineEdg:

; 197  :   else
; 198  :   {
; 199  :     ASSERT(IS_A_NODE(sd[nnA][0].ns));

  00255	8b 55 08	 mov	 edx, DWORD PTR _nnA$[ebp]
  00258	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0025b	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  00262	ba 02 00 00 00	 mov	 edx, 2
  00267	6b c2 00	 imul	 eax, edx, 0
  0026a	0f b6 0c 01	 movzx	 ecx, BYTE PTR [ecx+eax]
  0026e	81 f9 f9 00 00
	00		 cmp	 ecx, 249		; 000000f9H
  00274	7c 14		 jl	 SHORT $LN25@CombineEdg
  00276	68 c7 00 00 00	 push	 199			; 000000c7H
  0027b	68 00 00 00 00	 push	 OFFSET $SG225471
  00280	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00285	85 c0		 test	 eax, eax
  00287	74 01		 je	 SHORT $LN25@CombineEdg
  00289	cc		 int	 3
$LN25@CombineEdg:

; 200  :     if (sd[nnA][1].ns == GROUND)

  0028a	8b 45 08	 mov	 eax, DWORD PTR _nnA$[ebp]
  0028d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00290	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  00297	b8 02 00 00 00	 mov	 eax, 2
  0029c	c1 e0 00	 shl	 eax, 0
  0029f	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  002a3	81 f9 fa 00 00
	00		 cmp	 ecx, 250		; 000000faH
  002a9	0f 85 c9 01 00
	00		 jne	 $LN12@CombineEdg

; 201  :     {//non-GROUND to GROUND
; 202  :       //Set neighbor[0] edge to GROUND.  Tell Caller to delete this node.
; 203  :       int len, nnB, edgeB;
; 204  :       len = ed[nnA].e[1].el + ed[nnA].e[0].el + 1;

  002af	8b 55 08	 mov	 edx, DWORD PTR _nnA$[ebp]
  002b2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002b5	8d 4c d0 10	 lea	 ecx, DWORD PTR [eax+edx*8+16]
  002b9	ba 02 00 00 00	 mov	 edx, 2
  002be	c1 e2 00	 shl	 edx, 0
  002c1	0f b6 44 11 01	 movzx	 eax, BYTE PTR [ecx+edx+1]
  002c6	8b 4d 08	 mov	 ecx, DWORD PTR _nnA$[ebp]
  002c9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002cc	8d 4c ca 10	 lea	 ecx, DWORD PTR [edx+ecx*8+16]
  002d0	ba 02 00 00 00	 mov	 edx, 2
  002d5	6b d2 00	 imul	 edx, edx, 0
  002d8	0f b6 4c 11 01	 movzx	 ecx, BYTE PTR [ecx+edx+1]
  002dd	8d 54 08 01	 lea	 edx, DWORD PTR [eax+ecx+1]
  002e1	89 55 ec	 mov	 DWORD PTR _len$9[ebp], edx

; 205  :       if (len > 3) len = 3;

  002e4	83 7d ec 03	 cmp	 DWORD PTR _len$9[ebp], 3
  002e8	7e 07		 jle	 SHORT $LN14@CombineEdg
  002ea	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _len$9[ebp], 3
$LN14@CombineEdg:

; 206  :       nnB = sd[nnA][0].ns;

  002f1	8b 45 08	 mov	 eax, DWORD PTR _nnA$[ebp]
  002f4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002f7	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  002fe	b8 02 00 00 00	 mov	 eax, 2
  00303	6b c8 00	 imul	 ecx, eax, 0
  00306	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  0030a	89 55 e8	 mov	 DWORD PTR _nnB$8[ebp], edx

; 207  :       edgeB = sd[nnA][0].ne;

  0030d	8b 45 08	 mov	 eax, DWORD PTR _nnA$[ebp]
  00310	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00313	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  0031a	b8 02 00 00 00	 mov	 eax, 2
  0031f	6b c8 00	 imul	 ecx, eax, 0
  00322	0f b6 54 0a 01	 movzx	 edx, BYTE PTR [edx+ecx+1]
  00327	89 55 e4	 mov	 DWORD PTR _edgeB$7[ebp], edx

; 208  :       ed[nnB].e[edgeB].ng = GROUND;

  0032a	8b 45 e8	 mov	 eax, DWORD PTR _nnB$8[ebp]
  0032d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00330	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  00334	8b 45 e4	 mov	 eax, DWORD PTR _edgeB$7[ebp]
  00337	c6 04 42 fa	 mov	 BYTE PTR [edx+eax*2], 250 ; 000000faH

; 209  :       if (len == 1)

  0033b	83 7d ec 01	 cmp	 DWORD PTR _len$9[ebp], 1
  0033f	0f 85 ea 00 00
	00		 jne	 $LN15@CombineEdg

; 210  :       {
; 211  :         int en;
; 212  :         len = 0;

  00345	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _len$9[ebp], 0

; 213  :         for (en=0; en<nd[nnB].ec; en++)

  0034c	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _en$6[ebp], 0
  00353	eb 09		 jmp	 SHORT $LN4@CombineEdg
$LN2@CombineEdg:
  00355	8b 4d e0	 mov	 ecx, DWORD PTR _en$6[ebp]
  00358	83 c1 01	 add	 ecx, 1
  0035b	89 4d e0	 mov	 DWORD PTR _en$6[ebp], ecx
$LN4@CombineEdg:
  0035e	8b 55 e8	 mov	 edx, DWORD PTR _nnB$8[ebp]
  00361	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00364	0f b6 8c 90 10
	10 00 00	 movzx	 ecx, BYTE PTR [eax+edx*4+4112]
  0036c	39 4d e0	 cmp	 DWORD PTR _en$6[ebp], ecx
  0036f	0f 8d a4 00 00
	00		 jge	 $LN3@CombineEdg

; 214  :         {
; 215  :           if (ed[nnB].e[en].el >= 2) continue;

  00375	8b 55 e8	 mov	 edx, DWORD PTR _nnB$8[ebp]
  00378	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0037b	8d 4c d0 10	 lea	 ecx, DWORD PTR [eax+edx*8+16]
  0037f	8b 55 e0	 mov	 edx, DWORD PTR _en$6[ebp]
  00382	0f b6 44 51 01	 movzx	 eax, BYTE PTR [ecx+edx*2+1]
  00387	83 f8 02	 cmp	 eax, 2
  0038a	7c 02		 jl	 SHORT $LN17@CombineEdg
  0038c	eb c7		 jmp	 SHORT $LN2@CombineEdg
$LN17@CombineEdg:

; 216  :           if (IS_A_NODE(sd[nnB][en].ns))

  0038e	8b 4d e8	 mov	 ecx, DWORD PTR _nnB$8[ebp]
  00391	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00394	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  0039b	8b 4d e0	 mov	 ecx, DWORD PTR _en$6[ebp]
  0039e	0f b6 14 48	 movzx	 edx, BYTE PTR [eax+ecx*2]
  003a2	81 fa f9 00 00
	00		 cmp	 edx, 249		; 000000f9H
  003a8	7d 09		 jge	 SHORT $LN18@CombineEdg

; 217  :           {
; 218  :             len = 1;

  003aa	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _len$9[ebp], 1

; 219  :             break;;

  003b1	eb 66		 jmp	 SHORT $LN3@CombineEdg
$LN18@CombineEdg:

; 220  :           };
; 221  :           ASSERT(sd[nnB][en].ns == GROUND);

  003b3	8b 45 e8	 mov	 eax, DWORD PTR _nnB$8[ebp]
  003b6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003b9	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  003c0	8b 45 e0	 mov	 eax, DWORD PTR _en$6[ebp]
  003c3	0f b6 0c 42	 movzx	 ecx, BYTE PTR [edx+eax*2]
  003c7	81 f9 fa 00 00
	00		 cmp	 ecx, 250		; 000000faH
  003cd	74 14		 je	 SHORT $LN26@CombineEdg
  003cf	68 dd 00 00 00	 push	 221			; 000000ddH
  003d4	68 00 00 00 00	 push	 OFFSET $SG225479
  003d9	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  003de	85 c0		 test	 eax, eax
  003e0	74 01		 je	 SHORT $LN26@CombineEdg
  003e2	cc		 int	 3
$LN26@CombineEdg:

; 222  :           if (en == edgeB) continue;

  003e3	8b 45 e0	 mov	 eax, DWORD PTR _en$6[ebp]
  003e6	3b 45 e4	 cmp	 eax, DWORD PTR _edgeB$7[ebp]
  003e9	75 05		 jne	 SHORT $LN19@CombineEdg
  003eb	e9 65 ff ff ff	 jmp	 $LN2@CombineEdg
$LN19@CombineEdg:

; 223  :           if (ed[nnB].e[en].el == 0) continue;

  003f0	8b 4d e8	 mov	 ecx, DWORD PTR _nnB$8[ebp]
  003f3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003f6	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  003fa	8b 4d e0	 mov	 ecx, DWORD PTR _en$6[ebp]
  003fd	0f b6 54 48 01	 movzx	 edx, BYTE PTR [eax+ecx*2+1]
  00402	85 d2		 test	 edx, edx
  00404	75 05		 jne	 SHORT $LN20@CombineEdg
  00406	e9 4a ff ff ff	 jmp	 $LN2@CombineEdg
$LN20@CombineEdg:

; 224  :           len = 1;

  0040b	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _len$9[ebp], 1

; 225  :           break;

  00412	eb 05		 jmp	 SHORT $LN3@CombineEdg

; 226  :         };

  00414	e9 3c ff ff ff	 jmp	 $LN2@CombineEdg
$LN3@CombineEdg:

; 227  :           ed[nnB].e[edgeB].el = (EDGELEN)len;

  00419	8b 45 e8	 mov	 eax, DWORD PTR _nnB$8[ebp]
  0041c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0041f	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  00423	8b 45 e4	 mov	 eax, DWORD PTR _edgeB$7[ebp]
  00426	8a 4d ec	 mov	 cl, BYTE PTR _len$9[ebp]
  00429	88 4c 42 01	 mov	 BYTE PTR [edx+eax*2+1], cl

; 228  :       }

  0042d	eb 14		 jmp	 SHORT $LN16@CombineEdg
$LN15@CombineEdg:

; 229  :       else
; 230  :       {
; 231  :         ed[nnB].e[edgeB].el = (EDGELEN)len;

  0042f	8b 55 e8	 mov	 edx, DWORD PTR _nnB$8[ebp]
  00432	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00435	8d 4c d0 10	 lea	 ecx, DWORD PTR [eax+edx*8+16]
  00439	8b 55 e4	 mov	 edx, DWORD PTR _edgeB$7[ebp]
  0043c	8a 45 ec	 mov	 al, BYTE PTR _len$9[ebp]
  0043f	88 44 51 01	 mov	 BYTE PTR [ecx+edx*2+1], al
$LN16@CombineEdg:

; 232  :       };
; 233  :       sd[nnB][edgeB].ns = GROUND;

  00443	8b 4d e8	 mov	 ecx, DWORD PTR _nnB$8[ebp]
  00446	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00449	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  00450	8b 4d e4	 mov	 ecx, DWORD PTR _edgeB$7[ebp]
  00453	c6 04 48 fa	 mov	 BYTE PTR [eax+ecx*2], 250 ; 000000faH

; 234  :       sd[nnB][edgeB].ne = UNUSED;

  00457	8b 55 e8	 mov	 edx, DWORD PTR _nnB$8[ebp]
  0045a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0045d	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  00464	8b 55 e4	 mov	 edx, DWORD PTR _edgeB$7[ebp]
  00467	c6 44 51 01 ff	 mov	 BYTE PTR [ecx+edx*2+1], 255 ; 000000ffH

; 235  :       return true;

  0046c	b0 01		 mov	 al, 1
  0046e	e9 fd 01 00 00	 jmp	 $LN1@CombineEdg

; 236  :     }

  00473	e9 f8 01 00 00	 jmp	 $LN1@CombineEdg
$LN12@CombineEdg:

; 237  :     else
; 238  :     {//node-to-node
; 239  :       int len, nnB, nnC, edgeB, edgeC;
; 240  :       len = ed[nnA].e[1].el + ed[nnA].e[0].el + 1;

  00478	8b 45 08	 mov	 eax, DWORD PTR _nnA$[ebp]
  0047b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0047e	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  00482	b8 02 00 00 00	 mov	 eax, 2
  00487	c1 e0 00	 shl	 eax, 0
  0048a	0f b6 4c 02 01	 movzx	 ecx, BYTE PTR [edx+eax+1]
  0048f	8b 55 08	 mov	 edx, DWORD PTR _nnA$[ebp]
  00492	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00495	8d 54 d0 10	 lea	 edx, DWORD PTR [eax+edx*8+16]
  00499	b8 02 00 00 00	 mov	 eax, 2
  0049e	6b c0 00	 imul	 eax, eax, 0
  004a1	0f b6 54 02 01	 movzx	 edx, BYTE PTR [edx+eax+1]
  004a6	8d 44 11 01	 lea	 eax, DWORD PTR [ecx+edx+1]
  004aa	89 45 dc	 mov	 DWORD PTR _len$5[ebp], eax

; 241  :       nnB = sd[nnA][0].ns;

  004ad	8b 4d 08	 mov	 ecx, DWORD PTR _nnA$[ebp]
  004b0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  004b3	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  004ba	b9 02 00 00 00	 mov	 ecx, 2
  004bf	6b d1 00	 imul	 edx, ecx, 0
  004c2	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  004c6	89 45 d8	 mov	 DWORD PTR _nnB$4[ebp], eax

; 242  :       edgeB = sd[nnA][0].ne;

  004c9	8b 4d 08	 mov	 ecx, DWORD PTR _nnA$[ebp]
  004cc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  004cf	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  004d6	b9 02 00 00 00	 mov	 ecx, 2
  004db	6b d1 00	 imul	 edx, ecx, 0
  004de	0f b6 44 10 01	 movzx	 eax, BYTE PTR [eax+edx+1]
  004e3	89 45 d0	 mov	 DWORD PTR _edgeB$2[ebp], eax

; 243  :       nnC = sd[nnA][1].ns;

  004e6	8b 4d 08	 mov	 ecx, DWORD PTR _nnA$[ebp]
  004e9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  004ec	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  004f3	b9 02 00 00 00	 mov	 ecx, 2
  004f8	c1 e1 00	 shl	 ecx, 0
  004fb	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  004ff	89 55 d4	 mov	 DWORD PTR _nnC$3[ebp], edx

; 244  :       edgeC = sd[nnA][1].ne;

  00502	8b 45 08	 mov	 eax, DWORD PTR _nnA$[ebp]
  00505	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00508	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  0050f	b8 02 00 00 00	 mov	 eax, 2
  00514	c1 e0 00	 shl	 eax, 0
  00517	0f b6 4c 02 01	 movzx	 ecx, BYTE PTR [edx+eax+1]
  0051c	89 4d cc	 mov	 DWORD PTR _edgeC$1[ebp], ecx

; 245  :       if (len >= 3)

  0051f	83 7d dc 03	 cmp	 DWORD PTR _len$5[ebp], 3
  00523	0f 8c 9d 00 00
	00		 jl	 $LN21@CombineEdg

; 246  :       {//We can snap a long chain right now
; 247  :         sd[nnB][edgeB].ns = GROUND;

  00529	8b 55 d8	 mov	 edx, DWORD PTR _nnB$4[ebp]
  0052c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0052f	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  00536	8b 55 d0	 mov	 edx, DWORD PTR _edgeB$2[ebp]
  00539	c6 04 51 fa	 mov	 BYTE PTR [ecx+edx*2], 250 ; 000000faH

; 248  :         sd[nnC][edgeC].ns = GROUND;

  0053d	8b 45 d4	 mov	 eax, DWORD PTR _nnC$3[ebp]
  00540	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00543	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  0054a	8b 45 cc	 mov	 eax, DWORD PTR _edgeC$1[ebp]
  0054d	c6 04 42 fa	 mov	 BYTE PTR [edx+eax*2], 250 ; 000000faH

; 249  :         sd[nnB][edgeB].ne = UNUSED;

  00551	8b 4d d8	 mov	 ecx, DWORD PTR _nnB$4[ebp]
  00554	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00557	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  0055e	8b 4d d0	 mov	 ecx, DWORD PTR _edgeB$2[ebp]
  00561	c6 44 48 01 ff	 mov	 BYTE PTR [eax+ecx*2+1], 255 ; 000000ffH

; 250  :         sd[nnC][edgeC].ne = UNUSED;

  00566	8b 55 d4	 mov	 edx, DWORD PTR _nnC$3[ebp]
  00569	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0056c	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  00573	8b 55 cc	 mov	 edx, DWORD PTR _edgeC$1[ebp]
  00576	c6 44 51 01 ff	 mov	 BYTE PTR [ecx+edx*2+1], 255 ; 000000ffH

; 251  :         ed[nnB].e[edgeB].ng = GROUND;

  0057b	8b 45 d8	 mov	 eax, DWORD PTR _nnB$4[ebp]
  0057e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00581	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  00585	8b 45 d0	 mov	 eax, DWORD PTR _edgeB$2[ebp]
  00588	c6 04 42 fa	 mov	 BYTE PTR [edx+eax*2], 250 ; 000000faH

; 252  :         ed[nnC].e[edgeC].ng = GROUND;

  0058c	8b 4d d4	 mov	 ecx, DWORD PTR _nnC$3[ebp]
  0058f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00592	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  00596	8b 4d cc	 mov	 ecx, DWORD PTR _edgeC$1[ebp]
  00599	c6 04 48 fa	 mov	 BYTE PTR [eax+ecx*2], 250 ; 000000faH

; 253  :         ed[nnB].e[edgeB].el = 3;

  0059d	8b 55 d8	 mov	 edx, DWORD PTR _nnB$4[ebp]
  005a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005a3	8d 4c d0 10	 lea	 ecx, DWORD PTR [eax+edx*8+16]
  005a7	8b 55 d0	 mov	 edx, DWORD PTR _edgeB$2[ebp]
  005aa	c6 44 51 01 03	 mov	 BYTE PTR [ecx+edx*2+1], 3

; 254  :         ed[nnC].e[edgeC].el = 3;

  005af	8b 45 d4	 mov	 eax, DWORD PTR _nnC$3[ebp]
  005b2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005b5	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  005b9	8b 45 cc	 mov	 eax, DWORD PTR _edgeC$1[ebp]
  005bc	c6 44 42 01 03	 mov	 BYTE PTR [edx+eax*2+1], 3

; 255  :       }

  005c1	e9 a8 00 00 00	 jmp	 $LN22@CombineEdg
$LN21@CombineEdg:

; 256  :       else
; 257  :       {
; 258  :         sd[nnB][edgeB].ns = (STOPNUM)nnC;

  005c6	8b 4d d8	 mov	 ecx, DWORD PTR _nnB$4[ebp]
  005c9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  005cc	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  005d3	8b 4d d0	 mov	 ecx, DWORD PTR _edgeB$2[ebp]
  005d6	8a 55 d4	 mov	 dl, BYTE PTR _nnC$3[ebp]
  005d9	88 14 48	 mov	 BYTE PTR [eax+ecx*2], dl

; 259  :         ed[nnB].e[edgeB].ng = (STOPNUM)nnC;

  005dc	8b 45 d8	 mov	 eax, DWORD PTR _nnB$4[ebp]
  005df	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005e2	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  005e6	8b 45 d0	 mov	 eax, DWORD PTR _edgeB$2[ebp]
  005e9	8a 4d d4	 mov	 cl, BYTE PTR _nnC$3[ebp]
  005ec	88 0c 42	 mov	 BYTE PTR [edx+eax*2], cl

; 260  :         sd[nnC][edgeC].ns = (STOPNUM)nnB;

  005ef	8b 55 d4	 mov	 edx, DWORD PTR _nnC$3[ebp]
  005f2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005f5	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  005fc	8b 55 cc	 mov	 edx, DWORD PTR _edgeC$1[ebp]
  005ff	8a 45 d8	 mov	 al, BYTE PTR _nnB$4[ebp]
  00602	88 04 51	 mov	 BYTE PTR [ecx+edx*2], al

; 261  :         ed[nnC].e[edgeC].ng = (STOPNUM)nnB;

  00605	8b 4d d4	 mov	 ecx, DWORD PTR _nnC$3[ebp]
  00608	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0060b	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  0060f	8b 4d cc	 mov	 ecx, DWORD PTR _edgeC$1[ebp]
  00612	8a 55 d8	 mov	 dl, BYTE PTR _nnB$4[ebp]
  00615	88 14 48	 mov	 BYTE PTR [eax+ecx*2], dl

; 262  :         sd[nnB][edgeB].ne = (EDGENUM)edgeC;

  00618	8b 45 d8	 mov	 eax, DWORD PTR _nnB$4[ebp]
  0061b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0061e	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  00625	8b 45 d0	 mov	 eax, DWORD PTR _edgeB$2[ebp]
  00628	8a 4d cc	 mov	 cl, BYTE PTR _edgeC$1[ebp]
  0062b	88 4c 42 01	 mov	 BYTE PTR [edx+eax*2+1], cl

; 263  :         sd[nnC][edgeC].ne = (EDGENUM)edgeB;

  0062f	8b 55 d4	 mov	 edx, DWORD PTR _nnC$3[ebp]
  00632	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00635	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  0063c	8b 55 cc	 mov	 edx, DWORD PTR _edgeC$1[ebp]
  0063f	8a 45 d0	 mov	 al, BYTE PTR _edgeB$2[ebp]
  00642	88 44 51 01	 mov	 BYTE PTR [ecx+edx*2+1], al

; 264  :         ed[nnB].e[edgeB].el = (EDGELEN)len;

  00646	8b 4d d8	 mov	 ecx, DWORD PTR _nnB$4[ebp]
  00649	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0064c	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  00650	8b 4d d0	 mov	 ecx, DWORD PTR _edgeB$2[ebp]
  00653	8a 55 dc	 mov	 dl, BYTE PTR _len$5[ebp]
  00656	88 54 48 01	 mov	 BYTE PTR [eax+ecx*2+1], dl

; 265  :         ed[nnC].e[edgeC].el = (EDGELEN)len;

  0065a	8b 45 d4	 mov	 eax, DWORD PTR _nnC$3[ebp]
  0065d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00660	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  00664	8b 45 cc	 mov	 eax, DWORD PTR _edgeC$1[ebp]
  00667	8a 4d dc	 mov	 cl, BYTE PTR _len$5[ebp]
  0066a	88 4c 42 01	 mov	 BYTE PTR [edx+eax*2+1], cl
$LN22@CombineEdg:

; 266  :       };
; 267  :       return true;

  0066e	b0 01		 mov	 al, 1
$LN1@CombineEdg:

; 268  :     };
; 269  :   };
; 270  : }

  00670	5f		 pop	 edi
  00671	83 c4 34	 add	 esp, 52			; 00000034H
  00674	3b ec		 cmp	 ebp, esp
  00676	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0067b	8b e5		 mov	 esp, ebp
  0067d	5d		 pop	 ebp
  0067e	c2 04 00	 ret	 4
?CombineEdges@NIMCON@@QAE_NH@Z ENDP			; NIMCON::CombineEdges
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Nimstring.cpp
_TEXT	SEGMENT
_h2$ = -20						; size = 4
_h1$ = -16						; size = 4
_nnA$ = -12						; size = 4
_nn$ = -8						; size = 4
_this$ = -4						; size = 4
_nnFirst$ = 8						; size = 4
_nnLast$ = 12						; size = 4
?NimHash@NIMCON@@QAE_KHH@Z PROC				; NIMCON::NimHash
; _this$ = ecx

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 73   :   int nn, nnA;
; 74   :   ui32 h1, h2;
; 75   :   h1 = h2 = 0;

  0001d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _h2$[ebp], 0
  00024	8b 45 ec	 mov	 eax, DWORD PTR _h2$[ebp]
  00027	89 45 f0	 mov	 DWORD PTR _h1$[ebp], eax

; 76   :   for (nn = nnFirst; nn<nnLast; nn++)

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _nnFirst$[ebp]
  0002d	89 4d f8	 mov	 DWORD PTR _nn$[ebp], ecx
  00030	eb 09		 jmp	 SHORT $LN4@NimHash
$LN2@NimHash:
  00032	8b 55 f8	 mov	 edx, DWORD PTR _nn$[ebp]
  00035	83 c2 01	 add	 edx, 1
  00038	89 55 f8	 mov	 DWORD PTR _nn$[ebp], edx
$LN4@NimHash:
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _nn$[ebp]
  0003e	3b 45 0c	 cmp	 eax, DWORD PTR _nnLast$[ebp]
  00041	7d 68		 jge	 SHORT $LN3@NimHash

; 77   :   {
; 78   :     nnA = nd[nn].ix;

  00043	8b 4d f8	 mov	 ecx, DWORD PTR _nn$[ebp]
  00046	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00049	0f b6 84 8a 13
	10 00 00	 movzx	 eax, BYTE PTR [edx+ecx*4+4115]
  00051	89 45 f4	 mov	 DWORD PTR _nnA$[ebp], eax

; 79   :     h1 = h1*373733 + *((ui32 *)(&ed[nnA].e[0]));

  00054	69 4d f0 e5 b3
	05 00		 imul	 ecx, DWORD PTR _h1$[ebp], 373733
  0005b	8b 55 f4	 mov	 edx, DWORD PTR _nnA$[ebp]
  0005e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8d 54 d0 10	 lea	 edx, DWORD PTR [eax+edx*8+16]
  00065	b8 02 00 00 00	 mov	 eax, 2
  0006a	6b c0 00	 imul	 eax, eax, 0
  0006d	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  00070	89 4d f0	 mov	 DWORD PTR _h1$[ebp], ecx

; 80   :     h2 = h2*434347 + *((ui32 *)(&ed[nnA].e[2]));

  00073	69 4d ec ab a0
	06 00		 imul	 ecx, DWORD PTR _h2$[ebp], 434347
  0007a	8b 55 f4	 mov	 edx, DWORD PTR _nnA$[ebp]
  0007d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8d 54 d0 10	 lea	 edx, DWORD PTR [eax+edx*8+16]
  00084	b8 02 00 00 00	 mov	 eax, 2
  00089	d1 e0		 shl	 eax, 1
  0008b	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  0008e	89 4d ec	 mov	 DWORD PTR _h2$[ebp], ecx

; 81   :     h1 ^= h2 >> 21;

  00091	8b 4d ec	 mov	 ecx, DWORD PTR _h2$[ebp]
  00094	c1 e9 15	 shr	 ecx, 21			; 00000015H
  00097	33 4d f0	 xor	 ecx, DWORD PTR _h1$[ebp]
  0009a	89 4d f0	 mov	 DWORD PTR _h1$[ebp], ecx

; 82   :     h2 ^= h1 >> 23;

  0009d	8b 55 f0	 mov	 edx, DWORD PTR _h1$[ebp]
  000a0	c1 ea 17	 shr	 edx, 23			; 00000017H
  000a3	33 55 ec	 xor	 edx, DWORD PTR _h2$[ebp]
  000a6	89 55 ec	 mov	 DWORD PTR _h2$[ebp], edx

; 83   :   };

  000a9	eb 87		 jmp	 SHORT $LN2@NimHash
$LN3@NimHash:

; 84   :   return ((ui64)h1<<32) + h2;

  000ab	33 d2		 xor	 edx, edx
  000ad	8b 45 f0	 mov	 eax, DWORD PTR _h1$[ebp]
  000b0	b1 20		 mov	 cl, 32			; 00000020H
  000b2	e8 00 00 00 00	 call	 __allshl
  000b7	33 c9		 xor	 ecx, ecx
  000b9	03 45 ec	 add	 eax, DWORD PTR _h2$[ebp]
  000bc	13 d1		 adc	 edx, ecx

; 85   : }

  000be	83 c4 14	 add	 esp, 20			; 00000014H
  000c1	3b ec		 cmp	 ebp, esp
  000c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 08 00	 ret	 8
?NimHash@NIMCON@@QAE_KHH@Z ENDP				; NIMCON::NimHash
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Nimstring.cpp
_TEXT	SEGMENT
_nnA$ = -12						; size = 4
_nn$ = -8						; size = 4
_this$ = -4						; size = 4
_con$ = 8						; size = 4
??4NIMCON@@QAEAAV0@PBVCON@@@Z PROC			; NIMCON::operator=
; _this$ = ecx

; 716  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 717  :   int nn, nnA;
; 718  :   m_numNode        = con->m_numNode;

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _con$[ebp]
  00024	8b 11		 mov	 edx, DWORD PTR [ecx]
  00026	89 10		 mov	 DWORD PTR [eax], edx

; 719  :   for (nn=0; nn<m_numNode; nn++)

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nn$[ebp], 0
  0002f	eb 09		 jmp	 SHORT $LN4@operator
$LN2@operator:
  00031	8b 45 f8	 mov	 eax, DWORD PTR _nn$[ebp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 45 f8	 mov	 DWORD PTR _nn$[ebp], eax
$LN4@operator:
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8b 55 f8	 mov	 edx, DWORD PTR _nn$[ebp]
  00040	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00042	0f 8d 20 01 00
	00		 jge	 $LN3@operator

; 720  :   {
; 721  :     nnA = con->nd[nn].ix;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _nn$[ebp]
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _con$[ebp]
  0004e	0f b6 94 81 13
	10 00 00	 movzx	 edx, BYTE PTR [ecx+eax*4+4115]
  00056	89 55 f4	 mov	 DWORD PTR _nnA$[ebp], edx

; 722  :     nd[nn].ix = (STOPNUM)nnA;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _nn$[ebp]
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	8a 55 f4	 mov	 dl, BYTE PTR _nnA$[ebp]
  00062	88 94 81 13 10
	00 00		 mov	 BYTE PTR [ecx+eax*4+4115], dl

; 723  :     sd[nnA][0] = con->sd[nnA][0];

  00069	8b 45 f4	 mov	 eax, DWORD PTR _nnA$[ebp]
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _con$[ebp]
  0006f	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  00076	b8 02 00 00 00	 mov	 eax, 2
  0007b	6b c8 00	 imul	 ecx, eax, 0
  0007e	66 8b 14 0a	 mov	 dx, WORD PTR [edx+ecx]
  00082	8b 45 f4	 mov	 eax, DWORD PTR _nnA$[ebp]
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	8d 84 c1 10 08
	00 00		 lea	 eax, DWORD PTR [ecx+eax*8+2064]
  0008f	b9 02 00 00 00	 mov	 ecx, 2
  00094	6b c9 00	 imul	 ecx, ecx, 0
  00097	66 89 14 08	 mov	 WORD PTR [eax+ecx], dx

; 724  :     sd[nnA][1] = con->sd[nnA][1];

  0009b	8b 55 f4	 mov	 edx, DWORD PTR _nnA$[ebp]
  0009e	8b 45 08	 mov	 eax, DWORD PTR _con$[ebp]
  000a1	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  000a8	ba 02 00 00 00	 mov	 edx, 2
  000ad	c1 e2 00	 shl	 edx, 0
  000b0	66 8b 04 11	 mov	 ax, WORD PTR [ecx+edx]
  000b4	8b 4d f4	 mov	 ecx, DWORD PTR _nnA$[ebp]
  000b7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ba	8d 8c ca 10 08
	00 00		 lea	 ecx, DWORD PTR [edx+ecx*8+2064]
  000c1	ba 02 00 00 00	 mov	 edx, 2
  000c6	c1 e2 00	 shl	 edx, 0
  000c9	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax

; 725  :     sd[nnA][2] = con->sd[nnA][2];

  000cd	8b 45 f4	 mov	 eax, DWORD PTR _nnA$[ebp]
  000d0	8b 4d 08	 mov	 ecx, DWORD PTR _con$[ebp]
  000d3	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  000da	b8 02 00 00 00	 mov	 eax, 2
  000df	d1 e0		 shl	 eax, 1
  000e1	66 8b 0c 02	 mov	 cx, WORD PTR [edx+eax]
  000e5	8b 55 f4	 mov	 edx, DWORD PTR _nnA$[ebp]
  000e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8d 94 d0 10 08
	00 00		 lea	 edx, DWORD PTR [eax+edx*8+2064]
  000f2	b8 02 00 00 00	 mov	 eax, 2
  000f7	d1 e0		 shl	 eax, 1
  000f9	66 89 0c 02	 mov	 WORD PTR [edx+eax], cx

; 726  :     sd[nnA][3] = con->sd[nnA][3];

  000fd	8b 4d f4	 mov	 ecx, DWORD PTR _nnA$[ebp]
  00100	8b 55 08	 mov	 edx, DWORD PTR _con$[ebp]
  00103	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  0010a	b9 02 00 00 00	 mov	 ecx, 2
  0010f	6b d1 03	 imul	 edx, ecx, 3
  00112	66 8b 04 10	 mov	 ax, WORD PTR [eax+edx]
  00116	8b 4d f4	 mov	 ecx, DWORD PTR _nnA$[ebp]
  00119	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0011c	8d 8c ca 10 08
	00 00		 lea	 ecx, DWORD PTR [edx+ecx*8+2064]
  00123	ba 02 00 00 00	 mov	 edx, 2
  00128	6b d2 03	 imul	 edx, edx, 3
  0012b	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax

; 727  :     ed[nnA] = con->ed[nnA];

  0012f	8b 45 f4	 mov	 eax, DWORD PTR _nnA$[ebp]
  00132	8b 4d 08	 mov	 ecx, DWORD PTR _con$[ebp]
  00135	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  00139	52		 push	 edx
  0013a	8b 45 f4	 mov	 eax, DWORD PTR _nnA$[ebp]
  0013d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00140	8d 4c c1 10	 lea	 ecx, DWORD PTR [ecx+eax*8+16]
  00144	e8 00 00 00 00	 call	 ??4EDGEDATA@@QAEXABU0@@Z ; EDGEDATA::operator=

; 728  :     nd[nnA] = con->nd[nnA];

  00149	8b 55 f4	 mov	 edx, DWORD PTR _nnA$[ebp]
  0014c	8b 45 08	 mov	 eax, DWORD PTR _con$[ebp]
  0014f	8b 8c 90 10 10
	00 00		 mov	 ecx, DWORD PTR [eax+edx*4+4112]
  00156	8b 55 f4	 mov	 edx, DWORD PTR _nnA$[ebp]
  00159	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0015c	89 8c 90 10 10
	00 00		 mov	 DWORD PTR [eax+edx*4+4112], ecx

; 729  :   };

  00163	e9 c9 fe ff ff	 jmp	 $LN2@operator
$LN3@operator:

; 730  :   return *this;

  00168	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 731  : }

  0016b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016e	3b ec		 cmp	 ebp, esp
  00170	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00175	8b e5		 mov	 esp, ebp
  00177	5d		 pop	 ebp
  00178	c2 04 00	 ret	 4
??4NIMCON@@QAEAAV0@PBVCON@@@Z ENDP			; NIMCON::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Nimstring.cpp
_TEXT	SEGMENT
$T2 = -5888						; size = 4
$T3 = -5884						; size = 4
$T4 = -5880						; size = 4
$T5 = -5876						; size = 4
_r$6 = -5872						; size = 4
_val$7 = -5868						; size = 4
_nnA$8 = -5864						; size = 4
_last$9 = -5856						; size = 4
_nnB$10 = -5848						; size = 4
_nnA$11 = -5844						; size = 4
_last$12 = -5836					; size = 4
_ec$13 = -5828						; size = 4
_ts$14 = -5821						; size = 1
_lastNode$15 = -5820					; size = 4
_j$16 = -5816						; size = 4
_toVisit$17 = -5808					; size = 440
_nnCurrent$18 = -5364					; size = 4
_neighborA$19 = -5360					; size = 4
_neighbor$20 = -5356					; size = 4
_numVisited$21 = -5352					; size = 4
_numToVisit$22 = -5348					; size = 4
_en$23 = -5344						; size = 4
_nnA$24 = -5340						; size = 4
_nn$25 = -5336						; size = 4
_myCount$ = -5332					; size = 4
_hash$ = -5328						; size = 8
_result$ = -5320					; size = 4
_mex$ = -5316						; size = 4
_nimcon$ = -5308					; size = 5136
_hashIndex$ = -168					; size = 4
_visited$ = -160					; size = 117
_pVisited$ = -36					; size = 4
_n$ = -32						; size = 4
_i$ = -28						; size = 4
_firstNode$ = -24					; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_nnFirst$ = 8						; size = 4
_nnLast$ = 12						; size = 4
?NimVal@NIMCON@@QAEHHH@Z PROC				; NIMCON::NimVal
; _this$ = ecx

; 351  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?NimVal@NIMCON@@QAEHHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 f4 16 00 00	 mov	 eax, 5876		; 000016f4H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	51		 push	 ecx
  0001e	8d bd 00 e9 ff
	ff		 lea	 edi, DWORD PTR [ebp-5888]
  00024	b9 bd 05 00 00	 mov	 ecx, 1469		; 000005bdH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	59		 pop	 ecx
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00036	33 c5		 xor	 eax, ebp
  00038	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003b	50		 push	 eax
  0003c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00045	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 352  :   //Method:
; 353  :   //1) Divide into separate strings.
; 354  :   //   For each string:
; 355  :   //   a) Simplify
; 356  :   //   b) Canon
; 357  :   //   c) Check cached values
; 358  :   //   d) For each possible move
; 359  :   //      1) Copy to free area.
; 360  :   //      2) Make the move.
; 361  :   //      3) Get its nim value.
; 362  :   int firstNode, i, n;
; 363  :   ui64 *pVisited;
; 364  :   ui8 visited[MAX_NODES+7];
; 365  :   i32 hashIndex;
; 366  :   NIMCON nimcon;

  00048	8d 8d 44 eb ff
	ff		 lea	 ecx, DWORD PTR _nimcon$[ebp]
  0004e	e8 00 00 00 00	 call	 ??0NIMCON@@QAE@XZ
  00053	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 367  :   ui32 mex;
; 368  :   ui32 result=0;

  0005a	c7 85 38 eb ff
	ff 00 00 00 00	 mov	 DWORD PTR _result$[ebp], 0

; 369  :   ASSERT(nnLast > nnFirst);

  00064	8b 45 0c	 mov	 eax, DWORD PTR _nnLast$[ebp]
  00067	3b 45 08	 cmp	 eax, DWORD PTR _nnFirst$[ebp]
  0006a	7f 14		 jg	 SHORT $LN57@NimVal
  0006c	68 71 01 00 00	 push	 369			; 00000171H
  00071	68 00 00 00 00	 push	 OFFSET $SG225599
  00076	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0007b	85 c0		 test	 eax, eax
  0007d	74 01		 je	 SHORT $LN57@NimVal
  0007f	cc		 int	 3
$LN57@NimVal:

; 370  :   ui64 hash;
; 371  :   searchDepth++;

  00080	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?searchDepth@@3HA ; searchDepth
  00086	83 c2 01	 add	 edx, 1
  00089	89 15 00 00 00
	00		 mov	 DWORD PTR ?searchDepth@@3HA, edx ; searchDepth

; 372  : #ifdef _DEBUG
; 373  :   count++;

  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?count@@3HA
  00094	83 c0 01	 add	 eax, 1
  00097	a3 00 00 00 00	 mov	 DWORD PTR ?count@@3HA, eax

; 374  :   i32 myCount;
; 375  :   myCount = count;

  0009c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?count@@3HA
  000a2	89 8d 2c eb ff
	ff		 mov	 DWORD PTR _myCount$[ebp], ecx

; 376  : #endif
; 377  : #ifdef NS_DUMP
; 378  :   LOGUIUI("%d Enter NimVal", myCount, 0);
; 379  :   DUMP("Entering NimVal",myCount,0,0,nnFirst,nnLast);
; 380  : #endif
; 381  :   ASSERT(!Simplify(nnFirst, nnLast));

  000a8	8b 55 0c	 mov	 edx, DWORD PTR _nnLast$[ebp]
  000ab	52		 push	 edx
  000ac	8b 45 08	 mov	 eax, DWORD PTR _nnFirst$[ebp]
  000af	50		 push	 eax
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	e8 00 00 00 00	 call	 ?Simplify@NIMCON@@QAE_NHH@Z ; NIMCON::Simplify
  000b8	0f b6 c8	 movzx	 ecx, al
  000bb	85 c9		 test	 ecx, ecx
  000bd	74 14		 je	 SHORT $LN58@NimVal
  000bf	68 7d 01 00 00	 push	 381			; 0000017dH
  000c4	68 00 00 00 00	 push	 OFFSET $SG225600
  000c9	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  000ce	85 c0		 test	 eax, eax
  000d0	74 01		 je	 SHORT $LN58@NimVal
  000d2	cc		 int	 3
$LN58@NimVal:

; 382  :   n = (unsigned)(nnLast+7)/8;

  000d3	8b 45 0c	 mov	 eax, DWORD PTR _nnLast$[ebp]
  000d6	83 c0 07	 add	 eax, 7
  000d9	c1 e8 03	 shr	 eax, 3
  000dc	89 45 e0	 mov	 DWORD PTR _n$[ebp], eax

; 383  :   pVisited = (ui64 *)visited;

  000df	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _visited$[ebp]
  000e5	89 4d dc	 mov	 DWORD PTR _pVisited$[ebp], ecx

; 384  :   for (i=0; i<n; i++)

  000e8	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ef	eb 09		 jmp	 SHORT $LN4@NimVal
$LN2@NimVal:
  000f1	8b 55 e4	 mov	 edx, DWORD PTR _i$[ebp]
  000f4	83 c2 01	 add	 edx, 1
  000f7	89 55 e4	 mov	 DWORD PTR _i$[ebp], edx
$LN4@NimVal:
  000fa	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  000fd	3b 45 e0	 cmp	 eax, DWORD PTR _n$[ebp]
  00100	7d 17		 jge	 SHORT $LN3@NimVal

; 385  :   {
; 386  :     *(pVisited++) = 0;

  00102	8b 4d dc	 mov	 ecx, DWORD PTR _pVisited$[ebp]
  00105	33 d2		 xor	 edx, edx
  00107	33 c0		 xor	 eax, eax
  00109	89 11		 mov	 DWORD PTR [ecx], edx
  0010b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0010e	8b 4d dc	 mov	 ecx, DWORD PTR _pVisited$[ebp]
  00111	83 c1 08	 add	 ecx, 8
  00114	89 4d dc	 mov	 DWORD PTR _pVisited$[ebp], ecx

; 387  :   };

  00117	eb d8		 jmp	 SHORT $LN2@NimVal
$LN3@NimVal:

; 388  :   firstNode = nnFirst;

  00119	8b 55 08	 mov	 edx, DWORD PTR _nnFirst$[ebp]
  0011c	89 55 e8	 mov	 DWORD PTR _firstNode$[ebp], edx
$LN5@NimVal:

; 389  :   {
; 390  :     int nn, nnA, en, numToVisit, numVisited, neighbor, neighborA;;   int nnCurrent;
; 391  :     int toVisit[MAX_NODES];
; 392  :     int j;
; 393  :     while (firstNode < nnLast)

  0011f	8b 45 e8	 mov	 eax, DWORD PTR _firstNode$[ebp]
  00122	3b 45 0c	 cmp	 eax, DWORD PTR _nnLast$[ebp]
  00125	0f 8d 44 0b 00
	00		 jge	 $LN6@NimVal

; 394  :     {
; 395  :       int lastNode;
; 396  :       numToVisit = 1;

  0012b	c7 85 1c eb ff
	ff 01 00 00 00	 mov	 DWORD PTR _numToVisit$22[ebp], 1

; 397  :       numVisited = 0;

  00135	c7 85 18 eb ff
	ff 00 00 00 00	 mov	 DWORD PTR _numVisited$21[ebp], 0

; 398  :       toVisit[0] = firstNode;

  0013f	b9 04 00 00 00	 mov	 ecx, 4
  00144	6b d1 00	 imul	 edx, ecx, 0
  00147	8b 45 e8	 mov	 eax, DWORD PTR _firstNode$[ebp]
  0014a	89 84 15 50 e9
	ff ff		 mov	 DWORD PTR _toVisit$17[ebp+edx], eax

; 399  :       visited[firstNode] = 1;

  00151	8b 4d e8	 mov	 ecx, DWORD PTR _firstNode$[ebp]
  00154	c6 84 0d 60 ff
	ff ff 01	 mov	 BYTE PTR _visited$[ebp+ecx], 1
$LN7@NimVal:

; 400  :       while (numVisited < numToVisit)

  0015c	8b 95 18 eb ff
	ff		 mov	 edx, DWORD PTR _numVisited$21[ebp]
  00162	3b 95 1c eb ff
	ff		 cmp	 edx, DWORD PTR _numToVisit$22[ebp]
  00168	0f 8d 46 01 00
	00		 jge	 $LN8@NimVal

; 401  :       {
; 402  :         nnCurrent = toVisit[numVisited++];

  0016e	8b 85 18 eb ff
	ff		 mov	 eax, DWORD PTR _numVisited$21[ebp]
  00174	8b 8c 85 50 e9
	ff ff		 mov	 ecx, DWORD PTR _toVisit$17[ebp+eax*4]
  0017b	89 8d 0c eb ff
	ff		 mov	 DWORD PTR _nnCurrent$18[ebp], ecx
  00181	8b 95 18 eb ff
	ff		 mov	 edx, DWORD PTR _numVisited$21[ebp]
  00187	83 c2 01	 add	 edx, 1
  0018a	89 95 18 eb ff
	ff		 mov	 DWORD PTR _numVisited$21[ebp], edx

; 403  :         //if (visited[nnCurrent] != 0) continue;
; 404  :         //visited[nnCurrent] = 1;
; 405  :         nnA = nd[nnCurrent].ix;

  00190	8b 85 0c eb ff
	ff		 mov	 eax, DWORD PTR _nnCurrent$18[ebp]
  00196	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00199	0f b6 94 81 13
	10 00 00	 movzx	 edx, BYTE PTR [ecx+eax*4+4115]
  001a1	89 95 24 eb ff
	ff		 mov	 DWORD PTR _nnA$24[ebp], edx

; 406  :         if (IS_ISOLATED(sd[nnA][0].ns))

  001a7	8b 85 24 eb ff
	ff		 mov	 eax, DWORD PTR _nnA$24[ebp]
  001ad	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001b0	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  001b7	b8 02 00 00 00	 mov	 eax, 2
  001bc	6b c8 00	 imul	 ecx, eax, 0
  001bf	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  001c3	81 fa fa 00 00
	00		 cmp	 edx, 250		; 000000faH
  001c9	7e 22		 jle	 SHORT $LN32@NimVal

; 407  :         {
; 408  :           ASSERT(numVisited == 1);

  001cb	83 bd 18 eb ff
	ff 01		 cmp	 DWORD PTR _numVisited$21[ebp], 1
  001d2	74 14		 je	 SHORT $LN59@NimVal
  001d4	68 98 01 00 00	 push	 408			; 00000198H
  001d9	68 00 00 00 00	 push	 OFFSET $SG225603
  001de	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  001e3	85 c0		 test	 eax, eax
  001e5	74 01		 je	 SHORT $LN59@NimVal
  001e7	cc		 int	 3
$LN59@NimVal:

; 409  :         }

  001e8	e9 c2 00 00 00	 jmp	 $LN33@NimVal
$LN32@NimVal:

; 410  :         else
; 411  :         {
; 412  :           for (en=0; en<nd[nnA].ec; en++)

  001ed	c7 85 20 eb ff
	ff 00 00 00 00	 mov	 DWORD PTR _en$23[ebp], 0
  001f7	eb 0f		 jmp	 SHORT $LN11@NimVal
$LN9@NimVal:
  001f9	8b 8d 20 eb ff
	ff		 mov	 ecx, DWORD PTR _en$23[ebp]
  001ff	83 c1 01	 add	 ecx, 1
  00202	89 8d 20 eb ff
	ff		 mov	 DWORD PTR _en$23[ebp], ecx
$LN11@NimVal:
  00208	8b 95 24 eb ff
	ff		 mov	 edx, DWORD PTR _nnA$24[ebp]
  0020e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00211	0f b6 8c 90 10
	10 00 00	 movzx	 ecx, BYTE PTR [eax+edx*4+4112]
  00219	39 8d 20 eb ff
	ff		 cmp	 DWORD PTR _en$23[ebp], ecx
  0021f	0f 8d 8a 00 00
	00		 jge	 $LN33@NimVal

; 413  :           {
; 414  :             neighborA = sd[nnA][en].ns;

  00225	8b 95 24 eb ff
	ff		 mov	 edx, DWORD PTR _nnA$24[ebp]
  0022b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0022e	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  00235	8b 95 20 eb ff
	ff		 mov	 edx, DWORD PTR _en$23[ebp]
  0023b	0f b6 04 51	 movzx	 eax, BYTE PTR [ecx+edx*2]
  0023f	89 85 10 eb ff
	ff		 mov	 DWORD PTR _neighborA$19[ebp], eax

; 415  :             if (IS_A_NODE(neighborA))

  00245	81 bd 10 eb ff
	ff f9 00 00 00	 cmp	 DWORD PTR _neighborA$19[ebp], 249 ; 000000f9H
  0024f	7d 59		 jge	 SHORT $LN34@NimVal

; 416  :             {
; 417  :               neighbor = nd[neighborA].os;

  00251	8b 8d 10 eb ff
	ff		 mov	 ecx, DWORD PTR _neighborA$19[ebp]
  00257	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0025a	0f b6 84 8a 12
	10 00 00	 movzx	 eax, BYTE PTR [edx+ecx*4+4114]
  00262	89 85 14 eb ff
	ff		 mov	 DWORD PTR _neighbor$20[ebp], eax

; 418  :               if (visited[neighbor] == 0)

  00268	8b 8d 14 eb ff
	ff		 mov	 ecx, DWORD PTR _neighbor$20[ebp]
  0026e	0f b6 94 0d 60
	ff ff ff	 movzx	 edx, BYTE PTR _visited$[ebp+ecx]
  00276	85 d2		 test	 edx, edx
  00278	75 30		 jne	 SHORT $LN34@NimVal

; 419  :               {
; 420  :                 visited[neighbor] = 1;

  0027a	8b 85 14 eb ff
	ff		 mov	 eax, DWORD PTR _neighbor$20[ebp]
  00280	c6 84 05 60 ff
	ff ff 01	 mov	 BYTE PTR _visited$[ebp+eax], 1

; 421  :                 toVisit[numToVisit++] = neighbor;

  00288	8b 8d 1c eb ff
	ff		 mov	 ecx, DWORD PTR _numToVisit$22[ebp]
  0028e	8b 95 14 eb ff
	ff		 mov	 edx, DWORD PTR _neighbor$20[ebp]
  00294	89 94 8d 50 e9
	ff ff		 mov	 DWORD PTR _toVisit$17[ebp+ecx*4], edx
  0029b	8b 85 1c eb ff
	ff		 mov	 eax, DWORD PTR _numToVisit$22[ebp]
  002a1	83 c0 01	 add	 eax, 1
  002a4	89 85 1c eb ff
	ff		 mov	 DWORD PTR _numToVisit$22[ebp], eax
$LN34@NimVal:

; 422  :               };
; 423  :             };
; 424  :           };

  002aa	e9 4a ff ff ff	 jmp	 $LN9@NimVal
$LN33@NimVal:

; 425  :         };
; 426  :       };

  002af	e9 a8 fe ff ff	 jmp	 $LN7@NimVal
$LN8@NimVal:

; 427  :       //Now collect all the visited nodes together
; 428  :       j = firstNode;

  002b4	8b 4d e8	 mov	 ecx, DWORD PTR _firstNode$[ebp]
  002b7	89 8d 48 e9 ff
	ff		 mov	 DWORD PTR _j$16[ebp], ecx

; 429  :       nn = firstNode;

  002bd	8b 55 e8	 mov	 edx, DWORD PTR _firstNode$[ebp]
  002c0	89 95 28 eb ff
	ff		 mov	 DWORD PTR _nn$25[ebp], edx

; 430  :       lastNode = firstNode + numVisited;

  002c6	8b 45 e8	 mov	 eax, DWORD PTR _firstNode$[ebp]
  002c9	03 85 18 eb ff
	ff		 add	 eax, DWORD PTR _numVisited$21[ebp]
  002cf	89 85 44 e9 ff
	ff		 mov	 DWORD PTR _lastNode$15[ebp], eax

; 431  :       for (i=0; i<numVisited; i++)

  002d5	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  002dc	eb 09		 jmp	 SHORT $LN14@NimVal
$LN12@NimVal:
  002de	8b 4d e4	 mov	 ecx, DWORD PTR _i$[ebp]
  002e1	83 c1 01	 add	 ecx, 1
  002e4	89 4d e4	 mov	 DWORD PTR _i$[ebp], ecx
$LN14@NimVal:
  002e7	8b 55 e4	 mov	 edx, DWORD PTR _i$[ebp]
  002ea	3b 95 18 eb ff
	ff		 cmp	 edx, DWORD PTR _numVisited$21[ebp]
  002f0	0f 8d 16 01 00
	00		 jge	 $LN13@NimVal

; 432  :       {
; 433  :         if (toVisit[i] < lastNode) continue;

  002f6	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  002f9	8b 8c 85 50 e9
	ff ff		 mov	 ecx, DWORD PTR _toVisit$17[ebp+eax*4]
  00300	3b 8d 44 e9 ff
	ff		 cmp	 ecx, DWORD PTR _lastNode$15[ebp]
  00306	7d 02		 jge	 SHORT $LN15@NimVal
  00308	eb d4		 jmp	 SHORT $LN12@NimVal
$LN15@NimVal:

; 434  :         //We have to move toVisit[i] into the collection
; 435  :         //of visited nodes.
; 436  :         //Find an unvisited node to swap with.
; 437  :         while (visited[j] != 0) j++;

  0030a	8b 95 48 e9 ff
	ff		 mov	 edx, DWORD PTR _j$16[ebp]
  00310	0f b6 84 15 60
	ff ff ff	 movzx	 eax, BYTE PTR _visited$[ebp+edx]
  00318	85 c0		 test	 eax, eax
  0031a	74 11		 je	 SHORT $LN16@NimVal
  0031c	8b 8d 48 e9 ff
	ff		 mov	 ecx, DWORD PTR _j$16[ebp]
  00322	83 c1 01	 add	 ecx, 1
  00325	89 8d 48 e9 ff
	ff		 mov	 DWORD PTR _j$16[ebp], ecx
  0032b	eb dd		 jmp	 SHORT $LN15@NimVal
$LN16@NimVal:

; 438  :         SwapNode(j, toVisit[i]);

  0032d	8b 95 48 e9 ff
	ff		 mov	 edx, DWORD PTR _j$16[ebp]
  00333	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00336	8a 8c 90 13 10
	00 00		 mov	 cl, BYTE PTR [eax+edx*4+4115]
  0033d	88 8d 43 e9 ff
	ff		 mov	 BYTE PTR _ts$14[ebp], cl
  00343	8b 55 e4	 mov	 edx, DWORD PTR _i$[ebp]
  00346	8b 84 95 50 e9
	ff ff		 mov	 eax, DWORD PTR _toVisit$17[ebp+edx*4]
  0034d	8b 8d 48 e9 ff
	ff		 mov	 ecx, DWORD PTR _j$16[ebp]
  00353	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00356	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00359	8a 84 86 13 10
	00 00		 mov	 al, BYTE PTR [esi+eax*4+4115]
  00360	88 84 8a 13 10
	00 00		 mov	 BYTE PTR [edx+ecx*4+4115], al
  00367	8b 4d e4	 mov	 ecx, DWORD PTR _i$[ebp]
  0036a	8b 94 8d 50 e9
	ff ff		 mov	 edx, DWORD PTR _toVisit$17[ebp+ecx*4]
  00371	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00374	8a 8d 43 e9 ff
	ff		 mov	 cl, BYTE PTR _ts$14[ebp]
  0037a	88 8c 90 13 10
	00 00		 mov	 BYTE PTR [eax+edx*4+4115], cl
  00381	8b 95 48 e9 ff
	ff		 mov	 edx, DWORD PTR _j$16[ebp]
  00387	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0038a	0f b6 8c 90 13
	10 00 00	 movzx	 ecx, BYTE PTR [eax+edx*4+4115]
  00392	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00395	8a 85 48 e9 ff
	ff		 mov	 al, BYTE PTR _j$16[ebp]
  0039b	88 84 8a 12 10
	00 00		 mov	 BYTE PTR [edx+ecx*4+4114], al
  003a2	8b 4d e4	 mov	 ecx, DWORD PTR _i$[ebp]
  003a5	8b 94 8d 50 e9
	ff ff		 mov	 edx, DWORD PTR _toVisit$17[ebp+ecx*4]
  003ac	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  003af	0f b6 8c 90 13
	10 00 00	 movzx	 ecx, BYTE PTR [eax+edx*4+4115]
  003b7	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  003ba	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  003bd	8a 84 85 50 e9
	ff ff		 mov	 al, BYTE PTR _toVisit$17[ebp+eax*4]
  003c4	88 84 8a 12 10
	00 00		 mov	 BYTE PTR [edx+ecx*4+4114], al

; 439  :         visited[toVisit[i]] = 0;

  003cb	8b 4d e4	 mov	 ecx, DWORD PTR _i$[ebp]
  003ce	8b 94 8d 50 e9
	ff ff		 mov	 edx, DWORD PTR _toVisit$17[ebp+ecx*4]
  003d5	89 95 0c e9 ff
	ff		 mov	 DWORD PTR $T5[ebp], edx
  003db	83 bd 0c e9 ff
	ff 75		 cmp	 DWORD PTR $T5[ebp], 117	; 00000075H
  003e2	73 02		 jae	 SHORT $LN60@NimVal
  003e4	eb 05		 jmp	 SHORT $LN61@NimVal
$LN60@NimVal:
  003e6	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN61@NimVal:
  003eb	8b 85 0c e9 ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]
  003f1	c6 84 05 60 ff
	ff ff 00	 mov	 BYTE PTR _visited$[ebp+eax], 0

; 440  :         visited[j] = 1;

  003f9	8b 8d 48 e9 ff
	ff		 mov	 ecx, DWORD PTR _j$16[ebp]
  003ff	c6 84 0d 60 ff
	ff ff 01	 mov	 BYTE PTR _visited$[ebp+ecx], 1

; 441  :       };

  00407	e9 d2 fe ff ff	 jmp	 $LN12@NimVal
$LN13@NimVal:

; 442  :       if (IS_ISOLATED(sd[nd[firstNode].ix][0].ns))

  0040c	8b 55 e8	 mov	 edx, DWORD PTR _firstNode$[ebp]
  0040f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00412	0f b6 8c 90 13
	10 00 00	 movzx	 ecx, BYTE PTR [eax+edx*4+4115]
  0041a	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0041d	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  00424	b9 02 00 00 00	 mov	 ecx, 2
  00429	6b d1 00	 imul	 edx, ecx, 0
  0042c	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  00430	3d fa 00 00 00	 cmp	 eax, 250		; 000000faH
  00435	0f 8e ab 00 00
	00		 jle	 $LN37@NimVal

; 443  :       {
; 444  :         //This is an isolated string.  easy to compute the nimstring value
; 445  :         nnA = nd[firstNode].ix;

  0043b	8b 4d e8	 mov	 ecx, DWORD PTR _firstNode$[ebp]
  0043e	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00441	0f b6 84 8a 13
	10 00 00	 movzx	 eax, BYTE PTR [edx+ecx*4+4115]
  00449	89 85 24 eb ff
	ff		 mov	 DWORD PTR _nnA$24[ebp], eax

; 446  :         if (sd[nnA][0].ns == GND_GND)

  0044f	8b 8d 24 eb ff
	ff		 mov	 ecx, DWORD PTR _nnA$24[ebp]
  00455	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00458	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  0045f	b9 02 00 00 00	 mov	 ecx, 2
  00464	6b d1 00	 imul	 edx, ecx, 0
  00467	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  0046b	3d fd 00 00 00	 cmp	 eax, 253		; 000000fdH
  00470	75 30		 jne	 SHORT $LN39@NimVal

; 447  :         {
; 448  :           if (ed[nnA].e[0].el < 3)

  00472	8b 8d 24 eb ff
	ff		 mov	 ecx, DWORD PTR _nnA$24[ebp]
  00478	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0047b	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  0047f	b9 02 00 00 00	 mov	 ecx, 2
  00484	6b d1 00	 imul	 edx, ecx, 0
  00487	0f b6 44 10 01	 movzx	 eax, BYTE PTR [eax+edx+1]
  0048c	83 f8 03	 cmp	 eax, 3
  0048f	7d 0f		 jge	 SHORT $LN41@NimVal

; 449  :           {
; 450  :             result ^= 1;

  00491	8b 8d 38 eb ff
	ff		 mov	 ecx, DWORD PTR _result$[ebp]
  00497	83 f1 01	 xor	 ecx, 1
  0049a	89 8d 38 eb ff
	ff		 mov	 DWORD PTR _result$[ebp], ecx
$LN41@NimVal:

; 451  : #ifdef NS_DUMP
; 452  :             LOGUIUI(" ",0,0);
; 453  :             LOGUIUI("%dIsolated sub-String value = 1",myCount,0);
; 454  : #endif
; 455  :           };
; 456  :           //else LOONY
; 457  :         }

  004a0	eb 3f		 jmp	 SHORT $LN40@NimVal
$LN39@NimVal:

; 458  :         else if (sd[nnA][0].ns == LOOP) 

  004a2	8b 95 24 eb ff
	ff		 mov	 edx, DWORD PTR _nnA$24[ebp]
  004a8	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  004ab	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  004b2	ba 02 00 00 00	 mov	 edx, 2
  004b7	6b c2 00	 imul	 eax, edx, 0
  004ba	0f b6 0c 01	 movzx	 ecx, BYTE PTR [ecx+eax]
  004be	81 f9 fe 00 00
	00		 cmp	 ecx, 254		; 000000feH
  004c4	75 0e		 jne	 SHORT $LN42@NimVal

; 459  :         {
; 460  :           result ^= 0;

  004c6	8b 95 38 eb ff
	ff		 mov	 edx, DWORD PTR _result$[ebp]
  004cc	89 95 38 eb ff
	ff		 mov	 DWORD PTR _result$[ebp], edx

; 461  :         }

  004d2	eb 0d		 jmp	 SHORT $LN40@NimVal
$LN42@NimVal:

; 462  :         else
; 463  :         {
; 464  :           NotImplemented("Nim of non-GND_GND isolated string");

  004d4	68 00 00 00 00	 push	 OFFSET $SG225614
  004d9	e8 00 00 00 00	 call	 ?NotImplemented@@YAXPAD@Z ; NotImplemented
  004de	83 c4 04	 add	 esp, 4
$LN40@NimVal:

; 465  :         };
; 466  :       }

  004e1	e9 78 07 00 00	 jmp	 $LN38@NimVal
$LN37@NimVal:

; 467  :       else
; 468  :       {
; 469  :         if (lastNode-firstNode <= NIM_MAX_CANON) Canon(firstNode, lastNode);

  004e6	8b 85 44 e9 ff
	ff		 mov	 eax, DWORD PTR _lastNode$15[ebp]
  004ec	2b 45 e8	 sub	 eax, DWORD PTR _firstNode$[ebp]
  004ef	3d e7 03 00 00	 cmp	 eax, 999		; 000003e7H
  004f4	7f 13		 jg	 SHORT $LN44@NimVal
  004f6	8b 8d 44 e9 ff
	ff		 mov	 ecx, DWORD PTR _lastNode$15[ebp]
  004fc	51		 push	 ecx
  004fd	8b 55 e8	 mov	 edx, DWORD PTR _firstNode$[ebp]
  00500	52		 push	 edx
  00501	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00504	e8 00 00 00 00	 call	 ?Canon@CON@@QAEXHH@Z	; CON::Canon
$LN44@NimVal:

; 470  :         hash = NimHash(firstNode, lastNode);

  00509	8b 85 44 e9 ff
	ff		 mov	 eax, DWORD PTR _lastNode$15[ebp]
  0050f	50		 push	 eax
  00510	8b 4d e8	 mov	 ecx, DWORD PTR _firstNode$[ebp]
  00513	51		 push	 ecx
  00514	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00517	e8 00 00 00 00	 call	 ?NimHash@NIMCON@@QAE_KHH@Z ; NIMCON::NimHash
  0051c	89 85 30 eb ff
	ff		 mov	 DWORD PTR _hash$[ebp], eax
  00522	89 95 34 eb ff
	ff		 mov	 DWORD PTR _hash$[ebp+4], edx

; 471  : #ifdef NS_DUMP
; 472  :         DUMP("NimVal Canonized sub-string",myCount,
; 473  :           (ui32)(hash>>32),(ui32)hash,
; 474  :           firstNode,lastNode);
; 475  : #endif
; 476  : #ifdef _CHECK
; 477  :         CheckEverything(firstNode, lastNode);
; 478  : #endif
; 479  :         hashIndex = nimHashTable->Exists(hash);

  00528	8b 95 34 eb ff
	ff		 mov	 edx, DWORD PTR _hash$[ebp+4]
  0052e	52		 push	 edx
  0052f	8b 85 30 eb ff
	ff		 mov	 eax, DWORD PTR _hash$[ebp]
  00535	50		 push	 eax
  00536	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nimHashTable@@3PAVNIMHASHTABLE@@A ; nimHashTable
  0053c	e8 00 00 00 00	 call	 ?Exists@NIMHASHTABLE@@QAEH_K@Z ; NIMHASHTABLE::Exists
  00541	89 85 58 ff ff
	ff		 mov	 DWORD PTR _hashIndex$[ebp], eax

; 480  :         if (hashIndex >= 0)

  00547	83 bd 58 ff ff
	ff 00		 cmp	 DWORD PTR _hashIndex$[ebp], 0
  0054e	7c 23		 jl	 SHORT $LN45@NimVal

; 481  :         {
; 482  :           result ^= nimHashTable->GetValue(hashIndex);

  00550	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _hashIndex$[ebp]
  00556	51		 push	 ecx
  00557	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nimHashTable@@3PAVNIMHASHTABLE@@A ; nimHashTable
  0055d	e8 00 00 00 00	 call	 ?GetValue@NIMHASHTABLE@@QBEIH@Z ; NIMHASHTABLE::GetValue
  00562	33 85 38 eb ff
	ff		 xor	 eax, DWORD PTR _result$[ebp]
  00568	89 85 38 eb ff
	ff		 mov	 DWORD PTR _result$[ebp], eax

; 483  :           LOGUIUI(" ",0,0);
; 484  :           LOGUII64UI("%d Sub-string Hash=%016I64x Value = %d",myCount,hash,nimHashTable->GetValue(hashIndex));
; 485  :         }

  0056e	e9 eb 06 00 00	 jmp	 $LN38@NimVal
$LN45@NimVal:

; 486  :         else
; 487  :         {
; 488  :           //Now we need to make all the possible moves and select the
; 489  :           //minimum excluded value;
; 490  :           if (stopThinking || (currentTime > timeLimit)) 

  00573	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR ?stopThinking@@3_NA ; stopThinking
  0057a	85 d2		 test	 edx, edx
  0057c	75 1d		 jne	 SHORT $LN48@NimVal
  0057e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?currentTime@@3_JA+4
  00583	3b 05 04 00 00
	00		 cmp	 eax, DWORD PTR ?timeLimit@@3_JA+4
  00589	7c 3e		 jl	 SHORT $LN47@NimVal
  0058b	7f 0e		 jg	 SHORT $LN48@NimVal
  0058d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?currentTime@@3_JA
  00593	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?timeLimit@@3_JA
  00599	76 2e		 jbe	 SHORT $LN47@NimVal
$LN48@NimVal:

; 491  :           {
; 492  :             searchAborted = true;

  0059b	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?searchAborted@@3_NA, 1 ; searchAborted

; 493  :             return 99;

  005a2	c7 85 08 e9 ff
	ff 63 00 00 00	 mov	 DWORD PTR $T4[ebp], 99	; 00000063H
  005ac	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  005b3	8d 8d 44 eb ff
	ff		 lea	 ecx, DWORD PTR _nimcon$[ebp]
  005b9	e8 00 00 00 00	 call	 ??1NIMCON@@QAE@XZ
  005be	8b 85 08 e9 ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  005c4	e9 d7 06 00 00	 jmp	 $LN56@NimVal
$LN47@NimVal:

; 494  :           };
; 495  :           mex = 0;

  005c9	c7 85 3c eb ff
	ff 00 00 00 00	 mov	 DWORD PTR _mex$[ebp], 0

; 496  :           for (nn=firstNode; nn<lastNode; nn++)

  005d3	8b 55 e8	 mov	 edx, DWORD PTR _firstNode$[ebp]
  005d6	89 95 28 eb ff
	ff		 mov	 DWORD PTR _nn$25[ebp], edx
  005dc	eb 0f		 jmp	 SHORT $LN19@NimVal
$LN17@NimVal:
  005de	8b 85 28 eb ff
	ff		 mov	 eax, DWORD PTR _nn$25[ebp]
  005e4	83 c0 01	 add	 eax, 1
  005e7	89 85 28 eb ff
	ff		 mov	 DWORD PTR _nn$25[ebp], eax
$LN19@NimVal:
  005ed	8b 8d 28 eb ff
	ff		 mov	 ecx, DWORD PTR _nn$25[ebp]
  005f3	3b 8d 44 e9 ff
	ff		 cmp	 ecx, DWORD PTR _lastNode$15[ebp]
  005f9	0f 8d f6 05 00
	00		 jge	 $LN18@NimVal

; 497  :           {
; 498  :             nnA = nd[nn].ix;

  005ff	8b 95 28 eb ff
	ff		 mov	 edx, DWORD PTR _nn$25[ebp]
  00605	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00608	0f b6 8c 90 13
	10 00 00	 movzx	 ecx, BYTE PTR [eax+edx*4+4115]
  00610	89 8d 24 eb ff
	ff		 mov	 DWORD PTR _nnA$24[ebp], ecx

; 499  :             const int ec = nd[nnA].ec;

  00616	8b 95 24 eb ff
	ff		 mov	 edx, DWORD PTR _nnA$24[ebp]
  0061c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0061f	0f b6 8c 90 10
	10 00 00	 movzx	 ecx, BYTE PTR [eax+edx*4+4112]
  00627	89 8d 3c e9 ff
	ff		 mov	 DWORD PTR _ec$13[ebp], ecx

; 500  :             if ((nn>firstNode) && ((nd[nnA].gn == nd[nd[nn-1].ix].gn))) continue;

  0062d	8b 95 28 eb ff
	ff		 mov	 edx, DWORD PTR _nn$25[ebp]
  00633	3b 55 e8	 cmp	 edx, DWORD PTR _firstNode$[ebp]
  00636	7e 36		 jle	 SHORT $LN49@NimVal
  00638	8b 85 24 eb ff
	ff		 mov	 eax, DWORD PTR _nnA$24[ebp]
  0063e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00641	0f b6 94 81 11
	10 00 00	 movzx	 edx, BYTE PTR [ecx+eax*4+4113]
  00649	8b 85 28 eb ff
	ff		 mov	 eax, DWORD PTR _nn$25[ebp]
  0064f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00652	0f b6 84 81 0f
	10 00 00	 movzx	 eax, BYTE PTR [ecx+eax*4+4111]
  0065a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0065d	0f b6 84 81 11
	10 00 00	 movzx	 eax, BYTE PTR [ecx+eax*4+4113]
  00665	3b d0		 cmp	 edx, eax
  00667	75 05		 jne	 SHORT $LN49@NimVal
  00669	e9 70 ff ff ff	 jmp	 $LN17@NimVal
$LN49@NimVal:

; 501  :             for (en=0; en<ec; en++)

  0066e	c7 85 20 eb ff
	ff 00 00 00 00	 mov	 DWORD PTR _en$23[ebp], 0
  00678	eb 0f		 jmp	 SHORT $LN22@NimVal
$LN20@NimVal:
  0067a	8b 8d 20 eb ff
	ff		 mov	 ecx, DWORD PTR _en$23[ebp]
  00680	83 c1 01	 add	 ecx, 1
  00683	89 8d 20 eb ff
	ff		 mov	 DWORD PTR _en$23[ebp], ecx
$LN22@NimVal:
  00689	8b 95 20 eb ff
	ff		 mov	 edx, DWORD PTR _en$23[ebp]
  0068f	3b 95 3c e9 ff
	ff		 cmp	 edx, DWORD PTR _ec$13[ebp]
  00695	0f 8d 55 05 00
	00		 jge	 $LN21@NimVal

; 502  :             {
; 503  :               ASSERT(sd[nnA][en].ns != UNUSED);

  0069b	8b 85 24 eb ff
	ff		 mov	 eax, DWORD PTR _nnA$24[ebp]
  006a1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  006a4	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  006ab	8b 85 20 eb ff
	ff		 mov	 eax, DWORD PTR _en$23[ebp]
  006b1	0f b6 0c 42	 movzx	 ecx, BYTE PTR [edx+eax*2]
  006b5	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  006bb	75 14		 jne	 SHORT $LN62@NimVal
  006bd	68 f7 01 00 00	 push	 503			; 000001f7H
  006c2	68 00 00 00 00	 push	 OFFSET $SG225622
  006c7	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  006cc	85 c0		 test	 eax, eax
  006ce	74 01		 je	 SHORT $LN62@NimVal
  006d0	cc		 int	 3
$LN62@NimVal:

; 504  :               if (    (en!=0) 
; 505  :                    && (ed[nnA].e[en-1].el == ed[nnA].e[en].el)
; 506  :                    && (nd[sd[nnA][en-1].ns].gn == nd[sd[nnA][en].ns].gn)) continue;

  006d1	83 bd 20 eb ff
	ff 00		 cmp	 DWORD PTR _en$23[ebp], 0
  006d8	0f 84 88 00 00
	00		 je	 $LN50@NimVal
  006de	8b 85 24 eb ff
	ff		 mov	 eax, DWORD PTR _nnA$24[ebp]
  006e4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  006e7	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  006eb	8b 85 20 eb ff
	ff		 mov	 eax, DWORD PTR _en$23[ebp]
  006f1	0f b6 4c 42 ff	 movzx	 ecx, BYTE PTR [edx+eax*2-1]
  006f6	8b 95 24 eb ff
	ff		 mov	 edx, DWORD PTR _nnA$24[ebp]
  006fc	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  006ff	8d 54 d0 10	 lea	 edx, DWORD PTR [eax+edx*8+16]
  00703	8b 85 20 eb ff
	ff		 mov	 eax, DWORD PTR _en$23[ebp]
  00709	0f b6 54 42 01	 movzx	 edx, BYTE PTR [edx+eax*2+1]
  0070e	3b ca		 cmp	 ecx, edx
  00710	75 54		 jne	 SHORT $LN50@NimVal
  00712	8b 85 24 eb ff
	ff		 mov	 eax, DWORD PTR _nnA$24[ebp]
  00718	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0071b	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  00722	8b 85 20 eb ff
	ff		 mov	 eax, DWORD PTR _en$23[ebp]
  00728	0f b6 4c 42 fe	 movzx	 ecx, BYTE PTR [edx+eax*2-2]
  0072d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00730	0f b6 84 8a 11
	10 00 00	 movzx	 eax, BYTE PTR [edx+ecx*4+4113]
  00738	8b 8d 24 eb ff
	ff		 mov	 ecx, DWORD PTR _nnA$24[ebp]
  0073e	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00741	8d 8c ca 10 08
	00 00		 lea	 ecx, DWORD PTR [edx+ecx*8+2064]
  00748	8b 95 20 eb ff
	ff		 mov	 edx, DWORD PTR _en$23[ebp]
  0074e	0f b6 0c 51	 movzx	 ecx, BYTE PTR [ecx+edx*2]
  00752	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00755	0f b6 8c 8a 11
	10 00 00	 movzx	 ecx, BYTE PTR [edx+ecx*4+4113]
  0075d	3b c1		 cmp	 eax, ecx
  0075f	75 05		 jne	 SHORT $LN50@NimVal
  00761	e9 14 ff ff ff	 jmp	 $LN20@NimVal
$LN50@NimVal:

; 507  :               if (ed[nnA].e[en].el < 3)

  00766	8b 95 24 eb ff
	ff		 mov	 edx, DWORD PTR _nnA$24[ebp]
  0076c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0076f	8d 4c d0 10	 lea	 ecx, DWORD PTR [eax+edx*8+16]
  00773	8b 95 20 eb ff
	ff		 mov	 edx, DWORD PTR _en$23[ebp]
  00779	0f b6 44 51 01	 movzx	 eax, BYTE PTR [ecx+edx*2+1]
  0077e	83 f8 03	 cmp	 eax, 3
  00781	0f 8d 64 04 00
	00		 jge	 $LN51@NimVal

; 508  :               {
; 509  :                 if (sd[nnA][en].ns == GROUND)

  00787	8b 8d 24 eb ff
	ff		 mov	 ecx, DWORD PTR _nnA$24[ebp]
  0078d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00790	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  00797	8b 8d 20 eb ff
	ff		 mov	 ecx, DWORD PTR _en$23[ebp]
  0079d	0f b6 14 48	 movzx	 edx, BYTE PTR [eax+ecx*2]
  007a1	81 fa fa 00 00
	00		 cmp	 edx, 250		; 000000faH
  007a7	0f 85 cb 01 00
	00		 jne	 $LN52@NimVal

; 510  :                 {
; 511  :                   int last = lastNode;

  007ad	8b 85 44 e9 ff
	ff		 mov	 eax, DWORD PTR _lastNode$15[ebp]
  007b3	89 85 34 e9 ff
	ff		 mov	 DWORD PTR _last$12[ebp], eax

; 512  :   
; 513  : 
; 514  : 
; 515  :                   for (i=firstNode; i<lastNode; i++)

  007b9	8b 4d e8	 mov	 ecx, DWORD PTR _firstNode$[ebp]
  007bc	89 4d e4	 mov	 DWORD PTR _i$[ebp], ecx
  007bf	eb 09		 jmp	 SHORT $LN25@NimVal
$LN23@NimVal:
  007c1	8b 55 e4	 mov	 edx, DWORD PTR _i$[ebp]
  007c4	83 c2 01	 add	 edx, 1
  007c7	89 55 e4	 mov	 DWORD PTR _i$[ebp], edx
$LN25@NimVal:
  007ca	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  007cd	3b 85 44 e9 ff
	ff		 cmp	 eax, DWORD PTR _lastNode$15[ebp]
  007d3	0f 8d 4f 01 00
	00		 jge	 $LN24@NimVal

; 516  :                   { //Copy the string.
; 517  :                     int nnA;
; 518  :                     nimcon.nd[i] = nd[i];

  007d9	8b 4d e4	 mov	 ecx, DWORD PTR _i$[ebp]
  007dc	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  007df	8b 84 8a 10 10
	00 00		 mov	 eax, DWORD PTR [edx+ecx*4+4112]
  007e6	8b 4d e4	 mov	 ecx, DWORD PTR _i$[ebp]
  007e9	89 84 8d 54 fb
	ff ff		 mov	 DWORD PTR _nimcon$[ebp+ecx*4+4112], eax

; 519  :                     nnA = nd[i].ix;

  007f0	8b 55 e4	 mov	 edx, DWORD PTR _i$[ebp]
  007f3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  007f6	0f b6 8c 90 13
	10 00 00	 movzx	 ecx, BYTE PTR [eax+edx*4+4115]
  007fe	89 8d 2c e9 ff
	ff		 mov	 DWORD PTR _nnA$11[ebp], ecx

; 520  :                     nimcon.sd[nnA][0] = sd[nnA][0];

  00804	8b 95 2c e9 ff
	ff		 mov	 edx, DWORD PTR _nnA$11[ebp]
  0080a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0080d	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  00814	ba 02 00 00 00	 mov	 edx, 2
  00819	6b c2 00	 imul	 eax, edx, 0
  0081c	66 8b 0c 01	 mov	 cx, WORD PTR [ecx+eax]
  00820	8b 95 2c e9 ff
	ff		 mov	 edx, DWORD PTR _nnA$11[ebp]
  00826	8d 84 d5 54 f3
	ff ff		 lea	 eax, DWORD PTR _nimcon$[ebp+edx*8+2064]
  0082d	ba 02 00 00 00	 mov	 edx, 2
  00832	6b d2 00	 imul	 edx, edx, 0
  00835	66 89 0c 10	 mov	 WORD PTR [eax+edx], cx

; 521  :                     nimcon.sd[nnA][1] = sd[nnA][1];

  00839	8b 85 2c e9 ff
	ff		 mov	 eax, DWORD PTR _nnA$11[ebp]
  0083f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00842	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  00849	b8 02 00 00 00	 mov	 eax, 2
  0084e	c1 e0 00	 shl	 eax, 0
  00851	66 8b 0c 02	 mov	 cx, WORD PTR [edx+eax]
  00855	8b 95 2c e9 ff
	ff		 mov	 edx, DWORD PTR _nnA$11[ebp]
  0085b	8d 84 d5 54 f3
	ff ff		 lea	 eax, DWORD PTR _nimcon$[ebp+edx*8+2064]
  00862	ba 02 00 00 00	 mov	 edx, 2
  00867	c1 e2 00	 shl	 edx, 0
  0086a	66 89 0c 10	 mov	 WORD PTR [eax+edx], cx

; 522  :                     nimcon.sd[nnA][2] = sd[nnA][2];

  0086e	8b 85 2c e9 ff
	ff		 mov	 eax, DWORD PTR _nnA$11[ebp]
  00874	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00877	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  0087e	b8 02 00 00 00	 mov	 eax, 2
  00883	d1 e0		 shl	 eax, 1
  00885	66 8b 0c 02	 mov	 cx, WORD PTR [edx+eax]
  00889	8b 95 2c e9 ff
	ff		 mov	 edx, DWORD PTR _nnA$11[ebp]
  0088f	8d 84 d5 54 f3
	ff ff		 lea	 eax, DWORD PTR _nimcon$[ebp+edx*8+2064]
  00896	ba 02 00 00 00	 mov	 edx, 2
  0089b	d1 e2		 shl	 edx, 1
  0089d	66 89 0c 10	 mov	 WORD PTR [eax+edx], cx

; 523  :                     nimcon.sd[nnA][3] = sd[nnA][3];

  008a1	8b 85 2c e9 ff
	ff		 mov	 eax, DWORD PTR _nnA$11[ebp]
  008a7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  008aa	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  008b1	b8 02 00 00 00	 mov	 eax, 2
  008b6	6b c8 03	 imul	 ecx, eax, 3
  008b9	66 8b 14 0a	 mov	 dx, WORD PTR [edx+ecx]
  008bd	8b 85 2c e9 ff
	ff		 mov	 eax, DWORD PTR _nnA$11[ebp]
  008c3	8d 8c c5 54 f3
	ff ff		 lea	 ecx, DWORD PTR _nimcon$[ebp+eax*8+2064]
  008ca	b8 02 00 00 00	 mov	 eax, 2
  008cf	6b c0 03	 imul	 eax, eax, 3
  008d2	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx

; 524  :                     nimcon.ed[nnA] = ed[nnA];

  008d6	8b 8d 2c e9 ff
	ff		 mov	 ecx, DWORD PTR _nnA$11[ebp]
  008dc	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  008df	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  008e3	50		 push	 eax
  008e4	8b 8d 2c e9 ff
	ff		 mov	 ecx, DWORD PTR _nnA$11[ebp]
  008ea	8d 8c cd 54 eb
	ff ff		 lea	 ecx, DWORD PTR _nimcon$[ebp+ecx*8+16]
  008f1	e8 00 00 00 00	 call	 ??4EDGEDATA@@QAEXABU0@@Z ; EDGEDATA::operator=

; 525  :                     nimcon.nd[nnA] = nd[nnA];

  008f6	8b 95 2c e9 ff
	ff		 mov	 edx, DWORD PTR _nnA$11[ebp]
  008fc	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  008ff	8b 8c 90 10 10
	00 00		 mov	 ecx, DWORD PTR [eax+edx*4+4112]
  00906	8b 95 2c e9 ff
	ff		 mov	 edx, DWORD PTR _nnA$11[ebp]
  0090c	89 8c 95 54 fb
	ff ff		 mov	 DWORD PTR _nimcon$[ebp+edx*4+4112], ecx

; 526  :                     nimcon.nd[nnA].gn = (STOPNUM)i;

  00913	8b 85 2c e9 ff
	ff		 mov	 eax, DWORD PTR _nnA$11[ebp]
  00919	8a 4d e4	 mov	 cl, BYTE PTR _i$[ebp]
  0091c	88 8c 85 55 fb
	ff ff		 mov	 BYTE PTR _nimcon$[ebp+eax*4+4113], cl

; 527  :                   };

  00923	e9 99 fe ff ff	 jmp	 $LN23@NimVal
$LN24@NimVal:

; 528  :                   nimcon.DeleteEdge(nn,en,&last);

  00928	8d 95 34 e9 ff
	ff		 lea	 edx, DWORD PTR _last$12[ebp]
  0092e	52		 push	 edx
  0092f	8b 85 20 eb ff
	ff		 mov	 eax, DWORD PTR _en$23[ebp]
  00935	50		 push	 eax
  00936	8b 8d 28 eb ff
	ff		 mov	 ecx, DWORD PTR _nn$25[ebp]
  0093c	51		 push	 ecx
  0093d	8d 8d 44 eb ff
	ff		 lea	 ecx, DWORD PTR _nimcon$[ebp]
  00943	e8 00 00 00 00	 call	 ?DeleteEdge@NIMCON@@QAEXHHPAH@Z ; NIMCON::DeleteEdge

; 529  :                   //{ //MoveEdge
; 530  :                   //  while (en < ec-1)
; 531  :                   //  {
; 532  :                   //    con.sd[nnA][en] = con.sd[nnA][en+1];
; 533  :                   //    con.ed[nnA].e[en] = con.ed[nnA].e[en+1];
; 534  :                   //    if (IS_A_NODE(con.sd[nnA][en].ns))
; 535  :                   //    {
; 536  :                   //      con.sd[con.sd[nnA][en].ns][con.sd[nnA][en].ne].ne=(EDGENUM)en;
; 537  :                   //    };
; 538  :                   //    en++;
; 539  :                   //  };
; 540  :                   //  con.sd[nnA][ec-1].Clear();
; 541  :                   //  con.ed[nnA].e[ec-1].Clear();
; 542  :                   //};
; 543  :                   //con.nd[nnA].ec--;
; 544  :                   //if (ec == 3)
; 545  :                   //{
; 546  :                   //  if (con.CombineEdges(nnA))
; 547  :                   //  {
; 548  :                   //    con.DeleteNode(nn, &last);
; 549  :                   //    //con.nd[nn].ix = con.nd[--last].ix;
; 550  :                   //    //con.nd[con.nd[nn].ix].os = (STOPNUM)nn;
; 551  :                   //  };
; 552  :                   //};
; 553  :                   mex |= 1 << nimcon.NimVal(firstNode, last);

  00948	8b 95 34 e9 ff
	ff		 mov	 edx, DWORD PTR _last$12[ebp]
  0094e	52		 push	 edx
  0094f	8b 45 e8	 mov	 eax, DWORD PTR _firstNode$[ebp]
  00952	50		 push	 eax
  00953	8d 8d 44 eb ff
	ff		 lea	 ecx, DWORD PTR _nimcon$[ebp]
  00959	e8 00 00 00 00	 call	 ?NimVal@NIMCON@@QAEHHH@Z ; NIMCON::NimVal
  0095e	ba 01 00 00 00	 mov	 edx, 1
  00963	8b c8		 mov	 ecx, eax
  00965	d3 e2		 shl	 edx, cl
  00967	0b 95 3c eb ff
	ff		 or	 edx, DWORD PTR _mex$[ebp]
  0096d	89 95 3c eb ff
	ff		 mov	 DWORD PTR _mex$[ebp], edx

; 554  : 
; 555  : 
; 556  : 
; 557  : #ifdef Searching0
; 558  :                   if ((searchDepth == 1) && (mex & 1)) return 1;
; 559  : #endif
; 560  :                   
; 561  : 
; 562  : 
; 563  : 
; 564  : 
; 565  :                 }

  00973	e9 73 02 00 00	 jmp	 $LN51@NimVal
$LN52@NimVal:

; 566  :                 else
; 567  :                 {
; 568  :                   int nnB;
; 569  :                   ASSERT(IS_A_NODE(sd[nnA][en].ns));

  00978	8b 85 24 eb ff
	ff		 mov	 eax, DWORD PTR _nnA$24[ebp]
  0097e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00981	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  00988	8b 85 20 eb ff
	ff		 mov	 eax, DWORD PTR _en$23[ebp]
  0098e	0f b6 0c 42	 movzx	 ecx, BYTE PTR [edx+eax*2]
  00992	81 f9 f9 00 00
	00		 cmp	 ecx, 249		; 000000f9H
  00998	7c 14		 jl	 SHORT $LN63@NimVal
  0099a	68 39 02 00 00	 push	 569			; 00000239H
  0099f	68 00 00 00 00	 push	 OFFSET $SG225627
  009a4	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  009a9	85 c0		 test	 eax, eax
  009ab	74 01		 je	 SHORT $LN63@NimVal
  009ad	cc		 int	 3
$LN63@NimVal:

; 570  :                   nnB = sd[nnA][en].ns;

  009ae	8b 85 24 eb ff
	ff		 mov	 eax, DWORD PTR _nnA$24[ebp]
  009b4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  009b7	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  009be	8b 85 20 eb ff
	ff		 mov	 eax, DWORD PTR _en$23[ebp]
  009c4	0f b6 0c 42	 movzx	 ecx, BYTE PTR [edx+eax*2]
  009c8	89 8d 28 e9 ff
	ff		 mov	 DWORD PTR _nnB$10[ebp], ecx

; 571  :                   if (nd[nnB].os > nn)

  009ce	8b 95 28 e9 ff
	ff		 mov	 edx, DWORD PTR _nnB$10[ebp]
  009d4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  009d7	0f b6 8c 90 12
	10 00 00	 movzx	 ecx, BYTE PTR [eax+edx*4+4114]
  009df	3b 8d 28 eb ff
	ff		 cmp	 ecx, DWORD PTR _nn$25[ebp]
  009e5	0f 8e 00 02 00
	00		 jle	 $LN51@NimVal

; 572  :                   {
; 573  :                     int last = lastNode;

  009eb	8b 95 44 e9 ff
	ff		 mov	 edx, DWORD PTR _lastNode$15[ebp]
  009f1	89 95 20 e9 ff
	ff		 mov	 DWORD PTR _last$9[ebp], edx

; 574  :                     for (i=firstNode; i<lastNode; i++)

  009f7	8b 45 e8	 mov	 eax, DWORD PTR _firstNode$[ebp]
  009fa	89 45 e4	 mov	 DWORD PTR _i$[ebp], eax
  009fd	eb 09		 jmp	 SHORT $LN28@NimVal
$LN26@NimVal:
  009ff	8b 4d e4	 mov	 ecx, DWORD PTR _i$[ebp]
  00a02	83 c1 01	 add	 ecx, 1
  00a05	89 4d e4	 mov	 DWORD PTR _i$[ebp], ecx
$LN28@NimVal:
  00a08	8b 55 e4	 mov	 edx, DWORD PTR _i$[ebp]
  00a0b	3b 95 44 e9 ff
	ff		 cmp	 edx, DWORD PTR _lastNode$15[ebp]
  00a11	0f 8d 4f 01 00
	00		 jge	 $LN27@NimVal

; 575  :                     {
; 576  :                       int nnA;
; 577  :                       nimcon.nd[i] = nd[i];

  00a17	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  00a1a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00a1d	8b 94 81 10 10
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+4112]
  00a24	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  00a27	89 94 85 54 fb
	ff ff		 mov	 DWORD PTR _nimcon$[ebp+eax*4+4112], edx

; 578  :                       nnA = nd[i].ix;

  00a2e	8b 4d e4	 mov	 ecx, DWORD PTR _i$[ebp]
  00a31	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00a34	0f b6 84 8a 13
	10 00 00	 movzx	 eax, BYTE PTR [edx+ecx*4+4115]
  00a3c	89 85 18 e9 ff
	ff		 mov	 DWORD PTR _nnA$8[ebp], eax

; 579  :                       nimcon.sd[nnA][0] = sd[nnA][0];

  00a42	8b 8d 18 e9 ff
	ff		 mov	 ecx, DWORD PTR _nnA$8[ebp]
  00a48	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00a4b	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  00a52	b9 02 00 00 00	 mov	 ecx, 2
  00a57	6b d1 00	 imul	 edx, ecx, 0
  00a5a	66 8b 04 10	 mov	 ax, WORD PTR [eax+edx]
  00a5e	8b 8d 18 e9 ff
	ff		 mov	 ecx, DWORD PTR _nnA$8[ebp]
  00a64	8d 94 cd 54 f3
	ff ff		 lea	 edx, DWORD PTR _nimcon$[ebp+ecx*8+2064]
  00a6b	b9 02 00 00 00	 mov	 ecx, 2
  00a70	6b c9 00	 imul	 ecx, ecx, 0
  00a73	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 580  :                       nimcon.sd[nnA][1] = sd[nnA][1];

  00a77	8b 95 18 e9 ff
	ff		 mov	 edx, DWORD PTR _nnA$8[ebp]
  00a7d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00a80	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  00a87	ba 02 00 00 00	 mov	 edx, 2
  00a8c	c1 e2 00	 shl	 edx, 0
  00a8f	66 8b 04 11	 mov	 ax, WORD PTR [ecx+edx]
  00a93	8b 8d 18 e9 ff
	ff		 mov	 ecx, DWORD PTR _nnA$8[ebp]
  00a99	8d 94 cd 54 f3
	ff ff		 lea	 edx, DWORD PTR _nimcon$[ebp+ecx*8+2064]
  00aa0	b9 02 00 00 00	 mov	 ecx, 2
  00aa5	c1 e1 00	 shl	 ecx, 0
  00aa8	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 581  :                       nimcon.sd[nnA][2] = sd[nnA][2];

  00aac	8b 95 18 e9 ff
	ff		 mov	 edx, DWORD PTR _nnA$8[ebp]
  00ab2	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00ab5	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  00abc	ba 02 00 00 00	 mov	 edx, 2
  00ac1	d1 e2		 shl	 edx, 1
  00ac3	66 8b 04 11	 mov	 ax, WORD PTR [ecx+edx]
  00ac7	8b 8d 18 e9 ff
	ff		 mov	 ecx, DWORD PTR _nnA$8[ebp]
  00acd	8d 94 cd 54 f3
	ff ff		 lea	 edx, DWORD PTR _nimcon$[ebp+ecx*8+2064]
  00ad4	b9 02 00 00 00	 mov	 ecx, 2
  00ad9	d1 e1		 shl	 ecx, 1
  00adb	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 582  :                       nimcon.sd[nnA][3] = sd[nnA][3];

  00adf	8b 95 18 e9 ff
	ff		 mov	 edx, DWORD PTR _nnA$8[ebp]
  00ae5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00ae8	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  00aef	ba 02 00 00 00	 mov	 edx, 2
  00af4	6b c2 03	 imul	 eax, edx, 3
  00af7	66 8b 0c 01	 mov	 cx, WORD PTR [ecx+eax]
  00afb	8b 95 18 e9 ff
	ff		 mov	 edx, DWORD PTR _nnA$8[ebp]
  00b01	8d 84 d5 54 f3
	ff ff		 lea	 eax, DWORD PTR _nimcon$[ebp+edx*8+2064]
  00b08	ba 02 00 00 00	 mov	 edx, 2
  00b0d	6b d2 03	 imul	 edx, edx, 3
  00b10	66 89 0c 10	 mov	 WORD PTR [eax+edx], cx

; 583  :                       nimcon.ed[nnA] = ed[nnA];

  00b14	8b 85 18 e9 ff
	ff		 mov	 eax, DWORD PTR _nnA$8[ebp]
  00b1a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00b1d	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  00b21	52		 push	 edx
  00b22	8b 85 18 e9 ff
	ff		 mov	 eax, DWORD PTR _nnA$8[ebp]
  00b28	8d 8c c5 54 eb
	ff ff		 lea	 ecx, DWORD PTR _nimcon$[ebp+eax*8+16]
  00b2f	e8 00 00 00 00	 call	 ??4EDGEDATA@@QAEXABU0@@Z ; EDGEDATA::operator=

; 584  :                       nimcon.nd[nnA] = nd[nnA];

  00b34	8b 8d 18 e9 ff
	ff		 mov	 ecx, DWORD PTR _nnA$8[ebp]
  00b3a	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00b3d	8b 84 8a 10 10
	00 00		 mov	 eax, DWORD PTR [edx+ecx*4+4112]
  00b44	8b 8d 18 e9 ff
	ff		 mov	 ecx, DWORD PTR _nnA$8[ebp]
  00b4a	89 84 8d 54 fb
	ff ff		 mov	 DWORD PTR _nimcon$[ebp+ecx*4+4112], eax

; 585  :                       nimcon.nd[nnA].gn = (STOPNUM)i;

  00b51	8b 95 18 e9 ff
	ff		 mov	 edx, DWORD PTR _nnA$8[ebp]
  00b57	8a 45 e4	 mov	 al, BYTE PTR _i$[ebp]
  00b5a	88 84 95 55 fb
	ff ff		 mov	 BYTE PTR _nimcon$[ebp+edx*4+4113], al

; 586  :                     };

  00b61	e9 99 fe ff ff	 jmp	 $LN26@NimVal
$LN27@NimVal:

; 587  :   
; 588  :                 
; 589  :                 
; 590  :                 
; 591  :                 
; 592  :                 
; 593  :                 
; 594  :                     {
; 595  :                       // We need to remove the edge from the other node. (pna,one)
; 596  :                       //onn = nodes[nn].L[en];
; 597  :                       //oei = GETFIELD(en,nodes[nn].fei);
; 598  :                       //int enB, ecB;
; 599  :                       //ecB = con.nd[nnB].ec;
; 600  :                       //enB = con.sd[nnA][en].ne;
; 601  :                       nimcon.DeleteEdge(nn, en, &last);

  00b66	8d 8d 20 e9 ff
	ff		 lea	 ecx, DWORD PTR _last$9[ebp]
  00b6c	51		 push	 ecx
  00b6d	8b 95 20 eb ff
	ff		 mov	 edx, DWORD PTR _en$23[ebp]
  00b73	52		 push	 edx
  00b74	8b 85 28 eb ff
	ff		 mov	 eax, DWORD PTR _nn$25[ebp]
  00b7a	50		 push	 eax
  00b7b	8d 8d 44 eb ff
	ff		 lea	 ecx, DWORD PTR _nimcon$[ebp]
  00b81	e8 00 00 00 00	 call	 ?DeleteEdge@NIMCON@@QAEXHHPAH@Z ; NIMCON::DeleteEdge

; 602  :                       //{ //MoveEdge
; 603  :                       //  while (enB < ecB-1)
; 604  :                       //  {
; 605  :                       //    con.sd[nnB][enB] = con.sd[nnB][enB+1];
; 606  :                       //    con.ed[nnB].e[enB] = con.ed[nnB].e[enB+1];
; 607  :                       //    if (IS_A_NODE(con.sd[nnB][enB].ns))
; 608  :                       //    {
; 609  :                       //      con.sd[con.sd[nnB][enB].ns][con.sd[nnB][enB].ne].ne=(EDGENUM)enB;
; 610  :                       //    };
; 611  :                       //    enB++;
; 612  :                       //  };
; 613  :                       //  con.sd[nnB][ecB-1].Clear();
; 614  :                       //  con.ed[nnB].e[ecB-1].Clear();
; 615  :                       //};
; 616  :                       //con.nd[nnB].ec--;
; 617  :                       //if (ecB == 3) //It has been reduced to 2.
; 618  :                       //{
; 619  :                       //  //We know that this node number is the larger
; 620  :                       //  //of the two (ie:  nnB > nnA).
; 621  :                       //  //So, if we need to delete it we will not disturb
; 622  :                       //  //the node at nnA.
; 623  :                       //  if (con.CombineEdges(nnB))
; 624  :                       //  {
; 625  :                       //    int nB = con.nd[nnB].os;
; 626  :                       //    con.DeleteNode(nB, &last);
; 627  :                       //    //con.nd[nB].ix = con.nd[--last].ix;
; 628  :                       //    //con.nd[con.nd[nB].ix].os = (STOPNUM)nB;
; 629  :                       //  };
; 630  :                       //  //Remove the edge from this node
; 631  :                       // //  nodes[sn].len[en] = 0;
; 632  :                       // //  SETFIELD(en,EMP,nodes[sn].len);
; 633  :                       //};
; 634  :                     };
; 635  :                     //{
; 636  :                     //  // Now we need to remove the edge from this node. (nnA, en)
; 637  :                     //  { //MoveEdge
; 638  :                     //    while (en < ec-1)
; 639  :                     //    {
; 640  :                     //      con.sd[nnA][en] = con.sd[nnA][en+1];
; 641  :                     //      con.ed[nnA].e[en] = con.ed[nnA].e[en+1];
; 642  :                     //      if (IS_A_NODE(con.sd[nnA][en].ns))
; 643  :                     //      {
; 644  :                     //        con.sd[con.sd[nnA][en].ns][con.sd[nnA][en].ne].ne=(EDGENUM)en;
; 645  :                     //      };
; 646  :                     //      en++;
; 647  :                     //    };
; 648  :                     //    con.sd[nnA][ec-1].Clear();
; 649  :                     //    con.ed[nnA].e[ec-1].Clear();
; 650  :                     //  };
; 651  :                     //  con.nd[nnA].ec--;
; 652  :                     //  if (ec == 3) //It has been reduced to 2.
; 653  :                     //  {
; 654  :                     //    //We know that this node number is the larger
; 655  :                     //    //of the two (ie:  nnB > nnA).
; 656  :                     //    //So, if we need to delete it we will not disturb
; 657  :                     //    //the node at nnA.
; 658  :                     //    if (con.CombineEdges(nnA))
; 659  :                     //    {
; 660  :                     //      int mynn = con.nd[nnA].os;
; 661  :                     //      con.DeleteNode(mynn, &last);
; 662  :                     //      //con.nd[mynn].ix = con.nd[--last].ix;
; 663  :                     //      //con.nd[con.nd[mynn].ix].os = (STOPNUM)mynn;
; 664  :                     //    };
; 665  :                     //    //Remove the edge from this node
; 666  :                     ////  nodes[sn].len[en] = 0;
; 667  :                     ////  SETFIELD(en,EMP,nodes[sn].len);
; 668  :                     //  };
; 669  :                     //};
; 670  :                     {
; 671  :                       int val;
; 672  :                       val = nimcon.NimVal(firstNode, last);

  00b86	8b 8d 20 e9 ff
	ff		 mov	 ecx, DWORD PTR _last$9[ebp]
  00b8c	51		 push	 ecx
  00b8d	8b 55 e8	 mov	 edx, DWORD PTR _firstNode$[ebp]
  00b90	52		 push	 edx
  00b91	8d 8d 44 eb ff
	ff		 lea	 ecx, DWORD PTR _nimcon$[ebp]
  00b97	e8 00 00 00 00	 call	 ?NimVal@NIMCON@@QAEHHH@Z ; NIMCON::NimVal
  00b9c	89 85 14 e9 ff
	ff		 mov	 DWORD PTR _val$7[ebp], eax

; 673  :                       if (val == 99) return 99;

  00ba2	83 bd 14 e9 ff
	ff 63		 cmp	 DWORD PTR _val$7[ebp], 99 ; 00000063H
  00ba9	75 27		 jne	 SHORT $LN55@NimVal
  00bab	c7 85 04 e9 ff
	ff 63 00 00 00	 mov	 DWORD PTR $T3[ebp], 99	; 00000063H
  00bb5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00bbc	8d 8d 44 eb ff
	ff		 lea	 ecx, DWORD PTR _nimcon$[ebp]
  00bc2	e8 00 00 00 00	 call	 ??1NIMCON@@QAE@XZ
  00bc7	8b 85 04 e9 ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  00bcd	e9 ce 00 00 00	 jmp	 $LN56@NimVal
$LN55@NimVal:

; 674  :                       mex |= 1 << val;

  00bd2	b8 01 00 00 00	 mov	 eax, 1
  00bd7	8b 8d 14 e9 ff
	ff		 mov	 ecx, DWORD PTR _val$7[ebp]
  00bdd	d3 e0		 shl	 eax, cl
  00bdf	0b 85 3c eb ff
	ff		 or	 eax, DWORD PTR _mex$[ebp]
  00be5	89 85 3c eb ff
	ff		 mov	 DWORD PTR _mex$[ebp], eax
$LN51@NimVal:

; 675  : 
; 676  :                     
; 677  :                     
; 678  : #ifdef Searching0
; 679  :                       if ((searchDepth == 1) && (mex & 1)) return 1;
; 680  : #endif
; 681  :                     
; 682  :                     
; 683  :                     
; 684  :                     };
; 685  :               
; 686  :               
; 687  :               
; 688  :               
; 689  :               
; 690  :               
; 691  :               
; 692  :               
; 693  :                   };
; 694  :                 };
; 695  :               };
; 696  :             };

  00beb	e9 8a fa ff ff	 jmp	 $LN20@NimVal
$LN21@NimVal:

; 697  :           };//for each node

  00bf0	e9 e9 f9 ff ff	 jmp	 $LN17@NimVal
$LN18@NimVal:

; 698  : 		  int r;
; 699  :           for ( r=0; mex&1; r++,mex>>=1);

  00bf5	c7 85 10 e9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _r$6[ebp], 0
  00bff	eb 1d		 jmp	 SHORT $LN31@NimVal
$LN29@NimVal:
  00c01	8b 8d 10 e9 ff
	ff		 mov	 ecx, DWORD PTR _r$6[ebp]
  00c07	83 c1 01	 add	 ecx, 1
  00c0a	89 8d 10 e9 ff
	ff		 mov	 DWORD PTR _r$6[ebp], ecx
  00c10	8b 95 3c eb ff
	ff		 mov	 edx, DWORD PTR _mex$[ebp]
  00c16	d1 ea		 shr	 edx, 1
  00c18	89 95 3c eb ff
	ff		 mov	 DWORD PTR _mex$[ebp], edx
$LN31@NimVal:
  00c1e	8b 85 3c eb ff
	ff		 mov	 eax, DWORD PTR _mex$[ebp]
  00c24	83 e0 01	 and	 eax, 1
  00c27	74 02		 je	 SHORT $LN30@NimVal
  00c29	eb d6		 jmp	 SHORT $LN29@NimVal
$LN30@NimVal:

; 700  :           LOGUIUI(" ",0,0)
; 701  :           LOGUII64UI("%d Computed Substring Hash=%016I64x Set value = %d", myCount, hash, r);
; 702  :           result ^= r;

  00c2b	8b 8d 38 eb ff
	ff		 mov	 ecx, DWORD PTR _result$[ebp]
  00c31	33 8d 10 e9 ff
	ff		 xor	 ecx, DWORD PTR _r$6[ebp]
  00c37	89 8d 38 eb ff
	ff		 mov	 DWORD PTR _result$[ebp], ecx

; 703  :           nimHashTable->EnterValue(hash, (NIMVALUE)r);

  00c3d	0f b6 95 10 e9
	ff ff		 movzx	 edx, BYTE PTR _r$6[ebp]
  00c44	52		 push	 edx
  00c45	8b 85 34 eb ff
	ff		 mov	 eax, DWORD PTR _hash$[ebp+4]
  00c4b	50		 push	 eax
  00c4c	8b 8d 30 eb ff
	ff		 mov	 ecx, DWORD PTR _hash$[ebp]
  00c52	51		 push	 ecx
  00c53	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nimHashTable@@3PAVNIMHASHTABLE@@A ; nimHashTable
  00c59	e8 00 00 00 00	 call	 ?EnterValue@NIMHASHTABLE@@QAEX_KE@Z ; NIMHASHTABLE::EnterValue
$LN38@NimVal:

; 704  :         };
; 705  :       };
; 706  :       firstNode += numVisited;

  00c5e	8b 55 e8	 mov	 edx, DWORD PTR _firstNode$[ebp]
  00c61	03 95 18 eb ff
	ff		 add	 edx, DWORD PTR _numVisited$21[ebp]
  00c67	89 55 e8	 mov	 DWORD PTR _firstNode$[ebp], edx

; 707  :     };

  00c6a	e9 b0 f4 ff ff	 jmp	 $LN5@NimVal
$LN6@NimVal:

; 708  :   };
; 709  :   LOGUIUI("%d Exit NimVal result=%d", myCount, result);
; 710  :   searchDepth--;

  00c6f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?searchDepth@@3HA ; searchDepth
  00c74	83 e8 01	 sub	 eax, 1
  00c77	a3 00 00 00 00	 mov	 DWORD PTR ?searchDepth@@3HA, eax ; searchDepth

; 711  :   return result;

  00c7c	8b 8d 38 eb ff
	ff		 mov	 ecx, DWORD PTR _result$[ebp]
  00c82	89 8d 00 e9 ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  00c88	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00c8f	8d 8d 44 eb ff
	ff		 lea	 ecx, DWORD PTR _nimcon$[ebp]
  00c95	e8 00 00 00 00	 call	 ??1NIMCON@@QAE@XZ
  00c9a	8b 85 00 e9 ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
$LN56@NimVal:

; 712  : };

  00ca0	52		 push	 edx
  00ca1	8b cd		 mov	 ecx, ebp
  00ca3	50		 push	 eax
  00ca4	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN73@NimVal
  00caa	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00caf	58		 pop	 eax
  00cb0	5a		 pop	 edx
  00cb1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00cb4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00cbb	59		 pop	 ecx
  00cbc	5f		 pop	 edi
  00cbd	5e		 pop	 esi
  00cbe	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00cc1	33 cd		 xor	 ecx, ebp
  00cc3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00cc8	81 c4 00 17 00
	00		 add	 esp, 5888		; 00001700H
  00cce	3b ec		 cmp	 ebp, esp
  00cd0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00cd5	8b e5		 mov	 esp, ebp
  00cd7	5d		 pop	 ebp
  00cd8	c2 08 00	 ret	 8
  00cdb	90		 npad	 1
$LN73@NimVal:
  00cdc	05 00 00 00	 DD	 5
  00ce0	00 00 00 00	 DD	 $LN72@NimVal
$LN72@NimVal:
  00ce4	60 ff ff ff	 DD	 -160			; ffffff60H
  00ce8	75 00 00 00	 DD	 117			; 00000075H
  00cec	00 00 00 00	 DD	 $LN66@NimVal
  00cf0	44 eb ff ff	 DD	 -5308			; ffffeb44H
  00cf4	10 14 00 00	 DD	 5136			; 00001410H
  00cf8	00 00 00 00	 DD	 $LN67@NimVal
  00cfc	50 e9 ff ff	 DD	 -5808			; ffffe950H
  00d00	b8 01 00 00	 DD	 440			; 000001b8H
  00d04	00 00 00 00	 DD	 $LN68@NimVal
  00d08	34 e9 ff ff	 DD	 -5836			; ffffe934H
  00d0c	04 00 00 00	 DD	 4
  00d10	00 00 00 00	 DD	 $LN69@NimVal
  00d14	20 e9 ff ff	 DD	 -5856			; ffffe920H
  00d18	04 00 00 00	 DD	 4
  00d1c	00 00 00 00	 DD	 $LN70@NimVal
$LN70@NimVal:
  00d20	6c		 DB	 108			; 0000006cH
  00d21	61		 DB	 97			; 00000061H
  00d22	73		 DB	 115			; 00000073H
  00d23	74		 DB	 116			; 00000074H
  00d24	00		 DB	 0
$LN69@NimVal:
  00d25	6c		 DB	 108			; 0000006cH
  00d26	61		 DB	 97			; 00000061H
  00d27	73		 DB	 115			; 00000073H
  00d28	74		 DB	 116			; 00000074H
  00d29	00		 DB	 0
$LN68@NimVal:
  00d2a	74		 DB	 116			; 00000074H
  00d2b	6f		 DB	 111			; 0000006fH
  00d2c	56		 DB	 86			; 00000056H
  00d2d	69		 DB	 105			; 00000069H
  00d2e	73		 DB	 115			; 00000073H
  00d2f	69		 DB	 105			; 00000069H
  00d30	74		 DB	 116			; 00000074H
  00d31	00		 DB	 0
$LN67@NimVal:
  00d32	6e		 DB	 110			; 0000006eH
  00d33	69		 DB	 105			; 00000069H
  00d34	6d		 DB	 109			; 0000006dH
  00d35	63		 DB	 99			; 00000063H
  00d36	6f		 DB	 111			; 0000006fH
  00d37	6e		 DB	 110			; 0000006eH
  00d38	00		 DB	 0
$LN66@NimVal:
  00d39	76		 DB	 118			; 00000076H
  00d3a	69		 DB	 105			; 00000069H
  00d3b	73		 DB	 115			; 00000073H
  00d3c	69		 DB	 105			; 00000069H
  00d3d	74		 DB	 116			; 00000074H
  00d3e	65		 DB	 101			; 00000065H
  00d3f	64		 DB	 100			; 00000064H
  00d40	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?NimVal@NIMCON@@QAEHHH@Z$0:
  00000	8d 8d 44 eb ff
	ff		 lea	 ecx, DWORD PTR _nimcon$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1NIMCON@@QAE@XZ
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$?NimVal@NIMCON@@QAEHHH@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 00 e9 ff
	ff		 mov	 ecx, DWORD PTR [edx-5888]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?NimVal@NIMCON@@QAEHHH@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?NimVal@NIMCON@@QAEHHH@Z ENDP				; NIMCON::NimVal
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Nimstring.cpp
_TEXT	SEGMENT
_el$1 = -40						; size = 4
_el$2 = -36						; size = 4
_el$3 = -32						; size = 4
_ec$4 = -28						; size = 4
_en$5 = -24						; size = 4
_nnA$6 = -20						; size = 4
_modified$ = -13					; size = 1
_nn$ = -12						; size = 4
_result$ = -8						; size = 4
_this$ = -4						; size = 4
_con$ = 8						; size = 4
?NimVal@NIMCON@@QAEHPBVCON@@@Z PROC			; NIMCON::NimVal
; _this$ = ecx

; 734  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	57		 push	 edi
  00007	51		 push	 ecx
  00008	8d 7d d8	 lea	 edi, DWORD PTR [ebp-40]
  0000b	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	59		 pop	 ecx
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 735  :   ui result;
; 736  :   int nn;
; 737  :   bool modified;
; 738  : //  SetupLookupTables();
; 739  :   *this = con;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _con$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ??4NIMCON@@QAEAAV0@PBVCON@@@Z ; NIMCON::operator=

; 740  :   Simplify(0, m_numNode);

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002c	52		 push	 edx
  0002d	6a 00		 push	 0
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Simplify@NIMCON@@QAE_NHH@Z ; NIMCON::Simplify
$LN4@NimVal:

; 741  :   //
; 742  :   //
; 743  :   //
; 744  :   // We need to deal with capturable coins.
; 745  :   // There are two cases.
; 746  :   // 1) taking the coins does not change the nim-value.
; 747  :   // 2) the nim-value is LOONY
; 748  :   do
; 749  :   {
; 750  :     modified = false;

  00037	c6 45 f3 00	 mov	 BYTE PTR _modified$[ebp], 0

; 751  :     for (nn=0; !modified && (nn<m_numNode); nn++)

  0003b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _nn$[ebp], 0
  00042	eb 09		 jmp	 SHORT $LN7@NimVal
$LN5@NimVal:
  00044	8b 45 f4	 mov	 eax, DWORD PTR _nn$[ebp]
  00047	83 c0 01	 add	 eax, 1
  0004a	89 45 f4	 mov	 DWORD PTR _nn$[ebp], eax
$LN7@NimVal:
  0004d	0f b6 4d f3	 movzx	 ecx, BYTE PTR _modified$[ebp]
  00051	85 c9		 test	 ecx, ecx
  00053	0f 85 f0 01 00
	00		 jne	 $LN2@NimVal
  00059	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005c	8b 45 f4	 mov	 eax, DWORD PTR _nn$[ebp]
  0005f	3b 02		 cmp	 eax, DWORD PTR [edx]
  00061	0f 8d e2 01 00
	00		 jge	 $LN2@NimVal

; 752  :     {
; 753  :       int nnA, en, ec;
; 754  :       nnA = nd[nn].ix;

  00067	8b 4d f4	 mov	 ecx, DWORD PTR _nn$[ebp]
  0006a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	0f b6 84 8a 13
	10 00 00	 movzx	 eax, BYTE PTR [edx+ecx*4+4115]
  00075	89 45 ec	 mov	 DWORD PTR _nnA$6[ebp], eax

; 755  :       if (IS_ISOLATED(sd[nnA][0].ns))

  00078	8b 4d ec	 mov	 ecx, DWORD PTR _nnA$6[ebp]
  0007b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0007e	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  00085	b9 02 00 00 00	 mov	 ecx, 2
  0008a	6b d1 00	 imul	 edx, ecx, 0
  0008d	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  00091	3d fa 00 00 00	 cmp	 eax, 250		; 000000faH
  00096	0f 8e 1c 01 00
	00		 jle	 $LN11@NimVal

; 756  :       {
; 757  :         if (     (sd[nnA][0].ns == GND_GND)
; 758  :               || (sd[nnA][0].ns == LOOP) ) continue;

  0009c	8b 4d ec	 mov	 ecx, DWORD PTR _nnA$6[ebp]
  0009f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a2	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  000a9	b9 02 00 00 00	 mov	 ecx, 2
  000ae	6b d1 00	 imul	 edx, ecx, 0
  000b1	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  000b5	3d fd 00 00 00	 cmp	 eax, 253		; 000000fdH
  000ba	74 20		 je	 SHORT $LN14@NimVal
  000bc	8b 4d ec	 mov	 ecx, DWORD PTR _nnA$6[ebp]
  000bf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c2	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  000c9	b9 02 00 00 00	 mov	 ecx, 2
  000ce	6b d1 00	 imul	 edx, ecx, 0
  000d1	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  000d5	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  000da	75 05		 jne	 SHORT $LN13@NimVal
$LN14@NimVal:
  000dc	e9 63 ff ff ff	 jmp	 $LN5@NimVal
$LN13@NimVal:

; 759  :         if (sd[nnA][0].ns == DE_DE)

  000e1	8b 4d ec	 mov	 ecx, DWORD PTR _nnA$6[ebp]
  000e4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000e7	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  000ee	b9 02 00 00 00	 mov	 ecx, 2
  000f3	6b d1 00	 imul	 edx, ecx, 0
  000f6	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  000fa	3d fb 00 00 00	 cmp	 eax, 251		; 000000fbH
  000ff	75 42		 jne	 SHORT $LN15@NimVal

; 760  :         {
; 761  :           int el;
; 762  :           el = ed[nnA].e[0].el;

  00101	8b 4d ec	 mov	 ecx, DWORD PTR _nnA$6[ebp]
  00104	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00107	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  0010b	b9 02 00 00 00	 mov	 ecx, 2
  00110	6b d1 00	 imul	 edx, ecx, 0
  00113	0f b6 44 10 01	 movzx	 eax, BYTE PTR [eax+edx+1]
  00118	89 45 e0	 mov	 DWORD PTR _el$3[ebp], eax

; 763  :           if (el < 4)

  0011b	83 7d e0 04	 cmp	 DWORD PTR _el$3[ebp], 4
  0011f	7d 16		 jge	 SHORT $LN17@NimVal

; 764  :           {
; 765  :             DeleteNode(nn, &m_numNode);

  00121	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00124	51		 push	 ecx
  00125	8b 55 f4	 mov	 edx, DWORD PTR _nn$[ebp]
  00128	52		 push	 edx
  00129	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012c	e8 00 00 00 00	 call	 ?DeleteNode@NIMCON@@QAEXHPAH@Z ; NIMCON::DeleteNode

; 766  :             modified = true;

  00131	c6 45 f3 01	 mov	 BYTE PTR _modified$[ebp], 1

; 767  :           }

  00135	eb 0a		 jmp	 SHORT $LN18@NimVal
$LN17@NimVal:

; 768  :           else
; 769  :           {
; 770  :             return LOONY4;

  00137	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0013c	e9 2a 01 00 00	 jmp	 $LN1@NimVal
$LN18@NimVal:

; 771  :           };
; 772  :         }

  00141	eb 70		 jmp	 SHORT $LN16@NimVal
$LN15@NimVal:

; 773  :         else if (sd[nnA][0].ns == GND_DE)

  00143	8b 45 ec	 mov	 eax, DWORD PTR _nnA$6[ebp]
  00146	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00149	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  00150	b8 02 00 00 00	 mov	 eax, 2
  00155	6b c8 00	 imul	 ecx, eax, 0
  00158	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  0015c	81 fa fc 00 00
	00		 cmp	 edx, 252		; 000000fcH
  00162	75 42		 jne	 SHORT $LN19@NimVal

; 774  :         {
; 775  :           int el;
; 776  :           el = ed[nnA].e[0].el;

  00164	8b 45 ec	 mov	 eax, DWORD PTR _nnA$6[ebp]
  00167	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0016a	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  0016e	b8 02 00 00 00	 mov	 eax, 2
  00173	6b c8 00	 imul	 ecx, eax, 0
  00176	0f b6 54 0a 01	 movzx	 edx, BYTE PTR [edx+ecx+1]
  0017b	89 55 dc	 mov	 DWORD PTR _el$2[ebp], edx

; 777  :           if (el < 2)

  0017e	83 7d dc 02	 cmp	 DWORD PTR _el$2[ebp], 2
  00182	7d 16		 jge	 SHORT $LN21@NimVal

; 778  :           {
; 779  :             DeleteNode(nn, &m_numNode);

  00184	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00187	50		 push	 eax
  00188	8b 4d f4	 mov	 ecx, DWORD PTR _nn$[ebp]
  0018b	51		 push	 ecx
  0018c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0018f	e8 00 00 00 00	 call	 ?DeleteNode@NIMCON@@QAEXHPAH@Z ; NIMCON::DeleteNode

; 780  :             modified = true;

  00194	c6 45 f3 01	 mov	 BYTE PTR _modified$[ebp], 1

; 781  :           }

  00198	eb 0a		 jmp	 SHORT $LN22@NimVal
$LN21@NimVal:

; 782  :           else
; 783  :           {
; 784  :             return LOONY2;

  0019a	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0019f	e9 c7 00 00 00	 jmp	 $LN1@NimVal
$LN22@NimVal:

; 785  :           };
; 786  :         }

  001a4	eb 0d		 jmp	 SHORT $LN16@NimVal
$LN19@NimVal:

; 787  :         else
; 788  :         {
; 789  :           ImplementationError("Illegal Capturable configuration");

  001a6	68 00 00 00 00	 push	 OFFSET $SG225680
  001ab	e8 00 00 00 00	 call	 ?ImplementationError@@YAXPBD@Z ; ImplementationError
  001b0	83 c4 04	 add	 esp, 4
$LN16@NimVal:

; 790  :         };
; 791  :       }

  001b3	e9 8c 00 00 00	 jmp	 $LN12@NimVal
$LN11@NimVal:

; 792  :       else
; 793  :       {
; 794  :         ec = nd[nnA].ec;

  001b8	8b 55 ec	 mov	 edx, DWORD PTR _nnA$6[ebp]
  001bb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001be	0f b6 8c 90 10
	10 00 00	 movzx	 ecx, BYTE PTR [eax+edx*4+4112]
  001c6	89 4d e4	 mov	 DWORD PTR _ec$4[ebp], ecx

; 795  :         for (en=0; !modified && (en<ec); en++)

  001c9	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _en$5[ebp], 0
  001d0	eb 09		 jmp	 SHORT $LN10@NimVal
$LN8@NimVal:
  001d2	8b 55 e8	 mov	 edx, DWORD PTR _en$5[ebp]
  001d5	83 c2 01	 add	 edx, 1
  001d8	89 55 e8	 mov	 DWORD PTR _en$5[ebp], edx
$LN10@NimVal:
  001db	0f b6 45 f3	 movzx	 eax, BYTE PTR _modified$[ebp]
  001df	85 c0		 test	 eax, eax
  001e1	75 61		 jne	 SHORT $LN12@NimVal
  001e3	8b 4d e8	 mov	 ecx, DWORD PTR _en$5[ebp]
  001e6	3b 4d e4	 cmp	 ecx, DWORD PTR _ec$4[ebp]
  001e9	7d 59		 jge	 SHORT $LN12@NimVal

; 796  :         {
; 797  :           if (sd[nnA][en].ns == DEADEND)

  001eb	8b 55 ec	 mov	 edx, DWORD PTR _nnA$6[ebp]
  001ee	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001f1	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  001f8	8b 55 e8	 mov	 edx, DWORD PTR _en$5[ebp]
  001fb	0f b6 04 51	 movzx	 eax, BYTE PTR [ecx+edx*2]
  001ff	3d f9 00 00 00	 cmp	 eax, 249		; 000000f9H
  00204	75 3c		 jne	 SHORT $LN23@NimVal

; 798  :           {
; 799  :             int el;
; 800  :             el = ed[nnA].e[en].el;

  00206	8b 4d ec	 mov	 ecx, DWORD PTR _nnA$6[ebp]
  00209	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0020c	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  00210	8b 4d e8	 mov	 ecx, DWORD PTR _en$5[ebp]
  00213	0f b6 54 48 01	 movzx	 edx, BYTE PTR [eax+ecx*2+1]
  00218	89 55 d8	 mov	 DWORD PTR _el$1[ebp], edx

; 801  :             if (el == 1)

  0021b	83 7d d8 01	 cmp	 DWORD PTR _el$1[ebp], 1
  0021f	75 1a		 jne	 SHORT $LN24@NimVal

; 802  :             {
; 803  :               DeleteEdge(nn, en, &m_numNode);

  00221	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00224	50		 push	 eax
  00225	8b 4d e8	 mov	 ecx, DWORD PTR _en$5[ebp]
  00228	51		 push	 ecx
  00229	8b 55 f4	 mov	 edx, DWORD PTR _nn$[ebp]
  0022c	52		 push	 edx
  0022d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00230	e8 00 00 00 00	 call	 ?DeleteEdge@NIMCON@@QAEXHHPAH@Z ; NIMCON::DeleteEdge

; 804  :               modified = true;

  00235	c6 45 f3 01	 mov	 BYTE PTR _modified$[ebp], 1

; 805  :             }

  00239	eb 07		 jmp	 SHORT $LN23@NimVal
$LN24@NimVal:

; 806  :             else
; 807  :             {
; 808  :               return LOONY2;

  0023b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00240	eb 29		 jmp	 SHORT $LN1@NimVal
$LN23@NimVal:

; 809  :             };
; 810  :           };
; 811  :         };

  00242	eb 8e		 jmp	 SHORT $LN8@NimVal
$LN12@NimVal:

; 812  :       };
; 813  :     };

  00244	e9 fb fd ff ff	 jmp	 $LN5@NimVal
$LN2@NimVal:

; 814  :   } while (modified);

  00249	0f b6 45 f3	 movzx	 eax, BYTE PTR _modified$[ebp]
  0024d	85 c0		 test	 eax, eax
  0024f	0f 85 e2 fd ff
	ff		 jne	 $LN4@NimVal

; 815  : 
; 816  : 
; 817  : 
; 818  :   result = NimVal(0,m_numNode);

  00255	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00258	8b 11		 mov	 edx, DWORD PTR [ecx]
  0025a	52		 push	 edx
  0025b	6a 00		 push	 0
  0025d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00260	e8 00 00 00 00	 call	 ?NimVal@NIMCON@@QAEHHH@Z ; NIMCON::NimVal
  00265	89 45 f8	 mov	 DWORD PTR _result$[ebp], eax

; 819  : 
; 820  :   return result;

  00268	8b 45 f8	 mov	 eax, DWORD PTR _result$[ebp]
$LN1@NimVal:

; 821  : }

  0026b	5f		 pop	 edi
  0026c	83 c4 28	 add	 esp, 40			; 00000028H
  0026f	3b ec		 cmp	 ebp, esp
  00271	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00276	8b e5		 mov	 esp, ebp
  00278	5d		 pop	 ebp
  00279	c2 04 00	 ret	 4
?NimVal@NIMCON@@QAEHPBVCON@@@Z ENDP			; NIMCON::NimVal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\NIMCON.h
;	COMDAT ?MoveEdge@CON@@QAEXHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nnA$ = 8						; size = 4
_edgeFrom$ = 12						; size = 4
_edgeTo$ = 16						; size = 4
?MoveEdge@CON@@QAEXHHH@Z PROC				; CON::MoveEdge, COMDAT
; _this$ = ecx

; 250  :   {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 251  :     sd[nnA][edgeTo]=sd[nnA][edgeFrom];

  0000e	8b 45 08	 mov	 eax, DWORD PTR _nnA$[ebp]
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  0001b	8b 45 0c	 mov	 eax, DWORD PTR _edgeFrom$[ebp]
  0001e	66 8b 0c 42	 mov	 cx, WORD PTR [edx+eax*2]
  00022	8b 55 08	 mov	 edx, DWORD PTR _nnA$[ebp]
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8d 94 d0 10 08
	00 00		 lea	 edx, DWORD PTR [eax+edx*8+2064]
  0002f	8b 45 10	 mov	 eax, DWORD PTR _edgeTo$[ebp]
  00032	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx

; 252  :     ed[nnA].e[edgeTo]=ed[nnA].e[edgeFrom];

  00036	8b 4d 08	 mov	 ecx, DWORD PTR _nnA$[ebp]
  00039	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _edgeFrom$[ebp]
  00043	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  00046	52		 push	 edx
  00047	8b 45 08	 mov	 eax, DWORD PTR _nnA$[ebp]
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  00051	8b 45 10	 mov	 eax, DWORD PTR _edgeTo$[ebp]
  00054	8d 0c 42	 lea	 ecx, DWORD PTR [edx+eax*2]
  00057	e8 00 00 00 00	 call	 ??4EDGE@@QAEXABU0@@Z	; EDGE::operator=

; 253  :     if (IS_A_NODE(sd[nnA][edgeTo].ns))

  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _nnA$[ebp]
  0005f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00062	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  00069	8b 4d 10	 mov	 ecx, DWORD PTR _edgeTo$[ebp]
  0006c	0f b6 14 48	 movzx	 edx, BYTE PTR [eax+ecx*2]
  00070	81 fa f9 00 00
	00		 cmp	 edx, 249		; 000000f9H
  00076	7d 3a		 jge	 SHORT $LN1@MoveEdge

; 254  :     {
; 255  :       sd[sd[nnA][edgeTo].ns][sd[nnA][edgeTo].ne].ne=(EDGENUM)edgeTo;

  00078	8b 45 08	 mov	 eax, DWORD PTR _nnA$[ebp]
  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  00085	8b 45 10	 mov	 eax, DWORD PTR _edgeTo$[ebp]
  00088	0f b6 0c 42	 movzx	 ecx, BYTE PTR [edx+eax*2]
  0008c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0008f	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  00096	8b 4d 08	 mov	 ecx, DWORD PTR _nnA$[ebp]
  00099	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009c	8d 8c ca 10 08
	00 00		 lea	 ecx, DWORD PTR [edx+ecx*8+2064]
  000a3	8b 55 10	 mov	 edx, DWORD PTR _edgeTo$[ebp]
  000a6	0f b6 4c 51 01	 movzx	 ecx, BYTE PTR [ecx+edx*2+1]
  000ab	8a 55 10	 mov	 dl, BYTE PTR _edgeTo$[ebp]
  000ae	88 54 48 01	 mov	 BYTE PTR [eax+ecx*2+1], dl
$LN1@MoveEdge:

; 256  :     };
; 257  :   };

  000b2	83 c4 04	 add	 esp, 4
  000b5	3b ec		 cmp	 ebp, esp
  000b7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c2 0c 00	 ret	 12			; 0000000cH
?MoveEdge@CON@@QAEXHHH@Z ENDP				; CON::MoveEdge
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\NIMCON.h
;	COMDAT ?Clear@STOPDATA@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@STOPDATA@@QAEXXZ PROC				; STOPDATA::Clear, COMDAT
; _this$ = ecx

; 186  :   inline void Clear(void){*((ui16 *)this)=UNUSED2;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	66 89 01	 mov	 WORD PTR [ecx], ax
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?Clear@STOPDATA@@QAEXXZ ENDP				; STOPDATA::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\NIMCON.h
;	COMDAT ??4EDGEDATA@@QAEXABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ed$ = 8						; size = 4
??4EDGEDATA@@QAEXABU0@@Z PROC				; EDGEDATA::operator=, COMDAT
; _this$ = ecx

; 172  :   {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 173  :     *((ui64 *)this) = *((ui64 *)(&ed));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _ed$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00012	89 10		 mov	 DWORD PTR [eax], edx
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 174  :   };

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??4EDGEDATA@@QAEXABU0@@Z ENDP				; EDGEDATA::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\NIMCON.h
;	COMDAT ?Clear@EDGE@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@EDGE@@QAEXXZ PROC				; EDGE::Clear, COMDAT
; _this$ = ecx

; 156  :   inline void Clear(void){*((ui16 *)this)=UNUSED2;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	66 89 01	 mov	 WORD PTR [ecx], ax
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?Clear@EDGE@@QAEXXZ ENDP				; EDGE::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\NIMCON.h
;	COMDAT ??4EDGE@@QAEXABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_e$ = 8							; size = 4
??4EDGE@@QAEXABU0@@Z PROC				; EDGE::operator=, COMDAT
; _this$ = ecx

; 153  :   {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 154  :     *((ui16 *)(this)) = *((ui16 *)(&e));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _e$[ebp]
  0000d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00010	66 89 10	 mov	 WORD PTR [eax], dx

; 155  :   };

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??4EDGE@@QAEXABU0@@Z ENDP				; EDGE::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\NIMCON.h
;	COMDAT ?GetValue@NIMHASHTABLE@@QBEIH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hashIndex$ = 8						; size = 4
?GetValue@NIMHASHTABLE@@QBEIH@Z PROC			; NIMHASHTABLE::GetValue, COMDAT
; _this$ = ecx

; 131  :   {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  :     return values[hashIndex];

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	8b 55 08	 mov	 edx, DWORD PTR _hashIndex$[ebp]
  00010	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]

; 133  :   };

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?GetValue@NIMHASHTABLE@@QBEIH@Z ENDP			; NIMHASHTABLE::GetValue
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File G:\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\atlmfc\include\afx.h
;	COMDAT ?AfxAssertFailedLine@@YGHPBDH@Z
_TEXT	SEGMENT
_bResult$ = -44						; size = 4
_bQuit$ = -40						; size = 4
_msg$ = -32						; size = 28
_lpszFileName$ = 8					; size = 4
_nLine$ = 12						; size = 4
?AfxAssertFailedLine@@YGHPBDH@Z PROC			; AfxAssertFailedLine, COMDAT

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d d4	 lea	 edi, DWORD PTR [ebp-44]
  0000b	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd

; 313  : 	// we remove WM_QUIT because if it is in the queue then the message box
; 314  : 	// won't display
; 315  : 	MSG msg;
; 316  : 	BOOL bQuit = PeekMessage(&msg, NULL, WM_QUIT, WM_QUIT, PM_REMOVE);

  00017	8b f4		 mov	 esi, esp
  00019	6a 01		 push	 1
  0001b	6a 12		 push	 18			; 00000012H
  0001d	6a 12		 push	 18			; 00000012H
  0001f	6a 00		 push	 0
  00021	8d 45 e0	 lea	 eax, DWORD PTR _msg$[ebp]
  00024	50		 push	 eax
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PeekMessageA@20
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00032	89 45 d8	 mov	 DWORD PTR _bQuit$[ebp], eax

; 317  : 	BOOL bResult = _CrtDbgReport(_CRT_ASSERT, lpszFileName, nLine, NULL, NULL);

  00035	8b f4		 mov	 esi, esp
  00037	6a 00		 push	 0
  00039	6a 00		 push	 0
  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _nLine$[ebp]
  0003e	51		 push	 ecx
  0003f	8b 55 08	 mov	 edx, DWORD PTR _lpszFileName$[ebp]
  00042	52		 push	 edx
  00043	6a 02		 push	 2
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0004b	83 c4 14	 add	 esp, 20			; 00000014H
  0004e	3b f4		 cmp	 esi, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	89 45 d4	 mov	 DWORD PTR _bResult$[ebp], eax

; 318  : 	if (bQuit)

  00058	83 7d d8 00	 cmp	 DWORD PTR _bQuit$[ebp], 0
  0005c	74 13		 je	 SHORT $LN2@AfxAssertF

; 319  : 		PostQuitMessage((int)msg.wParam);

  0005e	8b f4		 mov	 esi, esp
  00060	8b 45 e8	 mov	 eax, DWORD PTR _msg$[ebp+8]
  00063	50		 push	 eax
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4
  0006a	3b f4		 cmp	 esi, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@AfxAssertF:

; 320  : 	return bResult;

  00071	8b 45 d4	 mov	 eax, DWORD PTR _bResult$[ebp]

; 321  : }

  00074	52		 push	 edx
  00075	8b cd		 mov	 ecx, ebp
  00077	50		 push	 eax
  00078	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@AfxAssertF
  0007e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00083	58		 pop	 eax
  00084	5a		 pop	 edx
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	83 c4 2c	 add	 esp, 44			; 0000002cH
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 08 00	 ret	 8
  00097	90		 npad	 1
$LN6@AfxAssertF:
  00098	01 00 00 00	 DD	 1
  0009c	00 00 00 00	 DD	 $LN5@AfxAssertF
$LN5@AfxAssertF:
  000a0	e0 ff ff ff	 DD	 -32			; ffffffe0H
  000a4	1c 00 00 00	 DD	 28			; 0000001cH
  000a8	00 00 00 00	 DD	 $LN4@AfxAssertF
$LN4@AfxAssertF:
  000ac	6d		 DB	 109			; 0000006dH
  000ad	73		 DB	 115			; 00000073H
  000ae	67		 DB	 103			; 00000067H
  000af	00		 DB	 0
?AfxAssertFailedLine@@YGHPBDH@Z ENDP			; AfxAssertFailedLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Nimstring.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Nimstring.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
