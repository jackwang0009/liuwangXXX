; Listing generated by Microsoft (R) Optimizing Compiler Version 19.35.32217.1 

	TITLE	C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\Debug\MoveHistory.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG74042 DB	'atlTraceException', 00H
	ORG $+2
$SG74238 DB	'atlTraceString', 00H
	ORG $+1
$SG226358 DB	'None', 00H
	ORG $+3
$SG226360 DB	'Random', 00H
	ORG $+1
$SG226362 DB	'Obvious Capture', 00H
$SG226364 DB	'Give Nothing', 00H
	ORG $+3
$SG226366 DB	'Break Loops', 00H
$SG226368 DB	'Break Divide', 00H
	ORG $+3
$SG226370 DB	'Divide and Conquer', 00H
	ORG $+1
$SG226372 DB	'Give Little', 00H
$SG226374 DB	'Grab Anything', 00H
	ORG $+2
$SG226376 DB	'SimpleWin', 00H
	ORG $+2
$SG226378 DB	'SimpleTie', 00H
	ORG $+2
$SG226380 DB	'Edit', 00H
	ORG $+3
$SG226382 DB	'Simple Win Capture', 00H
	ORG $+1
$SG226384 DB	'Nimval Capture', 00H
	ORG $+1
$SG226386 DB	'Nimval Decline', 00H
	ORG $+1
$SG226388 DB	'Maximize Capture', 00H
	ORG $+3
$SG226390 DB	'Maximize Decline', 00H
	ORG $+3
$SG226392 DB	'Simple Win Decline', 00H
	ORG $+1
$SG226394 DB	'Verify Nimstring Value', 00H
	ORG $+1
$SG226396 DB	'Nimstring value = 0', 00H
$SG226398 DB	'Nimstring value != 0', 00H
	ORG $+3
$SG226400 DB	'Opening book tie', 00H
	ORG $+3
$SG226402 DB	'Opening book win', 00H
	ORG $+3
$SG226404 DB	'Illegal', 00H
$SG226431 DB	'Getting non-existent ReDo move', 00H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	__vswprintf_s_l
PUBLIC	_swprintf_s
PUBLIC	??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
PUBLIC	?RegisterCategory@CTrace@ATL@@SAXPBDI@Z		; ATL::CTrace::RegisterCategory
PUBLIC	??0VECTOR@@QAE@XZ				; VECTOR::VECTOR
PUBLIC	??0VECTOR@@QAE@HH@Z				; VECTOR::VECTOR
PUBLIC	??4VECTOR@@QAEAAV0@ABUtagPOINT@@@Z		; VECTOR::operator=
PUBLIC	??HVECTOR@@QAE?AV0@ABV0@@Z			; VECTOR::operator+
PUBLIC	?v@DOTS_AND_BOXES@@AAEXXZ			; DOTS_AND_BOXES::v
PUBLIC	?Width@DOTS_AND_BOXES@@QBEHXZ			; DOTS_AND_BOXES::Width
PUBLIC	?Height@DOTS_AND_BOXES@@QBEHXZ			; DOTS_AND_BOXES::Height
PUBLIC	?Size@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ	; DOTS_AND_BOXES::Size
PUBLIC	?SetVLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetVLineType
PUBLIC	?SetVLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetVLineType
PUBLIC	?SetHLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetHLineType
PUBLIC	?SetHLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetHLineType
PUBLIC	?BoxOwner@DOTS_AND_BOXES@@QBE?AW4OWNER_TYPE@@HH@Z ; DOTS_AND_BOXES::BoxOwner
PUBLIC	?BoxOwner@DOTS_AND_BOXES@@QBE?AW4OWNER_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::BoxOwner
PUBLIC	?SetBoxOwner@DOTS_AND_BOXES@@QAEXHHW4OWNER_TYPE@@@Z ; DOTS_AND_BOXES::SetBoxOwner
PUBLIC	?SetBoxOwner@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4OWNER_TYPE@@@Z ; DOTS_AND_BOXES::SetBoxOwner
PUBLIC	?FindCaptures@MOVE@@QAEXPAVDOTS_AND_BOXES@@@Z	; MOVE::FindCaptures
PUBLIC	?SetCaptures@MOVE@@QAEXPAVDOTS_AND_BOXES@@@Z	; MOVE::SetCaptures
PUBLIC	?ConstructFromLineNumber@MOVE@@QAEXH@Z		; MOVE::ConstructFromLineNumber
PUBLIC	?TypeName@MOVE@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; MOVE::TypeName
PUBLIC	??0MOVE@@QAE@XZ					; MOVE::MOVE
PUBLIC	?IsUndoPossible@MOVE_HISTORY@@QAE_NXZ		; MOVE_HISTORY::IsUndoPossible
PUBLIC	?IsRedoPossible@MOVE_HISTORY@@QAE_NXZ		; MOVE_HISTORY::IsRedoPossible
PUBLIC	?GetUndoMove@MOVE_HISTORY@@QAE?AUMOVE@@XZ	; MOVE_HISTORY::GetUndoMove
PUBLIC	?GetRedoMove@MOVE_HISTORY@@QAE?AUMOVE@@XZ	; MOVE_HISTORY::GetRedoMove
PUBLIC	?OwnerType@@YA?AW4OWNER_TYPE@@W4LINE_TYPE@@@Z	; OwnerType
PUBLIC	?GameSize@CNewBoxesDoc@@QAE?AUtagPOINT@@XZ	; CNewBoxesDoc::GameSize
PUBLIC	?IsUndoPossible@CNewBoxesDoc@@QAE_NXZ		; CNewBoxesDoc::IsUndoPossible
PUBLIC	?IsRedoPossible@CNewBoxesDoc@@QAE_NXZ		; CNewBoxesDoc::IsRedoPossible
PUBLIC	?GetUndoMove@CNewBoxesDoc@@QAE?AUMOVE@@XZ	; CNewBoxesDoc::GetUndoMove
PUBLIC	?GetRedoMove@CNewBoxesDoc@@QAE?AUMOVE@@XZ	; CNewBoxesDoc::GetRedoMove
PUBLIC	?Game@CNewBoxesDoc@@QAEAAVDOTS_AND_BOXES@@XZ	; CNewBoxesDoc::Game
PUBLIC	??_GPROCESS@@QAEPAXI@Z				; PROCESS::`scalar deleting destructor'
PUBLIC	?OnInitialize@PROCESS_UNDO_TURN@@EAE?AW4STATUS@@XZ ; PROCESS_UNDO_TURN::OnInitialize
PUBLIC	?OnReturn@PROCESS_UNDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z ; PROCESS_UNDO_TURN::OnReturn
PUBLIC	?OnInitialize@PROCESS_REDO_TURN@@EAE?AW4STATUS@@XZ ; PROCESS_REDO_TURN::OnInitialize
PUBLIC	?OnReturn@PROCESS_REDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z ; PROCESS_REDO_TURN::OnReturn
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs@		; `string'
PUBLIC	?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
PUBLIC	?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
PUBLIC	?m_nLastCategory@CTrace@ATL@@1IA		; ATL::CTrace::m_nLastCategory
PUBLIC	?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A	; ATL::CTrace::m_nMap
PUBLIC	??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs@		; `string'
PUBLIC	??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm@ ; `string'
PUBLIC	??_C@_1LM@KONDCONO@?$AAG?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi@ ; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__imp__wcscpy_s:PROC
EXTRN	__imp____stdio_common_vswprintf_s:PROC
EXTRN	__imp___CrtDbgReportW:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z:PROC
EXTRN	?die@@YAXPBD@Z:PROC				; die
EXTRN	?CountLines@DOTS_AND_BOXES@@QBEHUtagPOINT@@@Z:PROC ; DOTS_AND_BOXES::CountLines
EXTRN	?PushProcess@PROCESS@@IAEXPAV1@@Z:PROC		; PROCESS::PushProcess
EXTRN	??1PROCESS@@QAE@XZ:PROC				; PROCESS::~PROCESS
EXTRN	??0PROCESS_FLASH@@QAE@ABUMOVE@@@Z:PROC		; PROCESS_FLASH::PROCESS_FLASH
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	?pDoc@@3PAVCNewBoxesDoc@@A:DWORD		; pDoc
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceException
_BSS	ENDS
;	COMDAT ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceString
_BSS	ENDS
;	COMDAT ?m_nLastCategory@CTrace@ATL@@1IA
_BSS	SEGMENT
?m_nLastCategory@CTrace@ATL@@1IA DD 01H DUP (?)		; ATL::CTrace::m_nLastCategory
_BSS	ENDS
;	COMDAT ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A
_BSS	SEGMENT
?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A DB 02080H DUP (?) ; ATL::CTrace::m_nMap
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceException$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceException@ATL@@YAXXZ ; ATL::atlTraceException$initializer$
CRT$XCU	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1LM@KONDCONO@?$AAG?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi@
CONST	SEGMENT
??_C@_1LM@KONDCONO@?$AAG?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi@ DB 'G'
	DB	00H, ':', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r', 00H
	DB	'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H, 'V'
	DB	00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' ', 00H
	DB	'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, '\'
	DB	00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H, 'C', 00H
	DB	'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H, 't'
	DB	00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T', 00H
	DB	'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H, 'S'
	DB	00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.', 00H
	DB	'3', 00H, '5', 00H, '.', 00H, '3', 00H, '2', 00H, '2', 00H, '1'
	DB	00H, '5', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm', 00H
	DB	'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't', 00H
	DB	'l', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'c', 00H, 'e', 00H, '.'
	DB	00H, 'h', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm@
CONST	SEGMENT
??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm@ DB 'f'
	DB	00H, 'a', 00H, 'l', 00H, 's', 00H, 'e', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, '"', 00H, 'T', 00H, 'o', 00H, 'o', 00H, ' '
	DB	00H, 'm', 00H, 'a', 00H, 'n', 00H, 'y', 00H, ' ', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, 'd', 00H, 'e', 00H, 'f', 00H
	DB	'i', 00H, 'n', 00H, 'e', 00H, 'd', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs@
CONST	SEGMENT
??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs@ DB '%', 00H, 'h', 00H, 's', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs@
CONST	SEGMENT
??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs@ DB '%', 00H, 'l', 00H, 's', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$?OnReturn@PROCESS_REDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnReturn@PROCESS_REDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z$0
__unwindtable$?OnReturn@PROCESS_UNDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnReturn@PROCESS_UNDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z$0
__ehfuncinfo$?OnReturn@PROCESS_REDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OnReturn@PROCESS_REDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?OnReturn@PROCESS_UNDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OnReturn@PROCESS_UNDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__unwindfunclet$?OnReturn@PROCESS_REDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z$0
	DD	01dH
	DD	027H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?OnReturn@PROCESS_REDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z
	DD	02eH
	DD	0139H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__unwindfunclet$?OnReturn@PROCESS_UNDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z$0
	DD	01dH
	DD	027H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?OnReturn@PROCESS_UNDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z
	DD	02eH
	DD	010bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?GetRedoMove@MOVE_HISTORY@@QAE?AUMOVE@@XZ
	DD	020H
	DD	0acH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?GetUndoMove@MOVE_HISTORY@@QAE?AUMOVE@@XZ
	DD	020H
	DD	013dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	024H
	DW	0100H
voltbl	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceString$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceString@ATL@@YAXXZ ; ATL::atlTraceString$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\MoveHistory.cpp
_TEXT	SEGMENT
tv142 = -96						; size = 4
tv69 = -92						; size = 4
$T2 = -88						; size = 4
$T3 = -84						; size = 4
$T4 = -80						; size = 4
$T5 = -76						; size = 56
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pFlashingProcess$ = 8					; size = 4
?OnReturn@PROCESS_REDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z PROC ; PROCESS_REDO_TURN::OnReturn
; _this$ = ecx

; 260  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnReturn@PROCESS_REDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	8d 7d a0	 lea	 edi, DWORD PTR [ebp-96]
  0001a	b9 15 00 00 00	 mov	 ecx, 21			; 00000015H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	59		 pop	 ecx
  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002c	33 c5		 xor	 eax, ebp
  0002e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00031	50		 push	 eax
  00032	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00035	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003b	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 261  :   if (pFlashingProcess != NULL) 

  0003e	83 7d 08 00	 cmp	 DWORD PTR _pFlashingProcess$[ebp], 0
  00042	74 2c		 je	 SHORT $LN2@OnReturn

; 262  :   {
; 263  :     delete pFlashingProcess;

  00044	8b 45 08	 mov	 eax, DWORD PTR _pFlashingProcess$[ebp]
  00047	89 45 b0	 mov	 DWORD PTR $T4[ebp], eax
  0004a	83 7d b0 00	 cmp	 DWORD PTR $T4[ebp], 0
  0004e	74 0f		 je	 SHORT $LN5@OnReturn
  00050	6a 01		 push	 1
  00052	8b 4d b0	 mov	 ecx, DWORD PTR $T4[ebp]
  00055	e8 00 00 00 00	 call	 ??_GPROCESS@@QAEPAXI@Z
  0005a	89 45 a4	 mov	 DWORD PTR tv69[ebp], eax
  0005d	eb 07		 jmp	 SHORT $LN6@OnReturn
$LN5@OnReturn:
  0005f	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN6@OnReturn:

; 264  : //    if (m_move.vertical) pDoc->VerticalLineType(m_move.dotNum, m_move.newLineType);
; 265  : //    else pDoc->HorizontalLineType(m_move.dotNum, m_move.newLineType);
; 266  : //    if (m_move.boxesCaptured[0].x >= 0) 
; 267  : //    {
; 268  : //      pDoc->BoxOwner(m_move.boxesCaptured[0],m_move.newOwnerType[0]);
; 269  : //      if (m_move.boxesCaptured[1].x >= 0) 
; 270  : //      {
; 271  : //        pDoc->BoxOwner(m_move.boxesCaptured[1],m_move.newOwnerType[1]);
; 272  : //      };
; 273  : //    }
; 274  : //    else
; 275  : //    {
; 276  :     return STATUS_DONE;

  00066	b8 02 00 00 00	 mov	 eax, 2
  0006b	e9 bc 00 00 00	 jmp	 $LN1@OnReturn
$LN2@OnReturn:

; 277  : //    };
; 278  :   };
; 279  :   if (pDoc->IsRedoPossible())

  00070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pDoc@@3PAVCNewBoxesDoc@@A ; pDoc
  00076	e8 00 00 00 00	 call	 ?IsRedoPossible@CNewBoxesDoc@@QAE_NXZ ; CNewBoxesDoc::IsRedoPossible
  0007b	0f b6 c8	 movzx	 ecx, al
  0007e	85 c9		 test	 ecx, ecx
  00080	0f 84 a1 00 00
	00		 je	 $LN3@OnReturn

; 280  :   {
; 281  :     m_move = pDoc->GetRedoMove();

  00086	8d 55 b4	 lea	 edx, DWORD PTR $T5[ebp]
  00089	52		 push	 edx
  0008a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pDoc@@3PAVCNewBoxesDoc@@A ; pDoc
  00090	e8 00 00 00 00	 call	 ?GetRedoMove@CNewBoxesDoc@@QAE?AUMOVE@@XZ ; CNewBoxesDoc::GetRedoMove
  00095	8b 7d ec	 mov	 edi, DWORD PTR _this$[ebp]
  00098	83 c7 08	 add	 edi, 8
  0009b	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  000a0	8b f0		 mov	 esi, eax
  000a2	f3 a5		 rep movsd

; 282  :     m_move.FindCaptures(&pDoc->Game());

  000a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pDoc@@3PAVCNewBoxesDoc@@A ; pDoc
  000aa	e8 00 00 00 00	 call	 ?Game@CNewBoxesDoc@@QAEAAVDOTS_AND_BOXES@@XZ ; CNewBoxesDoc::Game
  000af	50		 push	 eax
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	83 c1 08	 add	 ecx, 8
  000b6	e8 00 00 00 00	 call	 ?FindCaptures@MOVE@@QAEXPAVDOTS_AND_BOXES@@@Z ; MOVE::FindCaptures

; 283  :     m_move.SetCaptures(&pDoc->Game());

  000bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pDoc@@3PAVCNewBoxesDoc@@A ; pDoc
  000c1	e8 00 00 00 00	 call	 ?Game@CNewBoxesDoc@@QAEAAVDOTS_AND_BOXES@@XZ ; CNewBoxesDoc::Game
  000c6	50		 push	 eax
  000c7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	83 c1 08	 add	 ecx, 8
  000cd	e8 00 00 00 00	 call	 ?SetCaptures@MOVE@@QAEXPAVDOTS_AND_BOXES@@@Z ; MOVE::SetCaptures

; 284  :     PushProcess(new PROCESS_FLASH(m_move));

  000d2	6a 4c		 push	 76			; 0000004cH
  000d4	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000d9	83 c4 04	 add	 esp, 4
  000dc	89 45 a8	 mov	 DWORD PTR $T2[ebp], eax
  000df	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000e6	83 7d a8 00	 cmp	 DWORD PTR $T2[ebp], 0
  000ea	74 14		 je	 SHORT $LN7@OnReturn
  000ec	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	83 c0 08	 add	 eax, 8
  000f2	50		 push	 eax
  000f3	8b 4d a8	 mov	 ecx, DWORD PTR $T2[ebp]
  000f6	e8 00 00 00 00	 call	 ??0PROCESS_FLASH@@QAE@ABUMOVE@@@Z ; PROCESS_FLASH::PROCESS_FLASH
  000fb	89 45 a0	 mov	 DWORD PTR tv142[ebp], eax
  000fe	eb 07		 jmp	 SHORT $LN8@OnReturn
$LN7@OnReturn:
  00100	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv142[ebp], 0
$LN8@OnReturn:
  00107	8b 4d a0	 mov	 ecx, DWORD PTR tv142[ebp]
  0010a	89 4d ac	 mov	 DWORD PTR $T3[ebp], ecx
  0010d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00114	8b 55 ac	 mov	 edx, DWORD PTR $T3[ebp]
  00117	52		 push	 edx
  00118	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011b	e8 00 00 00 00	 call	 ?PushProcess@PROCESS@@IAEXPAV1@@Z ; PROCESS::PushProcess

; 285  :     return STATUS_OK;

  00120	b8 03 00 00 00	 mov	 eax, 3
  00125	eb 05		 jmp	 SHORT $LN1@OnReturn
$LN3@OnReturn:

; 286  :   };
; 287  :   return STATUS_DONE;

  00127	b8 02 00 00 00	 mov	 eax, 2
$LN1@OnReturn:

; 288  : }

  0012c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0012f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00136	59		 pop	 ecx
  00137	5f		 pop	 edi
  00138	5e		 pop	 esi
  00139	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013c	33 cd		 xor	 ecx, ebp
  0013e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00143	83 c4 60	 add	 esp, 96			; 00000060H
  00146	3b ec		 cmp	 ebp, esp
  00148	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?OnReturn@PROCESS_REDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z$0:
  00000	6a 4c		 push	 76			; 0000004cH
  00002	8b 45 a8	 mov	 eax, DWORD PTR $T2[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
__ehhandler$?OnReturn@PROCESS_REDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z:
  00014	90		 npad	 1
  00015	90		 npad	 1
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnReturn@PROCESS_REDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnReturn@PROCESS_REDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z ENDP ; PROCESS_REDO_TURN::OnReturn
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\MoveHistory.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnInitialize@PROCESS_REDO_TURN@@EAE?AW4STATUS@@XZ PROC	; PROCESS_REDO_TURN::OnInitialize
; _this$ = ecx

; 248  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 249  :  // m_title = "Restoring the latest move";
; 250  :   if (!pDoc->IsRedoPossible())

  0000f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pDoc@@3PAVCNewBoxesDoc@@A ; pDoc
  00015	e8 00 00 00 00	 call	 ?IsRedoPossible@CNewBoxesDoc@@QAE_NXZ ; CNewBoxesDoc::IsRedoPossible
  0001a	0f b6 c0	 movzx	 eax, al
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN2@OnInitiali

; 251  :   {
; 252  :    // MessageBox(NULL,"There are no turns in the ReDo buffer","Warning",MB_OK);
; 253  :     return STATUS_DONE;

  00021	b8 02 00 00 00	 mov	 eax, 2
  00026	eb 1d		 jmp	 SHORT $LN1@OnInitiali
$LN2@OnInitiali:

; 254  :   };
; 255  :   OnReturn(NULL);

  00028	8b f4		 mov	 esi, esp
  0002a	6a 00		 push	 0
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00037	ff d0		 call	 eax
  00039	3b f4		 cmp	 esi, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 256  :   return STATUS_OK;

  00040	b8 03 00 00 00	 mov	 eax, 3
$LN1@OnInitiali:

; 257  : }

  00045	5e		 pop	 esi
  00046	83 c4 04	 add	 esp, 4
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?OnInitialize@PROCESS_REDO_TURN@@EAE?AW4STATUS@@XZ ENDP	; PROCESS_REDO_TURN::OnInitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\MoveHistory.cpp
_TEXT	SEGMENT
tv132 = -96						; size = 4
tv69 = -92						; size = 4
$T2 = -88						; size = 4
$T3 = -84						; size = 4
$T4 = -80						; size = 4
$T5 = -76						; size = 56
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pFlashingProcess$ = 8					; size = 4
?OnReturn@PROCESS_UNDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z PROC ; PROCESS_UNDO_TURN::OnReturn
; _this$ = ecx

; 209  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnReturn@PROCESS_UNDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	8d 7d a0	 lea	 edi, DWORD PTR [ebp-96]
  0001a	b9 15 00 00 00	 mov	 ecx, 21			; 00000015H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	59		 pop	 ecx
  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002c	33 c5		 xor	 eax, ebp
  0002e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00031	50		 push	 eax
  00032	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00035	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003b	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 210  :   if (pFlashingProcess != NULL) 

  0003e	83 7d 08 00	 cmp	 DWORD PTR _pFlashingProcess$[ebp], 0
  00042	74 2e		 je	 SHORT $LN2@OnReturn

; 211  :   {
; 212  :     delete pFlashingProcess;

  00044	8b 45 08	 mov	 eax, DWORD PTR _pFlashingProcess$[ebp]
  00047	89 45 b0	 mov	 DWORD PTR $T4[ebp], eax
  0004a	83 7d b0 00	 cmp	 DWORD PTR $T4[ebp], 0
  0004e	74 0f		 je	 SHORT $LN7@OnReturn
  00050	6a 01		 push	 1
  00052	8b 4d b0	 mov	 ecx, DWORD PTR $T4[ebp]
  00055	e8 00 00 00 00	 call	 ??_GPROCESS@@QAEPAXI@Z
  0005a	89 45 a4	 mov	 DWORD PTR tv69[ebp], eax
  0005d	eb 07		 jmp	 SHORT $LN8@OnReturn
$LN7@OnReturn:
  0005f	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN8@OnReturn:

; 213  : //    if (m_move.vertical) pDoc->VerticalLineType(m_move.dotNum, LINE_NONE);
; 214  : //    else pDoc->HorizontalLineType(m_move.dotNum, LINE_NONE);
; 215  : //    if (m_move.boxesCaptured[0].x >= 0) pDoc->BoxOwner(m_move.boxesCaptured[0], OWNER_NONE);
; 216  : //    if (m_move.boxesCaptured[1].x >= 0) pDoc->BoxOwner(m_move.boxesCaptured[1], OWNER_NONE);
; 217  : //    if (pDoc->IsUndoPossible())
; 218  : //    {
; 219  : //      m_move = pDoc->GetUndoMove();
; 220  : //      m_move.Captures(&pDoc->Game());
; 221  : //      if (m_move.boxesCaptured[0].x < 0)
; 222  : //      {
; 223  : //        pDoc->GetRedoMove();
; 224  : //        return STATUS_DONE;
; 225  : //      };
; 226  : //    }
; 227  : //    else 
; 228  : //    {
; 229  :     return STATUS_DONE;

  00066	b8 02 00 00 00	 mov	 eax, 2
  0006b	e9 8e 00 00 00	 jmp	 $LN1@OnReturn

; 230  : //    };
; 231  :   }

  00070	eb 39		 jmp	 SHORT $LN3@OnReturn
$LN2@OnReturn:

; 232  :   else
; 233  :   {
; 234  :     if (pDoc->IsUndoPossible())

  00072	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pDoc@@3PAVCNewBoxesDoc@@A ; pDoc
  00078	e8 00 00 00 00	 call	 ?IsUndoPossible@CNewBoxesDoc@@QAE_NXZ ; CNewBoxesDoc::IsUndoPossible
  0007d	0f b6 c8	 movzx	 ecx, al
  00080	85 c9		 test	 ecx, ecx
  00082	74 20		 je	 SHORT $LN4@OnReturn

; 235  :     {
; 236  :       m_move = pDoc->GetUndoMove();

  00084	8d 55 b4	 lea	 edx, DWORD PTR $T5[ebp]
  00087	52		 push	 edx
  00088	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pDoc@@3PAVCNewBoxesDoc@@A ; pDoc
  0008e	e8 00 00 00 00	 call	 ?GetUndoMove@CNewBoxesDoc@@QAE?AUMOVE@@XZ ; CNewBoxesDoc::GetUndoMove
  00093	8b 7d ec	 mov	 edi, DWORD PTR _this$[ebp]
  00096	83 c7 08	 add	 edi, 8
  00099	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  0009e	8b f0		 mov	 esi, eax
  000a0	f3 a5		 rep movsd

; 237  :     }

  000a2	eb 07		 jmp	 SHORT $LN3@OnReturn
$LN4@OnReturn:

; 238  :     else
; 239  :     {
; 240  :       return STATUS_DONE;

  000a4	b8 02 00 00 00	 mov	 eax, 2
  000a9	eb 53		 jmp	 SHORT $LN1@OnReturn
$LN3@OnReturn:

; 241  :     };
; 242  :   };
; 243  :   PushProcess(new PROCESS_FLASH(m_move));

  000ab	6a 4c		 push	 76			; 0000004cH
  000ad	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b2	83 c4 04	 add	 esp, 4
  000b5	89 45 a8	 mov	 DWORD PTR $T2[ebp], eax
  000b8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000bf	83 7d a8 00	 cmp	 DWORD PTR $T2[ebp], 0
  000c3	74 14		 je	 SHORT $LN9@OnReturn
  000c5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000c8	83 c0 08	 add	 eax, 8
  000cb	50		 push	 eax
  000cc	8b 4d a8	 mov	 ecx, DWORD PTR $T2[ebp]
  000cf	e8 00 00 00 00	 call	 ??0PROCESS_FLASH@@QAE@ABUMOVE@@@Z ; PROCESS_FLASH::PROCESS_FLASH
  000d4	89 45 a0	 mov	 DWORD PTR tv132[ebp], eax
  000d7	eb 07		 jmp	 SHORT $LN10@OnReturn
$LN9@OnReturn:
  000d9	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv132[ebp], 0
$LN10@OnReturn:
  000e0	8b 4d a0	 mov	 ecx, DWORD PTR tv132[ebp]
  000e3	89 4d ac	 mov	 DWORD PTR $T3[ebp], ecx
  000e6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ed	8b 55 ac	 mov	 edx, DWORD PTR $T3[ebp]
  000f0	52		 push	 edx
  000f1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000f4	e8 00 00 00 00	 call	 ?PushProcess@PROCESS@@IAEXPAV1@@Z ; PROCESS::PushProcess

; 244  :   return STATUS_OK;

  000f9	b8 03 00 00 00	 mov	 eax, 3
$LN1@OnReturn:

; 245  : }

  000fe	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00101	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00108	59		 pop	 ecx
  00109	5f		 pop	 edi
  0010a	5e		 pop	 esi
  0010b	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010e	33 cd		 xor	 ecx, ebp
  00110	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00115	83 c4 60	 add	 esp, 96			; 00000060H
  00118	3b ec		 cmp	 ebp, esp
  0011a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?OnReturn@PROCESS_UNDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z$0:
  00000	6a 4c		 push	 76			; 0000004cH
  00002	8b 45 a8	 mov	 eax, DWORD PTR $T2[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
__ehhandler$?OnReturn@PROCESS_UNDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z:
  00014	90		 npad	 1
  00015	90		 npad	 1
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnReturn@PROCESS_UNDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnReturn@PROCESS_UNDO_TURN@@EAE?AW4STATUS@@PAVPROCESS@@@Z ENDP ; PROCESS_UNDO_TURN::OnReturn
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\MoveHistory.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnInitialize@PROCESS_UNDO_TURN@@EAE?AW4STATUS@@XZ PROC	; PROCESS_UNDO_TURN::OnInitialize
; _this$ = ecx

; 197  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 198  :  // m_title = "Reversing the latest move";
; 199  :   if (!pDoc->IsUndoPossible())

  0000f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pDoc@@3PAVCNewBoxesDoc@@A ; pDoc
  00015	e8 00 00 00 00	 call	 ?IsUndoPossible@CNewBoxesDoc@@QAE_NXZ ; CNewBoxesDoc::IsUndoPossible
  0001a	0f b6 c0	 movzx	 eax, al
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN2@OnInitiali

; 200  :   {
; 201  :    // MessageBox(NULL,"There are no turns in the UnDo buffer","Warning",MB_OK);
; 202  :     return STATUS_DONE;

  00021	b8 02 00 00 00	 mov	 eax, 2
  00026	eb 1d		 jmp	 SHORT $LN1@OnInitiali
$LN2@OnInitiali:

; 203  :   };
; 204  :   OnReturn(NULL);

  00028	8b f4		 mov	 esi, esp
  0002a	6a 00		 push	 0
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00037	ff d0		 call	 eax
  00039	3b f4		 cmp	 esi, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 205  :   return STATUS_OK;

  00040	b8 03 00 00 00	 mov	 eax, 3
$LN1@OnInitiali:

; 206  : }

  00045	5e		 pop	 esi
  00046	83 c4 04	 add	 esp, 4
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?OnInitialize@PROCESS_UNDO_TURN@@EAE?AW4STATUS@@XZ ENDP	; PROCESS_UNDO_TURN::OnInitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_GPROCESS@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GPROCESS@@QAEPAXI@Z PROC				; PROCESS::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1PROCESS@@QAE@XZ	; PROCESS::~PROCESS
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0e		 je	 SHORT $LN2@scalar
  0001e	6a 08		 push	 8
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??_GPROCESS@@QAEPAXI@Z ENDP				; PROCESS::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\NewBoxesDoc.h
;	COMDAT ?Game@CNewBoxesDoc@@QAEAAVDOTS_AND_BOXES@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Game@CNewBoxesDoc@@QAEAAVDOTS_AND_BOXES@@XZ PROC	; CNewBoxesDoc::Game, COMDAT
; _this$ = ecx

; 175  :   DOTS_AND_BOXES& Game(void){return *m_pGame;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 80 28 36 00
	00		 mov	 eax, DWORD PTR [eax+13864]
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?Game@CNewBoxesDoc@@QAEAAVDOTS_AND_BOXES@@XZ ENDP	; CNewBoxesDoc::Game
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\NewBoxesDoc.h
;	COMDAT ?GetRedoMove@CNewBoxesDoc@@QAE?AUMOVE@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetRedoMove@CNewBoxesDoc@@QAE?AUMOVE@@XZ PROC		; CNewBoxesDoc::GetRedoMove, COMDAT
; _this$ = ecx

; 158  :   MOVE GetRedoMove(void){return m_moveHistory.GetRedoMove();};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  0001b	e8 00 00 00 00	 call	 ?GetRedoMove@MOVE_HISTORY@@QAE?AUMOVE@@XZ ; MOVE_HISTORY::GetRedoMove
  00020	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00023	83 c4 04	 add	 esp, 4
  00026	3b ec		 cmp	 ebp, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?GetRedoMove@CNewBoxesDoc@@QAE?AUMOVE@@XZ ENDP		; CNewBoxesDoc::GetRedoMove
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\NewBoxesDoc.h
;	COMDAT ?GetUndoMove@CNewBoxesDoc@@QAE?AUMOVE@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUndoMove@CNewBoxesDoc@@QAE?AUMOVE@@XZ PROC		; CNewBoxesDoc::GetUndoMove, COMDAT
; _this$ = ecx

; 157  :   MOVE GetUndoMove(void){return m_moveHistory.GetUndoMove();};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  0001b	e8 00 00 00 00	 call	 ?GetUndoMove@MOVE_HISTORY@@QAE?AUMOVE@@XZ ; MOVE_HISTORY::GetUndoMove
  00020	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00023	83 c4 04	 add	 esp, 4
  00026	3b ec		 cmp	 ebp, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?GetUndoMove@CNewBoxesDoc@@QAE?AUMOVE@@XZ ENDP		; CNewBoxesDoc::GetUndoMove
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\NewBoxesDoc.h
;	COMDAT ?IsRedoPossible@CNewBoxesDoc@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsRedoPossible@CNewBoxesDoc@@QAE_NXZ PROC		; CNewBoxesDoc::IsRedoPossible, COMDAT
; _this$ = ecx

; 156  :   bool IsRedoPossible(void){return m_moveHistory.IsRedoPossible();};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  00017	e8 00 00 00 00	 call	 ?IsRedoPossible@MOVE_HISTORY@@QAE_NXZ ; MOVE_HISTORY::IsRedoPossible
  0001c	83 c4 04	 add	 esp, 4
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?IsRedoPossible@CNewBoxesDoc@@QAE_NXZ ENDP		; CNewBoxesDoc::IsRedoPossible
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\NewBoxesDoc.h
;	COMDAT ?IsUndoPossible@CNewBoxesDoc@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsUndoPossible@CNewBoxesDoc@@QAE_NXZ PROC		; CNewBoxesDoc::IsUndoPossible, COMDAT
; _this$ = ecx

; 155  :   bool IsUndoPossible(void){return m_moveHistory.IsUndoPossible();};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	81 c1 68 01 00
	00		 add	 ecx, 360		; 00000168H
  00017	e8 00 00 00 00	 call	 ?IsUndoPossible@MOVE_HISTORY@@QAE_NXZ ; MOVE_HISTORY::IsUndoPossible
  0001c	83 c4 04	 add	 esp, 4
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?IsUndoPossible@CNewBoxesDoc@@QAE_NXZ ENDP		; CNewBoxesDoc::IsUndoPossible
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\NewBoxesDoc.h
;	COMDAT ?GameSize@CNewBoxesDoc@@QAE?AUtagPOINT@@XZ
_TEXT	SEGMENT
_p$ = -16						; size = 8
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GameSize@CNewBoxesDoc@@QAE?AUtagPOINT@@XZ PROC		; CNewBoxesDoc::GameSize, COMDAT
; _this$ = ecx

; 75   :   POINT GameSize(void){POINT p={m_pGame->Width(),m_pGame->Height()};return p;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 88 28 36 00
	00		 mov	 ecx, DWORD PTR [eax+13864]
  00026	e8 00 00 00 00	 call	 ?Width@DOTS_AND_BOXES@@QBEHXZ ; DOTS_AND_BOXES::Width
  0002b	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	8b 89 28 36 00
	00		 mov	 ecx, DWORD PTR [ecx+13864]
  00037	e8 00 00 00 00	 call	 ?Height@DOTS_AND_BOXES@@QBEHXZ ; DOTS_AND_BOXES::Height
  0003c	89 45 f4	 mov	 DWORD PTR _p$[ebp+4], eax
  0003f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00042	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00045	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp+4]
  00048	89 02		 mov	 DWORD PTR [edx], eax
  0004a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0004d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00050	52		 push	 edx
  00051	8b cd		 mov	 ecx, ebp
  00053	50		 push	 eax
  00054	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@GameSize
  0005a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0005f	58		 pop	 eax
  00060	5a		 pop	 edx
  00061	83 c4 14	 add	 esp, 20			; 00000014H
  00064	3b ec		 cmp	 ebp, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 04 00	 ret	 4
  00071	0f 1f 00	 npad	 3
$LN5@GameSize:
  00074	01 00 00 00	 DD	 1
  00078	00 00 00 00	 DD	 $LN4@GameSize
$LN4@GameSize:
  0007c	f0 ff ff ff	 DD	 -16			; fffffff0H
  00080	08 00 00 00	 DD	 8
  00084	00 00 00 00	 DD	 $LN3@GameSize
$LN3@GameSize:
  00088	70		 DB	 112			; 00000070H
  00089	00		 DB	 0
?GameSize@CNewBoxesDoc@@QAE?AUtagPOINT@@XZ ENDP		; CNewBoxesDoc::GameSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\MoveHistory.cpp
_TEXT	SEGMENT
tv64 = -4						; size = 4
_lt$ = 8						; size = 4
?OwnerType@@YA?AW4OWNER_TYPE@@W4LINE_TYPE@@@Z PROC	; OwnerType

; 158  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 159  :   switch(lt)

  00004	8b 45 08	 mov	 eax, DWORD PTR _lt$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  0000a	83 7d fc 01	 cmp	 DWORD PTR tv64[ebp], 1
  0000e	74 0a		 je	 SHORT $LN5@OwnerType
  00010	83 7d fc 02	 cmp	 DWORD PTR tv64[ebp], 2
  00014	74 0b		 je	 SHORT $LN6@OwnerType

; 160  :   {
; 161  :   default: return OWNER_NONE;

  00016	33 c0		 xor	 eax, eax
  00018	eb 0c		 jmp	 SHORT $LN1@OwnerType
$LN5@OwnerType:

; 162  :   case LINE_COMPUTER: return OWNER_COMPUTER;

  0001a	b8 02 00 00 00	 mov	 eax, 2
  0001f	eb 05		 jmp	 SHORT $LN1@OwnerType
$LN6@OwnerType:

; 163  :   case LINE_HUMAN: return OWNER_HUMAN;

  00021	b8 01 00 00 00	 mov	 eax, 1
$LN1@OwnerType:

; 164  :   };
; 165  : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?OwnerType@@YA?AW4OWNER_TYPE@@W4LINE_TYPE@@@Z ENDP	; OwnerType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\MoveHistory.cpp
_TEXT	SEGMENT
_size$ = -84						; size = 8
_move$ = -68						; size = 56
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetRedoMove@MOVE_HISTORY@@QAE?AUMOVE@@XZ PROC		; MOVE_HISTORY::GetRedoMove
; _this$ = ecx

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	51		 push	 ecx
  00009	8d 7d a8	 lea	 edi, DWORD PTR [ebp-88]
  0000c	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	59		 pop	 ecx
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 184  :   MOVE move;

  00026	8d 4d bc	 lea	 ecx, DWORD PTR _move$[ebp]
  00029	e8 00 00 00 00	 call	 ??0MOVE@@QAE@XZ

; 185  :   VECTOR size;

  0002e	8d 4d ac	 lea	 ecx, DWORD PTR _size$[ebp]
  00031	e8 00 00 00 00	 call	 ??0VECTOR@@QAE@XZ	; VECTOR::VECTOR

; 186  :   if (m_currentMoves >= m_totalMoves)

  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003f	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00041	7c 1f		 jl	 SHORT $LN2@GetRedoMov

; 187  :   {
; 188  :     die("Getting non-existent ReDo move");

  00043	68 00 00 00 00	 push	 OFFSET $SG226431
  00048	e8 00 00 00 00	 call	 ?die@@YAXPBD@Z		; die
  0004d	83 c4 04	 add	 esp, 4

; 189  :     return move;

  00050	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  00055	8d 75 bc	 lea	 esi, DWORD PTR _move$[ebp]
  00058	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0005b	f3 a5		 rep movsd
  0005d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00060	eb 37		 jmp	 SHORT $LN1@GetRedoMov
$LN2@GetRedoMov:

; 190  :   };
; 191  :   move = this->m_moves[m_currentMoves++];

  00062	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00065	6b 48 04 38	 imul	 ecx, DWORD PTR [eax+4], 56
  00069	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006c	8d 74 0a 08	 lea	 esi, DWORD PTR [edx+ecx+8]
  00070	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  00075	8d 7d bc	 lea	 edi, DWORD PTR _move$[ebp]
  00078	f3 a5		 rep movsd
  0007a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00080	83 c1 01	 add	 ecx, 1
  00083	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00086	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 192  :   return move;

  00089	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  0008e	8d 75 bc	 lea	 esi, DWORD PTR _move$[ebp]
  00091	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00094	f3 a5		 rep movsd
  00096	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@GetRedoMov:

; 193  : }

  00099	52		 push	 edx
  0009a	8b cd		 mov	 ecx, ebp
  0009c	50		 push	 eax
  0009d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@GetRedoMov
  000a3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000a8	58		 pop	 eax
  000a9	5a		 pop	 edx
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000af	33 cd		 xor	 ecx, ebp
  000b1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b6	83 c4 58	 add	 esp, 88			; 00000058H
  000b9	3b ec		 cmp	 ebp, esp
  000bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 04 00	 ret	 4
  000c6	66 90		 npad	 2
$LN7@GetRedoMov:
  000c8	02 00 00 00	 DD	 2
  000cc	00 00 00 00	 DD	 $LN6@GetRedoMov
$LN6@GetRedoMov:
  000d0	bc ff ff ff	 DD	 -68			; ffffffbcH
  000d4	38 00 00 00	 DD	 56			; 00000038H
  000d8	00 00 00 00	 DD	 $LN4@GetRedoMov
  000dc	ac ff ff ff	 DD	 -84			; ffffffacH
  000e0	08 00 00 00	 DD	 8
  000e4	00 00 00 00	 DD	 $LN5@GetRedoMov
$LN5@GetRedoMov:
  000e8	73		 DB	 115			; 00000073H
  000e9	69		 DB	 105			; 00000069H
  000ea	7a		 DB	 122			; 0000007aH
  000eb	65		 DB	 101			; 00000065H
  000ec	00		 DB	 0
$LN4@GetRedoMov:
  000ed	6d		 DB	 109			; 0000006dH
  000ee	6f		 DB	 111			; 0000006fH
  000ef	76		 DB	 118			; 00000076H
  000f0	65		 DB	 101			; 00000065H
  000f1	00		 DB	 0
?GetRedoMove@MOVE_HISTORY@@QAE?AUMOVE@@XZ ENDP		; MOVE_HISTORY::GetRedoMove
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\MoveHistory.cpp
_TEXT	SEGMENT
tv71 = -92						; size = 4
_size$ = -84						; size = 8
_move$ = -68						; size = 56
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetUndoMove@MOVE_HISTORY@@QAE?AUMOVE@@XZ PROC		; MOVE_HISTORY::GetUndoMove
; _this$ = ecx

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	51		 push	 ecx
  00009	8d 7d a4	 lea	 edi, DWORD PTR [ebp-92]
  0000c	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	59		 pop	 ecx
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 170  :   MOVE move;

  00026	8d 4d bc	 lea	 ecx, DWORD PTR _move$[ebp]
  00029	e8 00 00 00 00	 call	 ??0MOVE@@QAE@XZ

; 171  :   VECTOR size;

  0002e	8d 4d ac	 lea	 ecx, DWORD PTR _size$[ebp]
  00031	e8 00 00 00 00	 call	 ??0VECTOR@@QAE@XZ	; VECTOR::VECTOR

; 172  :   move = m_moves[--m_currentMoves];

  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003c	83 e9 01	 sub	 ecx, 1
  0003f	89 4d a4	 mov	 DWORD PTR tv71[ebp], ecx
  00042	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00045	8b 45 a4	 mov	 eax, DWORD PTR tv71[ebp]
  00048	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0004b	6b 4d a4 38	 imul	 ecx, DWORD PTR tv71[ebp], 56
  0004f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00052	8d 74 0a 08	 lea	 esi, DWORD PTR [edx+ecx+8]
  00056	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  0005b	8d 7d bc	 lea	 edi, DWORD PTR _move$[ebp]
  0005e	f3 a5		 rep movsd

; 173  :   move.newLineType = m_moves[m_currentMoves].oldLineType;

  00060	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00063	6b 48 04 38	 imul	 ecx, DWORD PTR [eax+4], 56
  00067	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	8b 44 0a 34	 mov	 eax, DWORD PTR [edx+ecx+52]
  0006e	89 45 ec	 mov	 DWORD PTR _move$[ebp+48], eax

; 174  :   move.oldLineType = m_moves[m_currentMoves].newLineType;

  00071	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	6b 51 04 38	 imul	 edx, DWORD PTR [ecx+4], 56
  00078	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
  0007f	89 4d e8	 mov	 DWORD PTR _move$[ebp+44], ecx

; 175  :   move.oldOwnerType[0] = m_moves[m_currentMoves].newOwnerType[0];

  00082	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00085	6b 42 04 38	 imul	 eax, DWORD PTR [edx+4], 56
  00089	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  00090	b8 04 00 00 00	 mov	 eax, 4
  00095	6b c8 00	 imul	 ecx, eax, 0
  00098	b8 04 00 00 00	 mov	 eax, 4
  0009d	6b c0 00	 imul	 eax, eax, 0
  000a0	8b 4c 0a 24	 mov	 ecx, DWORD PTR [edx+ecx+36]
  000a4	89 4c 05 d8	 mov	 DWORD PTR _move$[ebp+eax+28], ecx

; 176  :   move.oldOwnerType[1] = m_moves[m_currentMoves].newOwnerType[1];

  000a8	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ab	6b 42 04 38	 imul	 eax, DWORD PTR [edx+4], 56
  000af	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  000b6	b8 04 00 00 00	 mov	 eax, 4
  000bb	c1 e0 00	 shl	 eax, 0
  000be	b9 04 00 00 00	 mov	 ecx, 4
  000c3	c1 e1 00	 shl	 ecx, 0
  000c6	8b 54 02 24	 mov	 edx, DWORD PTR [edx+eax+36]
  000ca	89 54 0d d8	 mov	 DWORD PTR _move$[ebp+ecx+28], edx

; 177  :   move.newOwnerType[0] = m_moves[m_currentMoves].oldOwnerType[0];

  000ce	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d1	6b 48 04 38	 imul	 ecx, DWORD PTR [eax+4], 56
  000d5	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000d8	8d 44 0a 08	 lea	 eax, DWORD PTR [edx+ecx+8]
  000dc	b9 04 00 00 00	 mov	 ecx, 4
  000e1	6b d1 00	 imul	 edx, ecx, 0
  000e4	b9 04 00 00 00	 mov	 ecx, 4
  000e9	6b c9 00	 imul	 ecx, ecx, 0
  000ec	8b 54 10 1c	 mov	 edx, DWORD PTR [eax+edx+28]
  000f0	89 54 0d e0	 mov	 DWORD PTR _move$[ebp+ecx+36], edx

; 178  :   move.newOwnerType[1] = m_moves[m_currentMoves].oldOwnerType[1];

  000f4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f7	6b 48 04 38	 imul	 ecx, DWORD PTR [eax+4], 56
  000fb	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000fe	8d 44 0a 08	 lea	 eax, DWORD PTR [edx+ecx+8]
  00102	b9 04 00 00 00	 mov	 ecx, 4
  00107	c1 e1 00	 shl	 ecx, 0
  0010a	ba 04 00 00 00	 mov	 edx, 4
  0010f	c1 e2 00	 shl	 edx, 0
  00112	8b 44 08 1c	 mov	 eax, DWORD PTR [eax+ecx+28]
  00116	89 44 15 e0	 mov	 DWORD PTR _move$[ebp+edx+36], eax

; 179  :   return move;

  0011a	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  0011f	8d 75 bc	 lea	 esi, DWORD PTR _move$[ebp]
  00122	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00125	f3 a5		 rep movsd
  00127	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 180  : }

  0012a	52		 push	 edx
  0012b	8b cd		 mov	 ecx, ebp
  0012d	50		 push	 eax
  0012e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@GetUndoMov
  00134	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00139	58		 pop	 eax
  0013a	5a		 pop	 edx
  0013b	5f		 pop	 edi
  0013c	5e		 pop	 esi
  0013d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00140	33 cd		 xor	 ecx, ebp
  00142	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00147	83 c4 5c	 add	 esp, 92			; 0000005cH
  0014a	3b ec		 cmp	 ebp, esp
  0014c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c2 04 00	 ret	 4
  00157	90		 npad	 1
$LN6@GetUndoMov:
  00158	02 00 00 00	 DD	 2
  0015c	00 00 00 00	 DD	 $LN5@GetUndoMov
$LN5@GetUndoMov:
  00160	bc ff ff ff	 DD	 -68			; ffffffbcH
  00164	38 00 00 00	 DD	 56			; 00000038H
  00168	00 00 00 00	 DD	 $LN3@GetUndoMov
  0016c	ac ff ff ff	 DD	 -84			; ffffffacH
  00170	08 00 00 00	 DD	 8
  00174	00 00 00 00	 DD	 $LN4@GetUndoMov
$LN4@GetUndoMov:
  00178	73		 DB	 115			; 00000073H
  00179	69		 DB	 105			; 00000069H
  0017a	7a		 DB	 122			; 0000007aH
  0017b	65		 DB	 101			; 00000065H
  0017c	00		 DB	 0
$LN3@GetUndoMov:
  0017d	6d		 DB	 109			; 0000006dH
  0017e	6f		 DB	 111			; 0000006fH
  0017f	76		 DB	 118			; 00000076H
  00180	65		 DB	 101			; 00000065H
  00181	00		 DB	 0
?GetUndoMove@MOVE_HISTORY@@QAE?AUMOVE@@XZ ENDP		; MOVE_HISTORY::GetUndoMove
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\BoxDef.h
;	COMDAT ?IsRedoPossible@MOVE_HISTORY@@QAE_NXZ
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?IsRedoPossible@MOVE_HISTORY@@QAE_NXZ PROC		; MOVE_HISTORY::IsRedoPossible, COMDAT
; _this$ = ecx

; 107  :   bool IsRedoPossible(void){return m_currentMoves < m_totalMoves;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00012	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00014	7d 09		 jge	 SHORT $LN3@IsRedoPoss
  00016	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  0001d	eb 07		 jmp	 SHORT $LN4@IsRedoPoss
$LN3@IsRedoPoss:
  0001f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN4@IsRedoPoss:
  00026	0f b6 45 f8	 movzx	 eax, BYTE PTR tv67[ebp]
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?IsRedoPossible@MOVE_HISTORY@@QAE_NXZ ENDP		; MOVE_HISTORY::IsRedoPossible
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\BoxDef.h
;	COMDAT ?IsUndoPossible@MOVE_HISTORY@@QAE_NXZ
_TEXT	SEGMENT
tv66 = -8						; size = 4
_this$ = -4						; size = 4
?IsUndoPossible@MOVE_HISTORY@@QAE_NXZ PROC		; MOVE_HISTORY::IsUndoPossible, COMDAT
; _this$ = ecx

; 106  :   bool IsUndoPossible(void){return m_currentMoves>0;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	7e 09		 jle	 SHORT $LN3@IsUndoPoss
  00012	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00019	eb 07		 jmp	 SHORT $LN4@IsUndoPoss
$LN3@IsUndoPoss:
  0001b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@IsUndoPoss:
  00022	0f b6 45 f8	 movzx	 eax, BYTE PTR tv66[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?IsUndoPossible@MOVE_HISTORY@@QAE_NXZ ENDP		; MOVE_HISTORY::IsUndoPossible
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0MOVE@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0MOVE@@QAE@XZ PROC					; MOVE::MOVE, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0VECTOR@@QAE@XZ	; VECTOR::VECTOR
  00016	68 00 00 00 00	 push	 OFFSET ??0VECTOR@@QAE@XZ ; VECTOR::VECTOR
  0001b	6a 02		 push	 2
  0001d	6a 08		 push	 8
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	83 c0 0c	 add	 eax, 12			; 0000000cH
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ??_H@YGXPAXIIP6EPAX0@Z@Z
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 c4 04	 add	 esp, 4
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??0MOVE@@QAE@XZ ENDP					; MOVE::MOVE
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\MoveHistory.cpp
_TEXT	SEGMENT
tv65 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?TypeName@MOVE@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ PROC ; MOVE::TypeName
; _this$ = ecx

; 126  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 127  :   switch (moveType)

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0002c	89 4d f4	 mov	 DWORD PTR tv65[ebp], ecx
  0002f	83 7d f4 16	 cmp	 DWORD PTR tv65[ebp], 22	; 00000016H
  00033	0f 87 99 03 00
	00		 ja	 $LN27@TypeName
  00039	8b 55 f4	 mov	 edx, DWORD PTR tv65[ebp]
  0003c	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN31@TypeName[edx*4]
$LN4@TypeName:

; 128  :   {
; 129  :   case MT_NONE:                 return   CString("None");

  00043	8b f4		 mov	 esi, esp
  00045	68 00 00 00 00	 push	 OFFSET $SG226358
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00053	3b f4		 cmp	 esi, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  0005d	83 c8 01	 or	 eax, 1
  00060	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00063	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00066	e9 8a 03 00 00	 jmp	 $LN1@TypeName
$LN5@TypeName:

; 130  :   case MT_RANDOM:               return   CString("Random");

  0006b	8b f4		 mov	 esi, esp
  0006d	68 00 00 00 00	 push	 OFFSET $SG226360
  00072	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0007b	3b f4		 cmp	 esi, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00085	83 c9 01	 or	 ecx, 1
  00088	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0008e	e9 62 03 00 00	 jmp	 $LN1@TypeName
$LN6@TypeName:

; 131  :   case MT_OBVIOUSCAPTURE:       return   CString("Obvious Capture");

  00093	8b f4		 mov	 esi, esp
  00095	68 00 00 00 00	 push	 OFFSET $SG226362
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  000a3	3b f4		 cmp	 esi, esp
  000a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000aa	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  000ad	83 ca 01	 or	 edx, 1
  000b0	89 55 f8	 mov	 DWORD PTR $T1[ebp], edx
  000b3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b6	e9 3a 03 00 00	 jmp	 $LN1@TypeName
$LN7@TypeName:

; 132  :   case MT_GIVENOTHING:          return   CString("Give Nothing");

  000bb	8b f4		 mov	 esi, esp
  000bd	68 00 00 00 00	 push	 OFFSET $SG226364
  000c2	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  000cb	3b f4		 cmp	 esi, esp
  000cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d2	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  000d5	83 c8 01	 or	 eax, 1
  000d8	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  000db	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000de	e9 12 03 00 00	 jmp	 $LN1@TypeName
$LN8@TypeName:

; 133  :   case MT_BREAKLOOPS:           return   CString("Break Loops");

  000e3	8b f4		 mov	 esi, esp
  000e5	68 00 00 00 00	 push	 OFFSET $SG226366
  000ea	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  000f3	3b f4		 cmp	 esi, esp
  000f5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fa	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  000fd	83 c9 01	 or	 ecx, 1
  00100	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
  00103	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00106	e9 ea 02 00 00	 jmp	 $LN1@TypeName
$LN9@TypeName:

; 134  :   case MT_LOOPDIVIDE:           return   CString("Break Divide");

  0010b	8b f4		 mov	 esi, esp
  0010d	68 00 00 00 00	 push	 OFFSET $SG226368
  00112	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00115	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0011b	3b f4		 cmp	 esi, esp
  0011d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00122	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  00125	83 ca 01	 or	 edx, 1
  00128	89 55 f8	 mov	 DWORD PTR $T1[ebp], edx
  0012b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0012e	e9 c2 02 00 00	 jmp	 $LN1@TypeName
$LN10@TypeName:

; 135  :   case MT_DIVIDE:               return   CString("Divide and Conquer");

  00133	8b f4		 mov	 esi, esp
  00135	68 00 00 00 00	 push	 OFFSET $SG226370
  0013a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0013d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00143	3b f4		 cmp	 esi, esp
  00145	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014a	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  0014d	83 c8 01	 or	 eax, 1
  00150	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00153	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00156	e9 9a 02 00 00	 jmp	 $LN1@TypeName
$LN11@TypeName:

; 136  :   case MT_GIVELITTLE:           return   CString("Give Little");

  0015b	8b f4		 mov	 esi, esp
  0015d	68 00 00 00 00	 push	 OFFSET $SG226372
  00162	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00165	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0016b	3b f4		 cmp	 esi, esp
  0016d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00172	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00175	83 c9 01	 or	 ecx, 1
  00178	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
  0017b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0017e	e9 72 02 00 00	 jmp	 $LN1@TypeName
$LN12@TypeName:

; 137  :   case MT_GRABANYTHING:         return   CString("Grab Anything");

  00183	8b f4		 mov	 esi, esp
  00185	68 00 00 00 00	 push	 OFFSET $SG226374
  0018a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0018d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00193	3b f4		 cmp	 esi, esp
  00195	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0019a	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  0019d	83 ca 01	 or	 edx, 1
  001a0	89 55 f8	 mov	 DWORD PTR $T1[ebp], edx
  001a3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001a6	e9 4a 02 00 00	 jmp	 $LN1@TypeName
$LN13@TypeName:

; 138  :   case MT_SIMPLEWIN:            return   CString("SimpleWin");

  001ab	8b f4		 mov	 esi, esp
  001ad	68 00 00 00 00	 push	 OFFSET $SG226376
  001b2	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  001b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  001bb	3b f4		 cmp	 esi, esp
  001bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c2	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  001c5	83 c8 01	 or	 eax, 1
  001c8	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  001cb	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001ce	e9 22 02 00 00	 jmp	 $LN1@TypeName
$LN14@TypeName:

; 139  :   case MT_SIMPLETIE:            return   CString("SimpleTie");

  001d3	8b f4		 mov	 esi, esp
  001d5	68 00 00 00 00	 push	 OFFSET $SG226378
  001da	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  001dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  001e3	3b f4		 cmp	 esi, esp
  001e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ea	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  001ed	83 c9 01	 or	 ecx, 1
  001f0	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
  001f3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001f6	e9 fa 01 00 00	 jmp	 $LN1@TypeName
$LN15@TypeName:

; 140  :   case MT_EDIT:                 return   CString("Edit");

  001fb	8b f4		 mov	 esi, esp
  001fd	68 00 00 00 00	 push	 OFFSET $SG226380
  00202	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00205	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0020b	3b f4		 cmp	 esi, esp
  0020d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00212	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  00215	83 ca 01	 or	 edx, 1
  00218	89 55 f8	 mov	 DWORD PTR $T1[ebp], edx
  0021b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0021e	e9 d2 01 00 00	 jmp	 $LN1@TypeName
$LN16@TypeName:

; 141  :   case MT_SIMPLEWINCAPTURE:     return   CString("Simple Win Capture");

  00223	8b f4		 mov	 esi, esp
  00225	68 00 00 00 00	 push	 OFFSET $SG226382
  0022a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0022d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00233	3b f4		 cmp	 esi, esp
  00235	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0023a	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  0023d	83 c8 01	 or	 eax, 1
  00240	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00243	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00246	e9 aa 01 00 00	 jmp	 $LN1@TypeName
$LN17@TypeName:

; 142  :   case MT_NIMVALCAPTURE:        return   CString("Nimval Capture");

  0024b	8b f4		 mov	 esi, esp
  0024d	68 00 00 00 00	 push	 OFFSET $SG226384
  00252	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00255	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0025b	3b f4		 cmp	 esi, esp
  0025d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00262	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00265	83 c9 01	 or	 ecx, 1
  00268	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
  0026b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0026e	e9 82 01 00 00	 jmp	 $LN1@TypeName
$LN18@TypeName:

; 143  :   case MT_NIMVALDECLINE:        return   CString("Nimval Decline");

  00273	8b f4		 mov	 esi, esp
  00275	68 00 00 00 00	 push	 OFFSET $SG226386
  0027a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0027d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00283	3b f4		 cmp	 esi, esp
  00285	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0028a	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  0028d	83 ca 01	 or	 edx, 1
  00290	89 55 f8	 mov	 DWORD PTR $T1[ebp], edx
  00293	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00296	e9 5a 01 00 00	 jmp	 $LN1@TypeName
$LN19@TypeName:

; 144  :   case MT_MAXCAPTURE:           return   CString("Maximize Capture");

  0029b	8b f4		 mov	 esi, esp
  0029d	68 00 00 00 00	 push	 OFFSET $SG226388
  002a2	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  002a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  002ab	3b f4		 cmp	 esi, esp
  002ad	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002b2	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  002b5	83 c8 01	 or	 eax, 1
  002b8	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  002bb	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002be	e9 32 01 00 00	 jmp	 $LN1@TypeName
$LN20@TypeName:

; 145  :   case MT_MAXDECLINE:           return   CString("Maximize Decline");

  002c3	8b f4		 mov	 esi, esp
  002c5	68 00 00 00 00	 push	 OFFSET $SG226390
  002ca	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  002cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  002d3	3b f4		 cmp	 esi, esp
  002d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002da	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  002dd	83 c9 01	 or	 ecx, 1
  002e0	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
  002e3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002e6	e9 0a 01 00 00	 jmp	 $LN1@TypeName
$LN21@TypeName:

; 146  :   case MT_SIMPLEWINDECLINE:     return   CString("Simple Win Decline");

  002eb	8b f4		 mov	 esi, esp
  002ed	68 00 00 00 00	 push	 OFFSET $SG226392
  002f2	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  002f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  002fb	3b f4		 cmp	 esi, esp
  002fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00302	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  00305	83 ca 01	 or	 edx, 1
  00308	89 55 f8	 mov	 DWORD PTR $T1[ebp], edx
  0030b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0030e	e9 e2 00 00 00	 jmp	 $LN1@TypeName
$LN22@TypeName:

; 147  :   case MT_VERIFYNIMSTRINGVALUE: return   CString("Verify Nimstring Value");

  00313	8b f4		 mov	 esi, esp
  00315	68 00 00 00 00	 push	 OFFSET $SG226394
  0031a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0031d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00323	3b f4		 cmp	 esi, esp
  00325	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0032a	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  0032d	83 c8 01	 or	 eax, 1
  00330	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00333	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00336	e9 ba 00 00 00	 jmp	 $LN1@TypeName
$LN23@TypeName:

; 148  :   case MT_NIMVAL:               return   CString("Nimstring value = 0");

  0033b	8b f4		 mov	 esi, esp
  0033d	68 00 00 00 00	 push	 OFFSET $SG226396
  00342	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00345	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0034b	3b f4		 cmp	 esi, esp
  0034d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00352	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00355	83 c9 01	 or	 ecx, 1
  00358	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
  0035b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0035e	e9 92 00 00 00	 jmp	 $LN1@TypeName
$LN24@TypeName:

; 149  :   case MT_NONIMVAL:             return   CString("Nimstring value != 0");

  00363	8b f4		 mov	 esi, esp
  00365	68 00 00 00 00	 push	 OFFSET $SG226398
  0036a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0036d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00373	3b f4		 cmp	 esi, esp
  00375	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0037a	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  0037d	83 ca 01	 or	 edx, 1
  00380	89 55 f8	 mov	 DWORD PTR $T1[ebp], edx
  00383	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00386	eb 6d		 jmp	 SHORT $LN1@TypeName
$LN25@TypeName:

; 150  :   case MT_OPENINGTIE:           return   CString("Opening book tie");

  00388	8b f4		 mov	 esi, esp
  0038a	68 00 00 00 00	 push	 OFFSET $SG226400
  0038f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00392	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00398	3b f4		 cmp	 esi, esp
  0039a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0039f	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  003a2	83 c8 01	 or	 eax, 1
  003a5	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  003a8	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  003ab	eb 48		 jmp	 SHORT $LN1@TypeName
$LN26@TypeName:

; 151  :   case MT_OPENINGWIN:           return   CString("Opening book win");

  003ad	8b f4		 mov	 esi, esp
  003af	68 00 00 00 00	 push	 OFFSET $SG226402
  003b4	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  003b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  003bd	3b f4		 cmp	 esi, esp
  003bf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003c4	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  003c7	83 c9 01	 or	 ecx, 1
  003ca	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
  003cd	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  003d0	eb 23		 jmp	 SHORT $LN1@TypeName
$LN27@TypeName:

; 152  :   default:                      return   CString("Illegal");

  003d2	8b f4		 mov	 esi, esp
  003d4	68 00 00 00 00	 push	 OFFSET $SG226404
  003d9	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  003dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  003e2	3b f4		 cmp	 esi, esp
  003e4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003e9	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  003ec	83 ca 01	 or	 edx, 1
  003ef	89 55 f8	 mov	 DWORD PTR $T1[ebp], edx
  003f2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@TypeName:

; 153  :   };
; 154  : }

  003f5	5e		 pop	 esi
  003f6	83 c4 0c	 add	 esp, 12			; 0000000cH
  003f9	3b ec		 cmp	 ebp, esp
  003fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00400	8b e5		 mov	 esp, ebp
  00402	5d		 pop	 ebp
  00403	c2 04 00	 ret	 4
  00406	66 90		 npad	 2
$LN31@TypeName:
  00408	00 00 00 00	 DD	 $LN4@TypeName
  0040c	00 00 00 00	 DD	 $LN5@TypeName
  00410	00 00 00 00	 DD	 $LN6@TypeName
  00414	00 00 00 00	 DD	 $LN7@TypeName
  00418	00 00 00 00	 DD	 $LN8@TypeName
  0041c	00 00 00 00	 DD	 $LN9@TypeName
  00420	00 00 00 00	 DD	 $LN10@TypeName
  00424	00 00 00 00	 DD	 $LN11@TypeName
  00428	00 00 00 00	 DD	 $LN12@TypeName
  0042c	00 00 00 00	 DD	 $LN13@TypeName
  00430	00 00 00 00	 DD	 $LN14@TypeName
  00434	00 00 00 00	 DD	 $LN16@TypeName
  00438	00 00 00 00	 DD	 $LN21@TypeName
  0043c	00 00 00 00	 DD	 $LN23@TypeName
  00440	00 00 00 00	 DD	 $LN24@TypeName
  00444	00 00 00 00	 DD	 $LN15@TypeName
  00448	00 00 00 00	 DD	 $LN22@TypeName
  0044c	00 00 00 00	 DD	 $LN26@TypeName
  00450	00 00 00 00	 DD	 $LN25@TypeName
  00454	00 00 00 00	 DD	 $LN20@TypeName
  00458	00 00 00 00	 DD	 $LN19@TypeName
  0045c	00 00 00 00	 DD	 $LN17@TypeName
  00460	00 00 00 00	 DD	 $LN18@TypeName
?TypeName@MOVE@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ENDP ; MOVE::TypeName
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\MoveHistory.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 8
_size$ = -16						; size = 8
_this$ = -4						; size = 4
_lineNum$ = 8						; size = 4
?ConstructFromLineNumber@MOVE@@QAEXH@Z PROC		; MOVE::ConstructFromLineNumber
; _this$ = ecx

; 109  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 110  :   VECTOR size;

  00023	8d 4d f0	 lea	 ecx, DWORD PTR _size$[ebp]
  00026	e8 00 00 00 00	 call	 ??0VECTOR@@QAE@XZ	; VECTOR::VECTOR

; 111  :   size = pDoc->GameSize();

  0002b	8d 45 e4	 lea	 eax, DWORD PTR $T1[ebp]
  0002e	50		 push	 eax
  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pDoc@@3PAVCNewBoxesDoc@@A ; pDoc
  00035	e8 00 00 00 00	 call	 ?GameSize@CNewBoxesDoc@@QAE?AUtagPOINT@@XZ ; CNewBoxesDoc::GameSize
  0003a	50		 push	 eax
  0003b	8d 4d f0	 lea	 ecx, DWORD PTR _size$[ebp]
  0003e	e8 00 00 00 00	 call	 ??4VECTOR@@QAEAAV0@ABUtagPOINT@@@Z ; VECTOR::operator=

; 112  :   this->dotNum.y = lineNum/(2 * size.x - 1);

  00043	8b 4d f0	 mov	 ecx, DWORD PTR _size$[ebp]
  00046	8d 4c 09 ff	 lea	 ecx, DWORD PTR [ecx+ecx-1]
  0004a	8b 45 08	 mov	 eax, DWORD PTR _lineNum$[ebp]
  0004d	99		 cdq
  0004e	f7 f9		 idiv	 ecx
  00050	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00053	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 113  :   dotNum.x = lineNum%(2 * size.x - 1);

  00056	8b 45 f0	 mov	 eax, DWORD PTR _size$[ebp]
  00059	8d 4c 00 ff	 lea	 ecx, DWORD PTR [eax+eax-1]
  0005d	8b 45 08	 mov	 eax, DWORD PTR _lineNum$[ebp]
  00060	99		 cdq
  00061	f7 f9		 idiv	 ecx
  00063	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00066	89 10		 mov	 DWORD PTR [eax], edx

; 114  :   if (dotNum.x >= size.x - 1)

  00068	8b 4d f0	 mov	 ecx, DWORD PTR _size$[ebp]
  0006b	83 e9 01	 sub	 ecx, 1
  0006e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00071	39 0a		 cmp	 DWORD PTR [edx], ecx
  00073	7c 1b		 jl	 SHORT $LN2@ConstructF

; 115  :   {
; 116  :     dotNum.x -= size.x - 1;

  00075	8b 45 f0	 mov	 eax, DWORD PTR _size$[ebp]
  00078	83 e8 01	 sub	 eax, 1
  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00080	2b d0		 sub	 edx, eax
  00082	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00085	89 10		 mov	 DWORD PTR [eax], edx

; 117  :     vertical = true;

  00087	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	c6 41 08 01	 mov	 BYTE PTR [ecx+8], 1

; 118  :   }

  0008e	eb 07		 jmp	 SHORT $LN1@ConstructF
$LN2@ConstructF:

; 119  :   else
; 120  :   {
; 121  :     vertical = false;

  00090	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00093	c6 42 08 00	 mov	 BYTE PTR [edx+8], 0
$LN1@ConstructF:

; 122  :   };
; 123  : }

  00097	52		 push	 edx
  00098	8b cd		 mov	 ecx, ebp
  0009a	50		 push	 eax
  0009b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@ConstructF
  000a1	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000a6	58		 pop	 eax
  000a7	5a		 pop	 edx
  000a8	83 c4 1c	 add	 esp, 28			; 0000001cH
  000ab	3b ec		 cmp	 ebp, esp
  000ad	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c2 04 00	 ret	 4
$LN7@ConstructF:
  000b8	01 00 00 00	 DD	 1
  000bc	00 00 00 00	 DD	 $LN6@ConstructF
$LN6@ConstructF:
  000c0	f0 ff ff ff	 DD	 -16			; fffffff0H
  000c4	08 00 00 00	 DD	 8
  000c8	00 00 00 00	 DD	 $LN5@ConstructF
$LN5@ConstructF:
  000cc	73		 DB	 115			; 00000073H
  000cd	69		 DB	 105			; 00000069H
  000ce	7a		 DB	 122			; 0000007aH
  000cf	65		 DB	 101			; 00000065H
  000d0	00		 DB	 0
?ConstructFromLineNumber@MOVE@@QAEXH@Z ENDP		; MOVE::ConstructFromLineNumber
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\MoveHistory.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pGame$ = 8						; size = 4
?SetCaptures@MOVE@@QAEXPAVDOTS_AND_BOXES@@@Z PROC	; MOVE::SetCaptures
; _this$ = ecx

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 12   :   if (vertical)

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  00015	85 c9		 test	 ecx, ecx
  00017	74 15		 je	 SHORT $LN2@SetCapture

; 13   :   {
; 14   :     pGame->SetVLineType(dotNum, newLineType);

  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0001f	50		 push	 eax
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  00027	e8 00 00 00 00	 call	 ?SetVLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetVLineType

; 15   :   }

  0002c	eb 13		 jmp	 SHORT $LN3@SetCapture
$LN2@SetCapture:

; 16   :   else
; 17   :   {
; 18   :     pGame->SetHLineType(dotNum, newLineType);

  0002e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00031	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00034	50		 push	 eax
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	51		 push	 ecx
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  0003c	e8 00 00 00 00	 call	 ?SetHLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetHLineType
$LN3@SetCapture:

; 19   :   };
; 20   :   if (boxesCaptured[0].x >= 0) pGame->SetBoxOwner(boxesCaptured[0], newOwnerType[0]);

  00041	ba 08 00 00 00	 mov	 edx, 8
  00046	6b c2 00	 imul	 eax, edx, 0
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	83 7c 01 0c 00	 cmp	 DWORD PTR [ecx+eax+12], 0
  00051	7c 28		 jl	 SHORT $LN4@SetCapture
  00053	ba 04 00 00 00	 mov	 edx, 4
  00058	6b c2 00	 imul	 eax, edx, 0
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	8b 54 01 24	 mov	 edx, DWORD PTR [ecx+eax+36]
  00062	52		 push	 edx
  00063	b8 08 00 00 00	 mov	 eax, 8
  00068	6b c8 00	 imul	 ecx, eax, 0
  0006b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006e	8d 44 0a 0c	 lea	 eax, DWORD PTR [edx+ecx+12]
  00072	50		 push	 eax
  00073	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  00076	e8 00 00 00 00	 call	 ?SetBoxOwner@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4OWNER_TYPE@@@Z ; DOTS_AND_BOXES::SetBoxOwner
$LN4@SetCapture:

; 21   :   if (boxesCaptured[1].x >= 0) pGame->SetBoxOwner(boxesCaptured[1], newOwnerType[1]);

  0007b	b9 08 00 00 00	 mov	 ecx, 8
  00080	c1 e1 00	 shl	 ecx, 0
  00083	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00086	83 7c 0a 0c 00	 cmp	 DWORD PTR [edx+ecx+12], 0
  0008b	7c 28		 jl	 SHORT $LN1@SetCapture
  0008d	b8 04 00 00 00	 mov	 eax, 4
  00092	c1 e0 00	 shl	 eax, 0
  00095	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	8b 54 01 24	 mov	 edx, DWORD PTR [ecx+eax+36]
  0009c	52		 push	 edx
  0009d	b8 08 00 00 00	 mov	 eax, 8
  000a2	c1 e0 00	 shl	 eax, 0
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	8d 54 01 0c	 lea	 edx, DWORD PTR [ecx+eax+12]
  000ac	52		 push	 edx
  000ad	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  000b0	e8 00 00 00 00	 call	 ?SetBoxOwner@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4OWNER_TYPE@@@Z ; DOTS_AND_BOXES::SetBoxOwner
$LN1@SetCapture:

; 22   : }

  000b5	83 c4 04	 add	 esp, 4
  000b8	3b ec		 cmp	 ebp, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c2 04 00	 ret	 4
?SetCaptures@MOVE@@QAEXPAVDOTS_AND_BOXES@@@Z ENDP	; MOVE::SetCaptures
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\MoveHistory.cpp
_TEXT	SEGMENT
$T1 = -156						; size = 8
$T2 = -148						; size = 8
$T3 = -140						; size = 8
$T4 = -132						; size = 8
$T5 = -124						; size = 8
$T6 = -116						; size = 8
$T7 = -108						; size = 8
$T8 = -100						; size = 8
$T9 = -92						; size = 8
$T10 = -84						; size = 8
$T11 = -76						; size = 8
$T12 = -68						; size = 8
$T13 = -60						; size = 8
$T14 = -52						; size = 8
_dotAbove$15 = -40					; size = 8
_dotLeft$16 = -24					; size = 8
_newNumLine$ = -12					; size = 4
_oldNumLine$ = -8					; size = 4
_this$ = -4						; size = 4
_pGame$ = 8						; size = 4
?FindCaptures@MOVE@@QAEXPAVDOTS_AND_BOXES@@@Z PROC	; MOVE::FindCaptures
; _this$ = ecx

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 9c 00 00
	00		 sub	 esp, 156		; 0000009cH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	51		 push	 ecx
  0000c	8d bd 64 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-156]
  00012	b9 27 00 00 00	 mov	 ecx, 39			; 00000027H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	59		 pop	 ecx
  0001f	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 26   :   int oldNumLine, newNumLine;
; 27   :   boxesCaptured[0].y = boxesCaptured[0].x = -1;

  00022	b8 08 00 00 00	 mov	 eax, 8
  00027	6b c8 00	 imul	 ecx, eax, 0
  0002a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	c7 44 0a 0c ff
	ff ff ff	 mov	 DWORD PTR [edx+ecx+12], -1
  00035	b8 08 00 00 00	 mov	 eax, 8
  0003a	6b c8 00	 imul	 ecx, eax, 0
  0003d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00040	c7 44 0a 10 ff
	ff ff ff	 mov	 DWORD PTR [edx+ecx+16], -1

; 28   :   boxesCaptured[1].y = boxesCaptured[1].x = -1;

  00048	b8 08 00 00 00	 mov	 eax, 8
  0004d	c1 e0 00	 shl	 eax, 0
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	c7 44 01 0c ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax+12], -1
  0005b	ba 08 00 00 00	 mov	 edx, 8
  00060	c1 e2 00	 shl	 edx, 0
  00063	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00066	c7 44 10 10 ff
	ff ff ff	 mov	 DWORD PTR [eax+edx+16], -1

; 29   :   if (vertical)

  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	0f b6 51 08	 movzx	 edx, BYTE PTR [ecx+8]
  00075	85 d2		 test	 edx, edx
  00077	0f 84 af 02 00
	00		 je	 $LN2@FindCaptur

; 30   :   {
; 31   :     VECTOR dotLeft;

  0007d	8d 4d e8	 lea	 ecx, DWORD PTR _dotLeft$16[ebp]
  00080	e8 00 00 00 00	 call	 ??0VECTOR@@QAE@XZ	; VECTOR::VECTOR

; 32   :     if (dotNum.x > 0) //check box left

  00085	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00088	83 38 00	 cmp	 DWORD PTR [eax], 0
  0008b	0f 8e 4c 01 00
	00		 jle	 $LN4@FindCaptur

; 33   :     {
; 34   :       dotLeft = dotNum + VECTOR(-1,0);

  00091	6a 00		 push	 0
  00093	6a ff		 push	 -1
  00095	8d 4d cc	 lea	 ecx, DWORD PTR $T14[ebp]
  00098	e8 00 00 00 00	 call	 ??0VECTOR@@QAE@HH@Z	; VECTOR::VECTOR
  0009d	50		 push	 eax
  0009e	8d 4d c4	 lea	 ecx, DWORD PTR $T13[ebp]
  000a1	51		 push	 ecx
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ??HVECTOR@@QAE?AV0@ABV0@@Z ; VECTOR::operator+
  000aa	8b 10		 mov	 edx, DWORD PTR [eax]
  000ac	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000af	89 55 e8	 mov	 DWORD PTR _dotLeft$16[ebp], edx
  000b2	89 45 ec	 mov	 DWORD PTR _dotLeft$16[ebp+4], eax

; 35   :       oldOwnerType[0] = pGame->BoxOwner(dotLeft);

  000b5	8d 4d e8	 lea	 ecx, DWORD PTR _dotLeft$16[ebp]
  000b8	51		 push	 ecx
  000b9	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  000bc	e8 00 00 00 00	 call	 ?BoxOwner@DOTS_AND_BOXES@@QBE?AW4OWNER_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::BoxOwner
  000c1	ba 04 00 00 00	 mov	 edx, 4
  000c6	6b ca 00	 imul	 ecx, edx, 0
  000c9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000cc	89 44 0a 1c	 mov	 DWORD PTR [edx+ecx+28], eax

; 36   :       newOwnerType[0] = oldOwnerType[0];

  000d0	b8 04 00 00 00	 mov	 eax, 4
  000d5	6b c8 00	 imul	 ecx, eax, 0
  000d8	ba 04 00 00 00	 mov	 edx, 4
  000dd	6b c2 00	 imul	 eax, edx, 0
  000e0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000e3	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  000e6	8b 4c 0e 1c	 mov	 ecx, DWORD PTR [esi+ecx+28]
  000ea	89 4c 02 24	 mov	 DWORD PTR [edx+eax+36], ecx

; 37   :       pGame->SetVLineType(dotNum, oldLineType);

  000ee	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f1	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  000f4	50		 push	 eax
  000f5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f8	51		 push	 ecx
  000f9	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  000fc	e8 00 00 00 00	 call	 ?SetVLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetVLineType

; 38   :       oldNumLine = pGame->CountLines(dotLeft);

  00101	8b 55 e8	 mov	 edx, DWORD PTR _dotLeft$16[ebp]
  00104	8b 45 ec	 mov	 eax, DWORD PTR _dotLeft$16[ebp+4]
  00107	89 55 bc	 mov	 DWORD PTR $T12[ebp], edx
  0010a	89 45 c0	 mov	 DWORD PTR $T12[ebp+4], eax
  0010d	8b 4d c0	 mov	 ecx, DWORD PTR $T12[ebp+4]
  00110	51		 push	 ecx
  00111	8b 55 bc	 mov	 edx, DWORD PTR $T12[ebp]
  00114	52		 push	 edx
  00115	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  00118	e8 00 00 00 00	 call	 ?CountLines@DOTS_AND_BOXES@@QBEHUtagPOINT@@@Z ; DOTS_AND_BOXES::CountLines
  0011d	89 45 f8	 mov	 DWORD PTR _oldNumLine$[ebp], eax

; 39   :       pGame->SetVLineType(dotNum, newLineType);

  00120	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00123	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00126	51		 push	 ecx
  00127	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0012a	52		 push	 edx
  0012b	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  0012e	e8 00 00 00 00	 call	 ?SetVLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetVLineType

; 40   :       newNumLine = pGame->CountLines(dotLeft);

  00133	8b 45 e8	 mov	 eax, DWORD PTR _dotLeft$16[ebp]
  00136	8b 4d ec	 mov	 ecx, DWORD PTR _dotLeft$16[ebp+4]
  00139	89 45 b4	 mov	 DWORD PTR $T11[ebp], eax
  0013c	89 4d b8	 mov	 DWORD PTR $T11[ebp+4], ecx
  0013f	8b 55 b8	 mov	 edx, DWORD PTR $T11[ebp+4]
  00142	52		 push	 edx
  00143	8b 45 b4	 mov	 eax, DWORD PTR $T11[ebp]
  00146	50		 push	 eax
  00147	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  0014a	e8 00 00 00 00	 call	 ?CountLines@DOTS_AND_BOXES@@QBEHUtagPOINT@@@Z ; DOTS_AND_BOXES::CountLines
  0014f	89 45 f4	 mov	 DWORD PTR _newNumLine$[ebp], eax

; 41   :       pGame->SetVLineType(dotNum, oldLineType);

  00152	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00155	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00158	52		 push	 edx
  00159	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0015c	50		 push	 eax
  0015d	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  00160	e8 00 00 00 00	 call	 ?SetVLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetVLineType

; 42   :       if (newNumLine < 4) newOwnerType[0] = OWNER_NONE;

  00165	83 7d f4 04	 cmp	 DWORD PTR _newNumLine$[ebp], 4
  00169	7d 15		 jge	 SHORT $LN5@FindCaptur
  0016b	b9 04 00 00 00	 mov	 ecx, 4
  00170	6b d1 00	 imul	 edx, ecx, 0
  00173	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00176	c7 44 10 24 00
	00 00 00	 mov	 DWORD PTR [eax+edx+36], 0
  0017e	eb 24		 jmp	 SHORT $LN6@FindCaptur
$LN5@FindCaptur:

; 43   :       else if (oldNumLine < 4) newOwnerType[0] = OwnerType(newLineType);

  00180	83 7d f8 04	 cmp	 DWORD PTR _oldNumLine$[ebp], 4
  00184	7d 1e		 jge	 SHORT $LN6@FindCaptur
  00186	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00189	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0018c	52		 push	 edx
  0018d	e8 00 00 00 00	 call	 ?OwnerType@@YA?AW4OWNER_TYPE@@W4LINE_TYPE@@@Z ; OwnerType
  00192	83 c4 04	 add	 esp, 4
  00195	b9 04 00 00 00	 mov	 ecx, 4
  0019a	6b d1 00	 imul	 edx, ecx, 0
  0019d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a0	89 44 11 24	 mov	 DWORD PTR [ecx+edx+36], eax
$LN6@FindCaptur:

; 44   :       if (oldOwnerType[0] != newOwnerType[0])

  001a4	ba 04 00 00 00	 mov	 edx, 4
  001a9	6b c2 00	 imul	 eax, edx, 0
  001ac	b9 04 00 00 00	 mov	 ecx, 4
  001b1	6b d1 00	 imul	 edx, ecx, 0
  001b4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b7	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  001ba	8b 44 01 1c	 mov	 eax, DWORD PTR [ecx+eax+28]
  001be	3b 44 16 24	 cmp	 eax, DWORD PTR [esi+edx+36]
  001c2	74 19		 je	 SHORT $LN4@FindCaptur

; 45   :       {
; 46   :         boxesCaptured[0] = dotLeft;

  001c4	b9 08 00 00 00	 mov	 ecx, 8
  001c9	6b d1 00	 imul	 edx, ecx, 0
  001cc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001cf	8b 4d e8	 mov	 ecx, DWORD PTR _dotLeft$16[ebp]
  001d2	8b 75 ec	 mov	 esi, DWORD PTR _dotLeft$16[ebp+4]
  001d5	89 4c 10 0c	 mov	 DWORD PTR [eax+edx+12], ecx
  001d9	89 74 10 10	 mov	 DWORD PTR [eax+edx+16], esi
$LN4@FindCaptur:

; 47   :       };
; 48   :     };
; 49   :     if (dotNum.x < pGame->Size().x - 1) //check box right

  001dd	8d 55 ac	 lea	 edx, DWORD PTR $T10[ebp]
  001e0	52		 push	 edx
  001e1	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  001e4	e8 00 00 00 00	 call	 ?Size@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ ; DOTS_AND_BOXES::Size
  001e9	8b 00		 mov	 eax, DWORD PTR [eax]
  001eb	83 e8 01	 sub	 eax, 1
  001ee	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001f1	39 01		 cmp	 DWORD PTR [ecx], eax
  001f3	0f 8d 2e 01 00
	00		 jge	 $LN9@FindCaptur

; 50   :     {
; 51   :       oldOwnerType[1] = pGame->BoxOwner(dotNum);

  001f9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001fc	52		 push	 edx
  001fd	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  00200	e8 00 00 00 00	 call	 ?BoxOwner@DOTS_AND_BOXES@@QBE?AW4OWNER_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::BoxOwner
  00205	b9 04 00 00 00	 mov	 ecx, 4
  0020a	c1 e1 00	 shl	 ecx, 0
  0020d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00210	89 44 0a 1c	 mov	 DWORD PTR [edx+ecx+28], eax

; 52   :       newOwnerType[1] = oldOwnerType[1];

  00214	b8 04 00 00 00	 mov	 eax, 4
  00219	c1 e0 00	 shl	 eax, 0
  0021c	b9 04 00 00 00	 mov	 ecx, 4
  00221	c1 e1 00	 shl	 ecx, 0
  00224	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00227	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  0022a	8b 44 06 1c	 mov	 eax, DWORD PTR [esi+eax+28]
  0022e	89 44 0a 24	 mov	 DWORD PTR [edx+ecx+36], eax

; 53   :       pGame->SetVLineType(dotNum, oldLineType);

  00232	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00235	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00238	52		 push	 edx
  00239	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0023c	50		 push	 eax
  0023d	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  00240	e8 00 00 00 00	 call	 ?SetVLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetVLineType

; 54   :       oldNumLine = pGame->CountLines(dotNum);

  00245	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00248	8b 11		 mov	 edx, DWORD PTR [ecx]
  0024a	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0024d	89 55 a4	 mov	 DWORD PTR $T9[ebp], edx
  00250	89 45 a8	 mov	 DWORD PTR $T9[ebp+4], eax
  00253	8b 4d a8	 mov	 ecx, DWORD PTR $T9[ebp+4]
  00256	51		 push	 ecx
  00257	8b 55 a4	 mov	 edx, DWORD PTR $T9[ebp]
  0025a	52		 push	 edx
  0025b	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  0025e	e8 00 00 00 00	 call	 ?CountLines@DOTS_AND_BOXES@@QBEHUtagPOINT@@@Z ; DOTS_AND_BOXES::CountLines
  00263	89 45 f8	 mov	 DWORD PTR _oldNumLine$[ebp], eax

; 55   :       //if (numLine == 4) oldOwnerType[1] = OwnerType(oldLineType);
; 56   :       pGame->SetVLineType(dotNum, newLineType);

  00266	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00269	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0026c	51		 push	 ecx
  0026d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00270	52		 push	 edx
  00271	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  00274	e8 00 00 00 00	 call	 ?SetVLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetVLineType

; 57   :       newNumLine = pGame->CountLines(dotNum);

  00279	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0027c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0027e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00281	89 4d 9c	 mov	 DWORD PTR $T8[ebp], ecx
  00284	89 55 a0	 mov	 DWORD PTR $T8[ebp+4], edx
  00287	8b 45 a0	 mov	 eax, DWORD PTR $T8[ebp+4]
  0028a	50		 push	 eax
  0028b	8b 4d 9c	 mov	 ecx, DWORD PTR $T8[ebp]
  0028e	51		 push	 ecx
  0028f	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  00292	e8 00 00 00 00	 call	 ?CountLines@DOTS_AND_BOXES@@QBEHUtagPOINT@@@Z ; DOTS_AND_BOXES::CountLines
  00297	89 45 f4	 mov	 DWORD PTR _newNumLine$[ebp], eax

; 58   :       pGame->SetVLineType(dotNum, oldLineType);

  0029a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0029d	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  002a0	50		 push	 eax
  002a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002a4	51		 push	 ecx
  002a5	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  002a8	e8 00 00 00 00	 call	 ?SetVLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetVLineType

; 59   :       if (newNumLine < 4) newOwnerType[1] = OWNER_NONE;

  002ad	83 7d f4 04	 cmp	 DWORD PTR _newNumLine$[ebp], 4
  002b1	7d 15		 jge	 SHORT $LN10@FindCaptur
  002b3	ba 04 00 00 00	 mov	 edx, 4
  002b8	c1 e2 00	 shl	 edx, 0
  002bb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002be	c7 44 10 24 00
	00 00 00	 mov	 DWORD PTR [eax+edx+36], 0
  002c6	eb 24		 jmp	 SHORT $LN11@FindCaptur
$LN10@FindCaptur:

; 60   :       else if (oldNumLine < 4) newOwnerType[1] = OwnerType(newLineType);

  002c8	83 7d f8 04	 cmp	 DWORD PTR _oldNumLine$[ebp], 4
  002cc	7d 1e		 jge	 SHORT $LN11@FindCaptur
  002ce	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d1	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  002d4	52		 push	 edx
  002d5	e8 00 00 00 00	 call	 ?OwnerType@@YA?AW4OWNER_TYPE@@W4LINE_TYPE@@@Z ; OwnerType
  002da	83 c4 04	 add	 esp, 4
  002dd	b9 04 00 00 00	 mov	 ecx, 4
  002e2	c1 e1 00	 shl	 ecx, 0
  002e5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002e8	89 44 0a 24	 mov	 DWORD PTR [edx+ecx+36], eax
$LN11@FindCaptur:

; 61   :       if (oldOwnerType[1] != newOwnerType[1])

  002ec	b8 04 00 00 00	 mov	 eax, 4
  002f1	c1 e0 00	 shl	 eax, 0
  002f4	b9 04 00 00 00	 mov	 ecx, 4
  002f9	c1 e1 00	 shl	 ecx, 0
  002fc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002ff	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00302	8b 44 02 1c	 mov	 eax, DWORD PTR [edx+eax+28]
  00306	3b 44 0e 24	 cmp	 eax, DWORD PTR [esi+ecx+36]
  0030a	74 1b		 je	 SHORT $LN9@FindCaptur

; 62   :       {
; 63   :         boxesCaptured[1] = dotNum;

  0030c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0030f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00311	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00314	b9 08 00 00 00	 mov	 ecx, 8
  00319	c1 e1 00	 shl	 ecx, 0
  0031c	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  0031f	89 54 0e 0c	 mov	 DWORD PTR [esi+ecx+12], edx
  00323	89 44 0e 10	 mov	 DWORD PTR [esi+ecx+16], eax
$LN9@FindCaptur:

; 64   :       };
; 65   :     };
; 66   :   }

  00327	e9 ce 02 00 00	 jmp	 $LN1@FindCaptur
$LN2@FindCaptur:

; 67   :   else
; 68   :   {
; 69   :     VECTOR dotAbove;

  0032c	8d 4d d8	 lea	 ecx, DWORD PTR _dotAbove$15[ebp]
  0032f	e8 00 00 00 00	 call	 ??0VECTOR@@QAE@XZ	; VECTOR::VECTOR

; 70   :     if (dotNum.y > 0) //check box above

  00334	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00337	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0033b	0f 8e 52 01 00
	00		 jle	 $LN14@FindCaptur

; 71   :     {
; 72   :       dotAbove = dotNum + VECTOR(0,-1);

  00341	6a ff		 push	 -1
  00343	6a 00		 push	 0
  00345	8d 4d 94	 lea	 ecx, DWORD PTR $T7[ebp]
  00348	e8 00 00 00 00	 call	 ??0VECTOR@@QAE@HH@Z	; VECTOR::VECTOR
  0034d	50		 push	 eax
  0034e	8d 45 8c	 lea	 eax, DWORD PTR $T6[ebp]
  00351	50		 push	 eax
  00352	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00355	e8 00 00 00 00	 call	 ??HVECTOR@@QAE?AV0@ABV0@@Z ; VECTOR::operator+
  0035a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0035c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0035f	89 4d d8	 mov	 DWORD PTR _dotAbove$15[ebp], ecx
  00362	89 55 dc	 mov	 DWORD PTR _dotAbove$15[ebp+4], edx

; 73   :       oldOwnerType[0] = pGame->BoxOwner(dotAbove);

  00365	8d 45 d8	 lea	 eax, DWORD PTR _dotAbove$15[ebp]
  00368	50		 push	 eax
  00369	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  0036c	e8 00 00 00 00	 call	 ?BoxOwner@DOTS_AND_BOXES@@QBE?AW4OWNER_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::BoxOwner
  00371	b9 04 00 00 00	 mov	 ecx, 4
  00376	6b d1 00	 imul	 edx, ecx, 0
  00379	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0037c	89 44 11 1c	 mov	 DWORD PTR [ecx+edx+28], eax

; 74   :       newOwnerType[0] = oldOwnerType[0];

  00380	ba 04 00 00 00	 mov	 edx, 4
  00385	6b c2 00	 imul	 eax, edx, 0
  00388	b9 04 00 00 00	 mov	 ecx, 4
  0038d	6b d1 00	 imul	 edx, ecx, 0
  00390	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00393	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00396	8b 44 06 1c	 mov	 eax, DWORD PTR [esi+eax+28]
  0039a	89 44 11 24	 mov	 DWORD PTR [ecx+edx+36], eax

; 75   :       pGame->SetHLineType(dotNum, oldLineType);

  0039e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003a1	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  003a4	52		 push	 edx
  003a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003a8	50		 push	 eax
  003a9	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  003ac	e8 00 00 00 00	 call	 ?SetHLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetHLineType

; 76   :       oldNumLine = pGame->CountLines(dotAbove);

  003b1	8b 4d d8	 mov	 ecx, DWORD PTR _dotAbove$15[ebp]
  003b4	8b 55 dc	 mov	 edx, DWORD PTR _dotAbove$15[ebp+4]
  003b7	89 4d 84	 mov	 DWORD PTR $T5[ebp], ecx
  003ba	89 55 88	 mov	 DWORD PTR $T5[ebp+4], edx
  003bd	8b 45 88	 mov	 eax, DWORD PTR $T5[ebp+4]
  003c0	50		 push	 eax
  003c1	8b 4d 84	 mov	 ecx, DWORD PTR $T5[ebp]
  003c4	51		 push	 ecx
  003c5	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  003c8	e8 00 00 00 00	 call	 ?CountLines@DOTS_AND_BOXES@@QBEHUtagPOINT@@@Z ; DOTS_AND_BOXES::CountLines
  003cd	89 45 f8	 mov	 DWORD PTR _oldNumLine$[ebp], eax

; 77   :       //if (numLine == 4) oldOwnerType[0] = OwnerType(oldLineType);
; 78   :       pGame->SetHLineType(dotNum, newLineType);

  003d0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003d3	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  003d6	50		 push	 eax
  003d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003da	51		 push	 ecx
  003db	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  003de	e8 00 00 00 00	 call	 ?SetHLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetHLineType

; 79   :       newNumLine = pGame->CountLines(dotAbove);

  003e3	8b 55 d8	 mov	 edx, DWORD PTR _dotAbove$15[ebp]
  003e6	8b 45 dc	 mov	 eax, DWORD PTR _dotAbove$15[ebp+4]
  003e9	89 95 7c ff ff
	ff		 mov	 DWORD PTR $T4[ebp], edx
  003ef	89 45 80	 mov	 DWORD PTR $T4[ebp+4], eax
  003f2	8b 4d 80	 mov	 ecx, DWORD PTR $T4[ebp+4]
  003f5	51		 push	 ecx
  003f6	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR $T4[ebp]
  003fc	52		 push	 edx
  003fd	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  00400	e8 00 00 00 00	 call	 ?CountLines@DOTS_AND_BOXES@@QBEHUtagPOINT@@@Z ; DOTS_AND_BOXES::CountLines
  00405	89 45 f4	 mov	 DWORD PTR _newNumLine$[ebp], eax

; 80   :       pGame->SetHLineType(dotNum, oldLineType);

  00408	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0040b	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0040e	51		 push	 ecx
  0040f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00412	52		 push	 edx
  00413	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  00416	e8 00 00 00 00	 call	 ?SetHLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetHLineType

; 81   :       if (newNumLine < 4) newOwnerType[0] = OWNER_NONE;

  0041b	83 7d f4 04	 cmp	 DWORD PTR _newNumLine$[ebp], 4
  0041f	7d 15		 jge	 SHORT $LN15@FindCaptur
  00421	b8 04 00 00 00	 mov	 eax, 4
  00426	6b c8 00	 imul	 ecx, eax, 0
  00429	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0042c	c7 44 0a 24 00
	00 00 00	 mov	 DWORD PTR [edx+ecx+36], 0
  00434	eb 24		 jmp	 SHORT $LN16@FindCaptur
$LN15@FindCaptur:

; 82   :       else if (oldNumLine < 4) newOwnerType[0] = OwnerType(newLineType);

  00436	83 7d f8 04	 cmp	 DWORD PTR _oldNumLine$[ebp], 4
  0043a	7d 1e		 jge	 SHORT $LN16@FindCaptur
  0043c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0043f	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00442	51		 push	 ecx
  00443	e8 00 00 00 00	 call	 ?OwnerType@@YA?AW4OWNER_TYPE@@W4LINE_TYPE@@@Z ; OwnerType
  00448	83 c4 04	 add	 esp, 4
  0044b	ba 04 00 00 00	 mov	 edx, 4
  00450	6b ca 00	 imul	 ecx, edx, 0
  00453	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00456	89 44 0a 24	 mov	 DWORD PTR [edx+ecx+36], eax
$LN16@FindCaptur:

; 83   :       if (oldOwnerType[0] != newOwnerType[0])

  0045a	b8 04 00 00 00	 mov	 eax, 4
  0045f	6b c8 00	 imul	 ecx, eax, 0
  00462	ba 04 00 00 00	 mov	 edx, 4
  00467	6b c2 00	 imul	 eax, edx, 0
  0046a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0046d	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00470	8b 4c 0a 1c	 mov	 ecx, DWORD PTR [edx+ecx+28]
  00474	3b 4c 06 24	 cmp	 ecx, DWORD PTR [esi+eax+36]
  00478	74 19		 je	 SHORT $LN14@FindCaptur

; 84   :       {
; 85   :         boxesCaptured[0] = dotAbove;

  0047a	ba 08 00 00 00	 mov	 edx, 8
  0047f	6b c2 00	 imul	 eax, edx, 0
  00482	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00485	8b 55 d8	 mov	 edx, DWORD PTR _dotAbove$15[ebp]
  00488	8b 75 dc	 mov	 esi, DWORD PTR _dotAbove$15[ebp+4]
  0048b	89 54 01 0c	 mov	 DWORD PTR [ecx+eax+12], edx
  0048f	89 74 01 10	 mov	 DWORD PTR [ecx+eax+16], esi
$LN14@FindCaptur:

; 86   :       };
; 87   :     };
; 88   :     if (dotNum.y < pGame->Size().y - 1) //check box below

  00493	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00499	50		 push	 eax
  0049a	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  0049d	e8 00 00 00 00	 call	 ?Size@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ ; DOTS_AND_BOXES::Size
  004a2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004a5	83 e9 01	 sub	 ecx, 1
  004a8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  004ab	39 4a 04	 cmp	 DWORD PTR [edx+4], ecx
  004ae	0f 8d 46 01 00
	00		 jge	 $LN1@FindCaptur

; 89   :     {
; 90   :       oldOwnerType[1] = pGame->BoxOwner(dotNum);

  004b4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  004b7	50		 push	 eax
  004b8	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  004bb	e8 00 00 00 00	 call	 ?BoxOwner@DOTS_AND_BOXES@@QBE?AW4OWNER_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::BoxOwner
  004c0	b9 04 00 00 00	 mov	 ecx, 4
  004c5	c1 e1 00	 shl	 ecx, 0
  004c8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  004cb	89 44 0a 1c	 mov	 DWORD PTR [edx+ecx+28], eax

; 91   :       newOwnerType[1] = oldOwnerType[1];

  004cf	b8 04 00 00 00	 mov	 eax, 4
  004d4	c1 e0 00	 shl	 eax, 0
  004d7	b9 04 00 00 00	 mov	 ecx, 4
  004dc	c1 e1 00	 shl	 ecx, 0
  004df	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  004e2	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  004e5	8b 44 06 1c	 mov	 eax, DWORD PTR [esi+eax+28]
  004e9	89 44 0a 24	 mov	 DWORD PTR [edx+ecx+36], eax

; 92   :       pGame->SetHLineType(dotNum, oldLineType);

  004ed	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004f0	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  004f3	52		 push	 edx
  004f4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  004f7	50		 push	 eax
  004f8	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  004fb	e8 00 00 00 00	 call	 ?SetHLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetHLineType

; 93   :       oldNumLine = pGame->CountLines(dotNum);

  00500	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00503	8b 11		 mov	 edx, DWORD PTR [ecx]
  00505	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00508	89 95 6c ff ff
	ff		 mov	 DWORD PTR $T2[ebp], edx
  0050e	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+4], eax
  00514	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp+4]
  0051a	51		 push	 ecx
  0051b	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  00521	52		 push	 edx
  00522	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  00525	e8 00 00 00 00	 call	 ?CountLines@DOTS_AND_BOXES@@QBEHUtagPOINT@@@Z ; DOTS_AND_BOXES::CountLines
  0052a	89 45 f8	 mov	 DWORD PTR _oldNumLine$[ebp], eax

; 94   :       //if (numLine == 4) oldOwnerType[1] = OwnerType(oldLineType);
; 95   :       pGame->SetHLineType(dotNum, newLineType);

  0052d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00530	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00533	51		 push	 ecx
  00534	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00537	52		 push	 edx
  00538	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  0053b	e8 00 00 00 00	 call	 ?SetHLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetHLineType

; 96   :       newNumLine = pGame->CountLines(dotNum);

  00540	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00543	8b 08		 mov	 ecx, DWORD PTR [eax]
  00545	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00548	89 8d 64 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  0054e	89 95 68 ff ff
	ff		 mov	 DWORD PTR $T1[ebp+4], edx
  00554	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR $T1[ebp+4]
  0055a	50		 push	 eax
  0055b	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  00561	51		 push	 ecx
  00562	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  00565	e8 00 00 00 00	 call	 ?CountLines@DOTS_AND_BOXES@@QBEHUtagPOINT@@@Z ; DOTS_AND_BOXES::CountLines
  0056a	89 45 f4	 mov	 DWORD PTR _newNumLine$[ebp], eax

; 97   :       pGame->SetHLineType(dotNum, oldLineType);

  0056d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00570	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00573	50		 push	 eax
  00574	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00577	51		 push	 ecx
  00578	8b 4d 08	 mov	 ecx, DWORD PTR _pGame$[ebp]
  0057b	e8 00 00 00 00	 call	 ?SetHLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetHLineType

; 98   :       if (newNumLine < 4) newOwnerType[1] = OWNER_NONE;

  00580	83 7d f4 04	 cmp	 DWORD PTR _newNumLine$[ebp], 4
  00584	7d 15		 jge	 SHORT $LN20@FindCaptur
  00586	ba 04 00 00 00	 mov	 edx, 4
  0058b	c1 e2 00	 shl	 edx, 0
  0058e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00591	c7 44 10 24 00
	00 00 00	 mov	 DWORD PTR [eax+edx+36], 0
  00599	eb 24		 jmp	 SHORT $LN21@FindCaptur
$LN20@FindCaptur:

; 99   :       else if (oldNumLine < 4) newOwnerType[1] = OwnerType(newLineType);

  0059b	83 7d f8 04	 cmp	 DWORD PTR _oldNumLine$[ebp], 4
  0059f	7d 1e		 jge	 SHORT $LN21@FindCaptur
  005a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005a4	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  005a7	52		 push	 edx
  005a8	e8 00 00 00 00	 call	 ?OwnerType@@YA?AW4OWNER_TYPE@@W4LINE_TYPE@@@Z ; OwnerType
  005ad	83 c4 04	 add	 esp, 4
  005b0	b9 04 00 00 00	 mov	 ecx, 4
  005b5	c1 e1 00	 shl	 ecx, 0
  005b8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  005bb	89 44 0a 24	 mov	 DWORD PTR [edx+ecx+36], eax
$LN21@FindCaptur:

; 100  :       if (oldOwnerType[1] != newOwnerType[1])

  005bf	b8 04 00 00 00	 mov	 eax, 4
  005c4	c1 e0 00	 shl	 eax, 0
  005c7	b9 04 00 00 00	 mov	 ecx, 4
  005cc	c1 e1 00	 shl	 ecx, 0
  005cf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  005d2	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  005d5	8b 44 02 1c	 mov	 eax, DWORD PTR [edx+eax+28]
  005d9	3b 44 0e 24	 cmp	 eax, DWORD PTR [esi+ecx+36]
  005dd	74 1b		 je	 SHORT $LN1@FindCaptur

; 101  :       {
; 102  :         boxesCaptured[1] = dotNum;

  005df	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005e2	8b 11		 mov	 edx, DWORD PTR [ecx]
  005e4	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  005e7	b9 08 00 00 00	 mov	 ecx, 8
  005ec	c1 e1 00	 shl	 ecx, 0
  005ef	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  005f2	89 54 0e 0c	 mov	 DWORD PTR [esi+ecx+12], edx
  005f6	89 44 0e 10	 mov	 DWORD PTR [esi+ecx+16], eax
$LN1@FindCaptur:

; 103  :       };
; 104  :     };
; 105  :   };
; 106  : }

  005fa	52		 push	 edx
  005fb	8b cd		 mov	 ecx, ebp
  005fd	50		 push	 eax
  005fe	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN28@FindCaptur
  00604	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00609	58		 pop	 eax
  0060a	5a		 pop	 edx
  0060b	5f		 pop	 edi
  0060c	5e		 pop	 esi
  0060d	81 c4 9c 00 00
	00		 add	 esp, 156		; 0000009cH
  00613	3b ec		 cmp	 ebp, esp
  00615	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0061a	8b e5		 mov	 esp, ebp
  0061c	5d		 pop	 ebp
  0061d	c2 04 00	 ret	 4
$LN28@FindCaptur:
  00620	02 00 00 00	 DD	 2
  00624	00 00 00 00	 DD	 $LN27@FindCaptur
$LN27@FindCaptur:
  00628	e8 ff ff ff	 DD	 -24			; ffffffe8H
  0062c	08 00 00 00	 DD	 8
  00630	00 00 00 00	 DD	 $LN25@FindCaptur
  00634	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00638	08 00 00 00	 DD	 8
  0063c	00 00 00 00	 DD	 $LN26@FindCaptur
$LN26@FindCaptur:
  00640	64		 DB	 100			; 00000064H
  00641	6f		 DB	 111			; 0000006fH
  00642	74		 DB	 116			; 00000074H
  00643	41		 DB	 65			; 00000041H
  00644	62		 DB	 98			; 00000062H
  00645	6f		 DB	 111			; 0000006fH
  00646	76		 DB	 118			; 00000076H
  00647	65		 DB	 101			; 00000065H
  00648	00		 DB	 0
$LN25@FindCaptur:
  00649	64		 DB	 100			; 00000064H
  0064a	6f		 DB	 111			; 0000006fH
  0064b	74		 DB	 116			; 00000074H
  0064c	4c		 DB	 76			; 0000004cH
  0064d	65		 DB	 101			; 00000065H
  0064e	66		 DB	 102			; 00000066H
  0064f	74		 DB	 116			; 00000074H
  00650	00		 DB	 0
?FindCaptures@MOVE@@QAEXPAVDOTS_AND_BOXES@@@Z ENDP	; MOVE::FindCaptures
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?SetBoxOwner@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4OWNER_TYPE@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dotNum$ = 8						; size = 4
_ot$ = 12						; size = 4
?SetBoxOwner@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4OWNER_TYPE@@@Z PROC ; DOTS_AND_BOXES::SetBoxOwner, COMDAT
; _this$ = ecx

; 109  :   INLINE void SetBoxOwner(const POINT& dotNum, OWNER_TYPE ot){SetBoxOwner(dotNum.x, dotNum.y, ot);};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _ot$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _dotNum$[ebp]
  00015	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00018	52		 push	 edx
  00019	8b 45 08	 mov	 eax, DWORD PTR _dotNum$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	51		 push	 ecx
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?SetBoxOwner@DOTS_AND_BOXES@@QAEXHHW4OWNER_TYPE@@@Z ; DOTS_AND_BOXES::SetBoxOwner
  00027	83 c4 04	 add	 esp, 4
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
?SetBoxOwner@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4OWNER_TYPE@@@Z ENDP ; DOTS_AND_BOXES::SetBoxOwner
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?SetBoxOwner@DOTS_AND_BOXES@@QAEXHHW4OWNER_TYPE@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_col$ = 8						; size = 4
_row$ = 12						; size = 4
_ot$ = 16						; size = 4
?SetBoxOwner@DOTS_AND_BOXES@@QAEXHHW4OWNER_TYPE@@@Z PROC ; DOTS_AND_BOXES::SetBoxOwner, COMDAT
; _this$ = ecx

; 108  :   INLINE void SetBoxOwner(int col, int row, OWNER_TYPE ot){m_owners[row*(m_width-1)+col]=(ui8)ot;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000d	83 e9 01	 sub	 ecx, 1
  00010	0f af 4d 0c	 imul	 ecx, DWORD PTR _row$[ebp]
  00014	03 4d 08	 add	 ecx, DWORD PTR _col$[ebp]
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0001d	8a 55 10	 mov	 dl, BYTE PTR _ot$[ebp]
  00020	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 0c 00	 ret	 12			; 0000000cH
?SetBoxOwner@DOTS_AND_BOXES@@QAEXHHW4OWNER_TYPE@@@Z ENDP ; DOTS_AND_BOXES::SetBoxOwner
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?BoxOwner@DOTS_AND_BOXES@@QBE?AW4OWNER_TYPE@@ABUtagPOINT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dotNum$ = 8						; size = 4
?BoxOwner@DOTS_AND_BOXES@@QBE?AW4OWNER_TYPE@@ABUtagPOINT@@@Z PROC ; DOTS_AND_BOXES::BoxOwner, COMDAT
; _this$ = ecx

; 107  :   INLINE OWNER_TYPE BoxOwner(const POINT& dotNum)const{return BoxOwner(dotNum.x, dotNum.y);};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _dotNum$[ebp]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	51		 push	 ecx
  00015	8b 55 08	 mov	 edx, DWORD PTR _dotNum$[ebp]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?BoxOwner@DOTS_AND_BOXES@@QBE?AW4OWNER_TYPE@@HH@Z ; DOTS_AND_BOXES::BoxOwner
  00023	83 c4 04	 add	 esp, 4
  00026	3b ec		 cmp	 ebp, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?BoxOwner@DOTS_AND_BOXES@@QBE?AW4OWNER_TYPE@@ABUtagPOINT@@@Z ENDP ; DOTS_AND_BOXES::BoxOwner
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?BoxOwner@DOTS_AND_BOXES@@QBE?AW4OWNER_TYPE@@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_col$ = 8						; size = 4
_row$ = 12						; size = 4
?BoxOwner@DOTS_AND_BOXES@@QBE?AW4OWNER_TYPE@@HH@Z PROC	; DOTS_AND_BOXES::BoxOwner, COMDAT
; _this$ = ecx

; 106  :   INLINE OWNER_TYPE BoxOwner(int col, int row)const{return (OWNER_TYPE)m_owners[row*(m_width-1) + col];};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000d	83 e9 01	 sub	 ecx, 1
  00010	0f af 4d 0c	 imul	 ecx, DWORD PTR _row$[ebp]
  00014	03 4d 08	 add	 ecx, DWORD PTR _col$[ebp]
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0001d	0f b6 04 08	 movzx	 eax, BYTE PTR [eax+ecx]
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?BoxOwner@DOTS_AND_BOXES@@QBE?AW4OWNER_TYPE@@HH@Z ENDP	; DOTS_AND_BOXES::BoxOwner
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?SetHLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dotNum$ = 8						; size = 4
_lt$ = 12						; size = 4
?SetHLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z PROC ; DOTS_AND_BOXES::SetHLineType, COMDAT
; _this$ = ecx

; 104  :   INLINE void SetHLineType(const POINT& dotNum, LINE_TYPE lt){SetHLineType(dotNum.x, dotNum.y, lt);};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _lt$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _dotNum$[ebp]
  00015	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00018	52		 push	 edx
  00019	8b 45 08	 mov	 eax, DWORD PTR _dotNum$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	51		 push	 ecx
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?SetHLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetHLineType
  00027	83 c4 04	 add	 esp, 4
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
?SetHLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ENDP ; DOTS_AND_BOXES::SetHLineType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?SetHLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_col$ = 8						; size = 4
_row$ = 12						; size = 4
_lt$ = 16						; size = 4
?SetHLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z PROC ; DOTS_AND_BOXES::SetHLineType, COMDAT
; _this$ = ecx

; 103  :   INLINE void SetHLineType(int col, int row, LINE_TYPE lt){v();m_hlines[row*(m_width-1)+col]=(ui8)lt;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?v@DOTS_AND_BOXES@@AAEXXZ ; DOTS_AND_BOXES::v
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0001c	83 e9 01	 sub	 ecx, 1
  0001f	0f af 4d 0c	 imul	 ecx, DWORD PTR _row$[ebp]
  00023	03 4d 08	 add	 ecx, DWORD PTR _col$[ebp]
  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0002c	8a 55 10	 mov	 dl, BYTE PTR _lt$[ebp]
  0002f	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  00032	83 c4 04	 add	 esp, 4
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 0c 00	 ret	 12			; 0000000cH
?SetHLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z ENDP ; DOTS_AND_BOXES::SetHLineType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?SetVLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dotNum$ = 8						; size = 4
_lt$ = 12						; size = 4
?SetVLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z PROC ; DOTS_AND_BOXES::SetVLineType, COMDAT
; _this$ = ecx

; 100  :   INLINE void SetVLineType(const POINT& dotNum, LINE_TYPE lt){SetVLineType(dotNum.x, dotNum.y, lt);};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _lt$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _dotNum$[ebp]
  00015	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00018	52		 push	 edx
  00019	8b 45 08	 mov	 eax, DWORD PTR _dotNum$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	51		 push	 ecx
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?SetVLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetVLineType
  00027	83 c4 04	 add	 esp, 4
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
?SetVLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ENDP ; DOTS_AND_BOXES::SetVLineType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?SetVLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_col$ = 8						; size = 4
_row$ = 12						; size = 4
_lt$ = 16						; size = 4
?SetVLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z PROC ; DOTS_AND_BOXES::SetVLineType, COMDAT
; _this$ = ecx

; 99   :   INLINE void SetVLineType(int col, int row, LINE_TYPE lt){v();m_vlines[row*m_width+col]=(ui8)lt;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?v@DOTS_AND_BOXES@@AAEXXZ ; DOTS_AND_BOXES::v
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _row$[ebp]
  0001c	0f af 48 10	 imul	 ecx, DWORD PTR [eax+16]
  00020	03 4d 08	 add	 ecx, DWORD PTR _col$[ebp]
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00029	8a 55 10	 mov	 dl, BYTE PTR _lt$[ebp]
  0002c	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 0c 00	 ret	 12			; 0000000cH
?SetVLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z ENDP ; DOTS_AND_BOXES::SetVLineType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?Size@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ
_TEXT	SEGMENT
_p$ = -16						; size = 8
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Size@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ PROC		; DOTS_AND_BOXES::Size, COMDAT
; _this$ = ecx

; 95   :   INLINE POINT Size(void) const {POINT p; p.x=m_width; p.y=m_height; return p;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00023	89 4d f0	 mov	 DWORD PTR _p$[ebp], ecx
  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0002c	89 45 f4	 mov	 DWORD PTR _p$[ebp+4], eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00032	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  00035	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp+4]
  00038	89 11		 mov	 DWORD PTR [ecx], edx
  0003a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0003d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00040	52		 push	 edx
  00041	8b cd		 mov	 ecx, ebp
  00043	50		 push	 eax
  00044	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Size
  0004a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0004f	58		 pop	 eax
  00050	5a		 pop	 edx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
  00057	90		 npad	 1
$LN5@Size:
  00058	01 00 00 00	 DD	 1
  0005c	00 00 00 00	 DD	 $LN4@Size
$LN4@Size:
  00060	f0 ff ff ff	 DD	 -16			; fffffff0H
  00064	08 00 00 00	 DD	 8
  00068	00 00 00 00	 DD	 $LN3@Size
$LN3@Size:
  0006c	70		 DB	 112			; 00000070H
  0006d	00		 DB	 0
?Size@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ ENDP		; DOTS_AND_BOXES::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?Height@DOTS_AND_BOXES@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Height@DOTS_AND_BOXES@@QBEHXZ PROC			; DOTS_AND_BOXES::Height, COMDAT
; _this$ = ecx

; 93   :   INLINE int Height(void) const {return m_height;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Height@DOTS_AND_BOXES@@QBEHXZ ENDP			; DOTS_AND_BOXES::Height
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?Width@DOTS_AND_BOXES@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Width@DOTS_AND_BOXES@@QBEHXZ PROC			; DOTS_AND_BOXES::Width, COMDAT
; _this$ = ecx

; 92   :   INLINE int Width(void) const {return m_width;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Width@DOTS_AND_BOXES@@QBEHXZ ENDP			; DOTS_AND_BOXES::Width
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?v@DOTS_AND_BOXES@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?v@DOTS_AND_BOXES@@AAEXXZ PROC				; DOTS_AND_BOXES::v, COMDAT
; _this$ = ecx

; 80   :   INLINE void v(void){m_loopWeightsValid=false;m_divideWeightsValid=false;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?v@DOTS_AND_BOXES@@AAEXXZ ENDP				; DOTS_AND_BOXES::v
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\stdafx.h
;	COMDAT ??HVECTOR@@QAE?AV0@ABV0@@Z
_TEXT	SEGMENT
_w$ = -16						; size = 8
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_vector$ = 12						; size = 4
??HVECTOR@@QAE?AV0@ABV0@@Z PROC				; VECTOR::operator+, COMDAT
; _this$ = ecx

; 64   :   VECTOR  operator +(const VECTOR& vector){VECTOR w;w.x=x+vector.x; w.y=y+vector.y; return w;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001d	8d 4d f0	 lea	 ecx, DWORD PTR _w$[ebp]
  00020	e8 00 00 00 00	 call	 ??0VECTOR@@QAE@XZ	; VECTOR::VECTOR
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	8b 55 0c	 mov	 edx, DWORD PTR _vector$[ebp]
  0002d	03 0a		 add	 ecx, DWORD PTR [edx]
  0002f	89 4d f0	 mov	 DWORD PTR _w$[ebp], ecx
  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	8b 55 0c	 mov	 edx, DWORD PTR _vector$[ebp]
  0003b	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0003e	89 4d f4	 mov	 DWORD PTR _w$[ebp+4], ecx
  00041	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00044	8b 4d f0	 mov	 ecx, DWORD PTR _w$[ebp]
  00047	8b 55 f4	 mov	 edx, DWORD PTR _w$[ebp+4]
  0004a	89 08		 mov	 DWORD PTR [eax], ecx
  0004c	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0004f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00052	52		 push	 edx
  00053	8b cd		 mov	 ecx, ebp
  00055	50		 push	 eax
  00056	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@operator
  0005c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00061	58		 pop	 eax
  00062	5a		 pop	 edx
  00063	83 c4 14	 add	 esp, 20			; 00000014H
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 08 00	 ret	 8
  00073	90		 npad	 1
$LN5@operator:
  00074	01 00 00 00	 DD	 1
  00078	00 00 00 00	 DD	 $LN4@operator
$LN4@operator:
  0007c	f0 ff ff ff	 DD	 -16			; fffffff0H
  00080	08 00 00 00	 DD	 8
  00084	00 00 00 00	 DD	 $LN3@operator
$LN3@operator:
  00088	77		 DB	 119			; 00000077H
  00089	00		 DB	 0
??HVECTOR@@QAE?AV0@ABV0@@Z ENDP				; VECTOR::operator+
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\stdafx.h
;	COMDAT ??4VECTOR@@QAEAAV0@ABUtagPOINT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_point$ = 8						; size = 4
??4VECTOR@@QAEAAV0@ABUtagPOINT@@@Z PROC			; VECTOR::operator=, COMDAT
; _this$ = ecx

; 63   :   VECTOR& operator =(const POINT& point){x=point.x;y=point.y;return *this;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _point$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _point$[ebp]
  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??4VECTOR@@QAEAAV0@ABUtagPOINT@@@Z ENDP			; VECTOR::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\stdafx.h
;	COMDAT ??0VECTOR@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??0VECTOR@@QAE@HH@Z PROC				; VECTOR::VECTOR, COMDAT
; _this$ = ecx

; 62   :   VECTOR(int a, int b){x=a;y=b;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0VECTOR@@QAE@HH@Z ENDP				; VECTOR::VECTOR
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\stdafx.h
;	COMDAT ??0VECTOR@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VECTOR@@QAE@XZ PROC					; VECTOR::VECTOR, COMDAT
; _this$ = ecx

; 61   :   VECTOR(void){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0VECTOR@@QAE@XZ ENDP					; VECTOR::VECTOR
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File G:\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\atlmfc\include\atltrace.h
;	COMDAT ?RegisterCategory@CTrace@ATL@@SAXPBDI@Z
_TEXT	SEGMENT
_buffer$ = -264						; size = 256
__$ArrayPad$ = -4					; size = 4
_pszCategory$ = 8					; size = 4
_nCategory$ = 12					; size = 4
?RegisterCategory@CTrace@ATL@@SAXPBDI@Z PROC		; ATL::CTrace::RegisterCategory, COMDAT

; 329  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  00011	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 330  : 		if (pszCategory == nullptr)

  00027	83 7d 08 00	 cmp	 DWORD PTR _pszCategory$[ebp], 0
  0002b	75 05		 jne	 SHORT $LN2@RegisterCa

; 331  : 		{
; 332  : 			return;

  0002d	e9 bb 00 00 00	 jmp	 $LN1@RegisterCa
$LN2@RegisterCa:

; 333  : 		}
; 334  : 
; 335  : 		if (m_nLastCategory >= MaxCategoryArray) 

  00032	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 32 ; ATL::CTrace::m_nLastCategory, 00000020H
  00039	72 36		 jb	 SHORT $LN3@RegisterCa

; 336  : 		{
; 337  : 			ATLASSERT(false && "Too many categories defined");

  0003b	33 c0		 xor	 eax, eax
  0003d	75 30		 jne	 SHORT $LN5@RegisterCa
  0003f	8b f4		 mov	 esi, esp
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm@
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs@
  0004b	6a 00		 push	 0
  0004d	68 51 01 00 00	 push	 337			; 00000151H
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_1LM@KONDCONO@?$AAG?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi@
  00057	6a 02		 push	 2
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0005f	83 c4 18	 add	 esp, 24			; 00000018H
  00062	3b f4		 cmp	 esi, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	83 f8 01	 cmp	 eax, 1
  0006c	75 01		 jne	 SHORT $LN5@RegisterCa
  0006e	cc		 int	 3
$LN5@RegisterCa:

; 338  : 			return;

  0006f	eb 7c		 jmp	 SHORT $LN1@RegisterCa
$LN3@RegisterCa:

; 339  : 		}
; 340  : 
; 341  : 		m_nMap[m_nLastCategory].nCategory = nCategory;

  00071	69 15 00 00 00
	00 04 01 00 00	 imul	 edx, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 260 ; ATL::CTrace::m_nLastCategory
  0007b	8b 45 0c	 mov	 eax, DWORD PTR _nCategory$[ebp]
  0007e	89 82 00 00 00
	00		 mov	 DWORD PTR ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A[edx], eax

; 342  : #ifdef _UNICODE
; 343  : 		wcscpy_s(m_nMap[m_nLastCategory].categryName, MaxLengthOfCategoryName - 1, pszCategory);
; 344  : #else
; 345  : 		wchar_t buffer[MaxLengthOfCategoryName] = { 0 };	

  00084	68 00 01 00 00	 push	 256			; 00000100H
  00089	6a 00		 push	 0
  0008b	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 _memset
  00097	83 c4 0c	 add	 esp, 12			; 0000000cH

; 346  : #if _MSC_VER < 1900
; 347  : 		swprintf_s(buffer, MaxLengthOfCategoryName - 1, L"%S", pszCategory);
; 348  : #else
; 349  : 		swprintf_s(buffer, MaxLengthOfCategoryName - 1, L"%hs", pszCategory);

  0009a	8b 55 08	 mov	 edx, DWORD PTR _pszCategory$[ebp]
  0009d	52		 push	 edx
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs@
  000a3	6a 7f		 push	 127			; 0000007fH
  000a5	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _swprintf_s
  000b1	83 c4 10	 add	 esp, 16			; 00000010H

; 350  : #endif
; 351  : 		wcscpy_s(m_nMap[m_nLastCategory].categryName, MaxLengthOfCategoryName - 1, buffer);

  000b4	8b f4		 mov	 esi, esp
  000b6	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  000bc	51		 push	 ecx
  000bd	6a 7f		 push	 127			; 0000007fH
  000bf	69 15 00 00 00
	00 04 01 00 00	 imul	 edx, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 260 ; ATL::CTrace::m_nLastCategory
  000c9	81 c2 04 00 00
	00		 add	 edx, OFFSET ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A+4
  000cf	52		 push	 edx
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcscpy_s
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d9	3b f4		 cmp	 esi, esp
  000db	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 352  : #endif
; 353  : 	
; 354  : 		m_nLastCategory++;

  000e0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA ; ATL::CTrace::m_nLastCategory
  000e5	83 c0 01	 add	 eax, 1
  000e8	a3 00 00 00 00	 mov	 DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, eax ; ATL::CTrace::m_nLastCategory
$LN1@RegisterCa:

; 355  : 	}

  000ed	52		 push	 edx
  000ee	8b cd		 mov	 ecx, ebp
  000f0	50		 push	 eax
  000f1	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@RegisterCa
  000f7	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000fc	58		 pop	 eax
  000fd	5a		 pop	 edx
  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00103	33 cd		 xor	 ecx, ebp
  00105	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010a	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  00110	3b ec		 cmp	 ebp, esp
  00112	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c3		 ret	 0
  0011b	90		 npad	 1
$LN8@RegisterCa:
  0011c	01 00 00 00	 DD	 1
  00120	00 00 00 00	 DD	 $LN7@RegisterCa
$LN7@RegisterCa:
  00124	f8 fe ff ff	 DD	 -264			; fffffef8H
  00128	00 01 00 00	 DD	 256			; 00000100H
  0012c	00 00 00 00	 DD	 $LN6@RegisterCa
$LN6@RegisterCa:
  00130	62		 DB	 98			; 00000062H
  00131	75		 DB	 117			; 00000075H
  00132	66		 DB	 102			; 00000066H
  00133	66		 DB	 102			; 00000066H
  00134	65		 DB	 101			; 00000065H
  00135	72		 DB	 114			; 00000072H
  00136	00		 DB	 0
?RegisterCategory@CTrace@ATL@@SAXPBDI@Z ENDP		; ATL::CTrace::RegisterCategory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File G:\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceString@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceString@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceString'', COMDAT

; 114  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceString> atlTraceString(_T("atlTraceString"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG74238
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
  00012	3b ec		 cmp	 ebp, esp
  00014	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??__EatlTraceString@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceString''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu
; File G:\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>, COMDAT
; _this$ = ecx

; 480  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 481  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  0000e	68 00 00 02 00	 push	 131072			; 00020000H
  00013	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPBDI@Z ; ATL::CTrace::RegisterCategory
  0001c	83 c4 08	 add	 esp, 8

; 482  : }

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	83 c4 04	 add	 esp, 4
  00025	3b ec		 cmp	 ebp, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File G:\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceException@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceException@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceException'', COMDAT

; 110  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceException> atlTraceException(_T("atlTraceException"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG74042
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
  00012	3b ec		 cmp	 ebp, esp
  00014	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??__EatlTraceException@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceException''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu
; File G:\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>, COMDAT
; _this$ = ecx

; 480  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 481  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  0000e	68 00 20 00 00	 push	 8192			; 00002000H
  00013	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPBDI@Z ; ATL::CTrace::RegisterCategory
  0001c	83 c4 08	 add	 esp, 8

; 482  : }

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	83 c4 04	 add	 esp, 4
  00025	3b ec		 cmp	 ebp, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_wstdio.h
;	COMDAT _swprintf_s
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_swprintf_s PROC					; COMDAT

; 1523 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1524 :             int _Result;
; 1525 :             va_list _ArgList;
; 1526 :             __crt_va_start(_ArgList, _Format);

  0001b	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0001e	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1527 :             _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00021	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  00024	51		 push	 ecx
  00025	6a 00		 push	 0
  00027	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  0002a	52		 push	 edx
  0002b	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 __vswprintf_s_l
  00038	83 c4 14	 add	 esp, 20			; 00000014H
  0003b	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1528 :             __crt_va_end(_ArgList);

  0003e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1529 :             return _Result;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1530 :         }

  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_swprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_wstdio.h
;	COMDAT __vswprintf_s_l
_TEXT	SEGMENT
tv73 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vswprintf_s_l PROC					; COMDAT

; 1256 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1257 :         int const _Result = __stdio_common_vswprintf_s(

  00015	8b f4		 mov	 esi, esp
  00017	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00022	52		 push	 edx
  00023	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00030	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00033	52		 push	 edx
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vswprintf_s
  0003d	83 c4 1c	 add	 esp, 28			; 0000001cH
  00040	3b f4		 cmp	 esi, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1258 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1259 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1260 : 
; 1261 :         return _Result < 0 ? -1 : _Result;

  0004a	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0004e	7d 09		 jge	 SHORT $LN3@vswprintf_
  00050	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv73[ebp], -1
  00057	eb 06		 jmp	 SHORT $LN4@vswprintf_
$LN3@vswprintf_:
  00059	8b 4d fc	 mov	 ecx, DWORD PTR __Result$[ebp]
  0005c	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
$LN4@vswprintf_:
  0005f	8b 45 f8	 mov	 eax, DWORD PTR tv73[ebp]

; 1262 :     }

  00062	5e		 pop	 esi
  00063	83 c4 08	 add	 esp, 8
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
__vswprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\MoveHistory.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\MoveHistory.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv67 = -8						; size = 4
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
$LN2@vector:
  00015	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00018	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0001b	8b 4d 10	 mov	 ecx, DWORD PTR ___n$[ebp]
  0001e	83 e9 01	 sub	 ecx, 1
  00021	89 4d 10	 mov	 DWORD PTR ___n$[ebp], ecx
  00024	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00028	76 09		 jbe	 SHORT $LN5@vector
  0002a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  00031	eb 07		 jmp	 SHORT $LN6@vector
$LN5@vector:
  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN6@vector:
  0003a	83 7d f8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003e	74 1a		 je	 SHORT $LN1@vector
  00040	8b f4		 mov	 esi, esp
  00042	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00045	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  00048	3b f4		 cmp	 esi, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b 55 08	 mov	 edx, DWORD PTR ___t$[ebp]
  00052	03 55 0c	 add	 edx, DWORD PTR ___s$[ebp]
  00055	89 55 08	 mov	 DWORD PTR ___t$[ebp], edx
  00058	eb bb		 jmp	 SHORT $LN2@vector
$LN1@vector:
  0005a	5e		 pop	 esi
  0005b	83 c4 08	 add	 esp, 8
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
