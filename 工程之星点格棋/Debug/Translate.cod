; Listing generated by Microsoft (R) Optimizing Compiler Version 19.35.32217.1 

	TITLE	C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\Debug\Translate.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG225416 DB	'C:\Users\15485\Desktop\', 0b9H, 0a4H, 0b3H, 0ccH, 0d6H, 0aeH
	DB	0d0H, 0c7H, 0b5H, 0e3H, 0b8H, 0f1H, 0c6H, 0e5H, '\DotBoxLib\Tr'
	DB	'anslate.cpp', 00H
	ORG $+2
$SG225432 DB	'C:\Users\15485\Desktop\', 0b9H, 0a4H, 0b3H, 0ccH, 0d6H, 0aeH
	DB	0d0H, 0c7H, 0b5H, 0e3H, 0b8H, 0f1H, 0c6H, 0e5H, '\DotBoxLib\Tr'
	DB	'anslate.cpp', 00H
	ORG $+2
$SG225433 DB	'C:\Users\15485\Desktop\', 0b9H, 0a4H, 0b3H, 0ccH, 0d6H, 0aeH
	DB	0d0H, 0c7H, 0b5H, 0e3H, 0b8H, 0f1H, 0c6H, 0e5H, '\DotBoxLib\Tr'
	DB	'anslate.cpp', 00H
	ORG $+2
$SG225458 DB	'de-de length < 2', 00H
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?AfxAssertFailedLine@@YGHPBDH@Z			; AfxAssertFailedLine
PUBLIC	?Width@DOTS_AND_BOXES@@QBEHXZ			; DOTS_AND_BOXES::Width
PUBLIC	?Height@DOTS_AND_BOXES@@QBEHXZ			; DOTS_AND_BOXES::Height
PUBLIC	?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
PUBLIC	?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
PUBLIC	?Clear@EDGEDATA@@QAEXXZ				; EDGEDATA::Clear
PUBLIC	?Clear@NODEDATA@@QAEXXZ				; NODEDATA::Clear
PUBLIC	?Clear@CON@@QAEXH@Z				; CON::Clear
PUBLIC	?AddLink@CON@@QAEXHH@Z				; CON::AddLink
PUBLIC	?AddGround@CON@@QAEXH@Z				; CON::AddGround
PUBLIC	??4CON@@QAEAAV0@ABVDOTS_AND_BOXES@@@Z		; CON::operator=
PUBLIC	?GrabAnything@CON@@QAEXXZ			; CON::GrabAnything
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	?ImplementationError@@YAXPBD@Z:PROC		; ImplementationError
EXTRN	?DeleteEdge@CON@@QAEXHH@Z:PROC			; CON::DeleteEdge
EXTRN	?DeleteNode@CON@@QAEXH@Z:PROC			; CON::DeleteNode
EXTRN	?Compress@CON@@QAEXXZ:PROC			; CON::Compress
EXTRN	??4CON@@QAEAAV0@ABV0@@Z:PROC			; CON::operator=
EXTRN	?Canon@CON@@QAEXHH@Z:PROC			; CON::Canon
EXTRN	?_FormChains@CON@@QAEXXZ:PROC			; CON::_FormChains
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	?computerMove@@3UPossibleMove@@A:BYTE		; computerMove
EXTRN	?moveType@@3W4MOVE_TYPE@@A:DWORD		; moveType
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Translate.cpp
_TEXT	SEGMENT
_en$1 = -16						; size = 4
_nnA$ = -12						; size = 4
_nn$ = -8						; size = 4
_this$ = -4						; size = 4
?GrabAnything@CON@@QAEXXZ PROC				; CON::GrabAnything
; _this$ = ecx

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 41   :   int nn, nnA;
; 42   :   // Grab any available coin.
; 43   :   for (nn=0; nn<m_numNode; nn++)

  0001a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nn$[ebp], 0
  00021	eb 09		 jmp	 SHORT $LN4@GrabAnythi
$LN2@GrabAnythi:
  00023	8b 45 f8	 mov	 eax, DWORD PTR _nn$[ebp]
  00026	83 c0 01	 add	 eax, 1
  00029	89 45 f8	 mov	 DWORD PTR _nn$[ebp], eax
$LN4@GrabAnythi:
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 55 f8	 mov	 edx, DWORD PTR _nn$[ebp]
  00032	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00034	0f 8d f6 00 00
	00		 jge	 $LN3@GrabAnythi

; 44   :   {
; 45   :     //First we look for a chain with DEADEND on both ends.
; 46   :     nnA = nd[nn].ix;

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _nn$[ebp]
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	0f b6 94 81 13
	10 00 00	 movzx	 edx, BYTE PTR [ecx+eax*4+4115]
  00048	89 55 f4	 mov	 DWORD PTR _nnA$[ebp], edx

; 47   :     if (sd[nnA][0].ns == DE_DE)

  0004b	8b 45 f4	 mov	 eax, DWORD PTR _nnA$[ebp]
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  00058	b8 02 00 00 00	 mov	 eax, 2
  0005d	6b c8 00	 imul	 ecx, eax, 0
  00060	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  00064	81 fa fb 00 00
	00		 cmp	 edx, 251		; 000000fbH
  0006a	0f 85 bb 00 00
	00		 jne	 $LN14@GrabAnythi

; 48   :     {
; 49   :       if (ed[nnA].e[0].el == 2)

  00070	8b 45 f4	 mov	 eax, DWORD PTR _nnA$[ebp]
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  0007a	b8 02 00 00 00	 mov	 eax, 2
  0007f	6b c8 00	 imul	 ecx, eax, 0
  00082	0f b6 54 0a 01	 movzx	 edx, BYTE PTR [edx+ecx+1]
  00087	83 fa 02	 cmp	 edx, 2
  0008a	75 1e		 jne	 SHORT $LN15@GrabAnythi

; 50   :       {
; 51   :         computerMove.con = *this;

  0008c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	50		 push	 eax
  00090	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  00095	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=

; 52   :         computerMove.con.DeleteNode(nn);

  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _nn$[ebp]
  0009d	51		 push	 ecx
  0009e	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  000a3	e8 00 00 00 00	 call	 ?DeleteNode@CON@@QAEXH@Z ; CON::DeleteNode

; 53   :       }

  000a8	eb 5f		 jmp	 SHORT $LN16@GrabAnythi
$LN15@GrabAnythi:

; 54   :       else if (ed[nnA].e[0].el >= 3)

  000aa	8b 55 f4	 mov	 edx, DWORD PTR _nnA$[ebp]
  000ad	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b0	8d 4c d0 10	 lea	 ecx, DWORD PTR [eax+edx*8+16]
  000b4	ba 02 00 00 00	 mov	 edx, 2
  000b9	6b c2 00	 imul	 eax, edx, 0
  000bc	0f b6 4c 01 01	 movzx	 ecx, BYTE PTR [ecx+eax+1]
  000c1	83 f9 03	 cmp	 ecx, 3
  000c4	7c 36		 jl	 SHORT $LN17@GrabAnythi

; 55   :       {
; 56   :         computerMove.con = *this;

  000c6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c9	52		 push	 edx
  000ca	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  000cf	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=

; 57   :         computerMove.con.ed[nnA].e[0].el--;

  000d4	b8 02 00 00 00	 mov	 eax, 2
  000d9	6b c8 00	 imul	 ecx, eax, 0
  000dc	8b 55 f4	 mov	 edx, DWORD PTR _nnA$[ebp]
  000df	8a 84 d1 19 00
	00 00		 mov	 al, BYTE PTR ?computerMove@@3UPossibleMove@@A[ecx+edx*8+25]
  000e6	2c 01		 sub	 al, 1
  000e8	b9 02 00 00 00	 mov	 ecx, 2
  000ed	6b d1 00	 imul	 edx, ecx, 0
  000f0	8b 4d f4	 mov	 ecx, DWORD PTR _nnA$[ebp]
  000f3	88 84 ca 19 00
	00 00		 mov	 BYTE PTR ?computerMove@@3UPossibleMove@@A[edx+ecx*8+25], al

; 58   :       }

  000fa	eb 0d		 jmp	 SHORT $LN16@GrabAnythi
$LN17@GrabAnythi:

; 59   :       else
; 60   :       {
; 61   :         ImplementationError("de-de length < 2");

  000fc	68 00 00 00 00	 push	 OFFSET $SG225458
  00101	e8 00 00 00 00	 call	 ?ImplementationError@@YAXPBD@Z ; ImplementationError
  00106	83 c4 04	 add	 esp, 4
$LN16@GrabAnythi:

; 62   :       };
; 63   :       computerMove.con.Canon(0,computerMove.con.m_numNode);

  00109	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ?computerMove@@3UPossibleMove@@A+8
  0010f	52		 push	 edx
  00110	6a 00		 push	 0
  00112	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  00117	e8 00 00 00 00	 call	 ?Canon@CON@@QAEXHH@Z	; CON::Canon

; 64   : #ifdef _CHECK
; 65   :       computerMove.con.CheckEverything(0,computerMove.con.m_numNode,false);
; 66   : #endif
; 67   :       moveType = MT_GRABANYTHING;

  0011c	c7 05 00 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?moveType@@3W4MOVE_TYPE@@A, 8 ; moveType

; 68   :       return;

  00126	e9 ee 01 00 00	 jmp	 $LN1@GrabAnythi
$LN14@GrabAnythi:

; 69   :     };
; 70   :   };

  0012b	e9 f3 fe ff ff	 jmp	 $LN2@GrabAnythi
$LN3@GrabAnythi:

; 71   :   for (nn=0; nn<m_numNode; nn++)

  00130	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nn$[ebp], 0
  00137	eb 09		 jmp	 SHORT $LN7@GrabAnythi
$LN5@GrabAnythi:
  00139	8b 45 f8	 mov	 eax, DWORD PTR _nn$[ebp]
  0013c	83 c0 01	 add	 eax, 1
  0013f	89 45 f8	 mov	 DWORD PTR _nn$[ebp], eax
$LN7@GrabAnythi:
  00142	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00145	8b 55 f8	 mov	 edx, DWORD PTR _nn$[ebp]
  00148	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0014a	0f 8d be 00 00
	00		 jge	 $LN6@GrabAnythi

; 72   :   {
; 73   :     //Now look for a chain from DEADEND to GROUND
; 74   :     nnA = nd[nn].ix;

  00150	8b 45 f8	 mov	 eax, DWORD PTR _nn$[ebp]
  00153	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00156	0f b6 94 81 13
	10 00 00	 movzx	 edx, BYTE PTR [ecx+eax*4+4115]
  0015e	89 55 f4	 mov	 DWORD PTR _nnA$[ebp], edx

; 75   :     if (sd[nnA][0].ns == GND_DE)

  00161	8b 45 f4	 mov	 eax, DWORD PTR _nnA$[ebp]
  00164	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00167	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  0016e	b8 02 00 00 00	 mov	 eax, 2
  00173	6b c8 00	 imul	 ecx, eax, 0
  00176	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  0017a	81 fa fc 00 00
	00		 cmp	 edx, 252		; 000000fcH
  00180	0f 85 83 00 00
	00		 jne	 $LN19@GrabAnythi

; 76   :     {
; 77   :       computerMove.con = *this;

  00186	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00189	50		 push	 eax
  0018a	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  0018f	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=

; 78   :       if (ed[nnA].e[0].el == 1)

  00194	8b 4d f4	 mov	 ecx, DWORD PTR _nnA$[ebp]
  00197	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0019a	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  0019e	b9 02 00 00 00	 mov	 ecx, 2
  001a3	6b d1 00	 imul	 edx, ecx, 0
  001a6	0f b6 44 10 01	 movzx	 eax, BYTE PTR [eax+edx+1]
  001ab	83 f8 01	 cmp	 eax, 1
  001ae	75 10		 jne	 SHORT $LN20@GrabAnythi

; 79   :       {
; 80   :         computerMove.con.DeleteNode(nn);

  001b0	8b 4d f8	 mov	 ecx, DWORD PTR _nn$[ebp]
  001b3	51		 push	 ecx
  001b4	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  001b9	e8 00 00 00 00	 call	 ?DeleteNode@CON@@QAEXH@Z ; CON::DeleteNode

; 81   :       }

  001be	eb 27		 jmp	 SHORT $LN21@GrabAnythi
$LN20@GrabAnythi:

; 82   :       else
; 83   :       {
; 84   :         computerMove.con.ed[nnA].e[0].el--;

  001c0	ba 02 00 00 00	 mov	 edx, 2
  001c5	6b c2 00	 imul	 eax, edx, 0
  001c8	8b 4d f4	 mov	 ecx, DWORD PTR _nnA$[ebp]
  001cb	8a 94 c8 19 00
	00 00		 mov	 dl, BYTE PTR ?computerMove@@3UPossibleMove@@A[eax+ecx*8+25]
  001d2	80 ea 01	 sub	 dl, 1
  001d5	b8 02 00 00 00	 mov	 eax, 2
  001da	6b c8 00	 imul	 ecx, eax, 0
  001dd	8b 45 f4	 mov	 eax, DWORD PTR _nnA$[ebp]
  001e0	88 94 c1 19 00
	00 00		 mov	 BYTE PTR ?computerMove@@3UPossibleMove@@A[ecx+eax*8+25], dl
$LN21@GrabAnythi:

; 85   :       };
; 86   :       moveType = MT_GRABANYTHING;

  001e7	c7 05 00 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?moveType@@3W4MOVE_TYPE@@A, 8 ; moveType

; 87   :       computerMove.con.Canon(0,computerMove.con.m_numNode);

  001f1	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?computerMove@@3UPossibleMove@@A+8
  001f7	51		 push	 ecx
  001f8	6a 00		 push	 0
  001fa	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  001ff	e8 00 00 00 00	 call	 ?Canon@CON@@QAEXHH@Z	; CON::Canon

; 88   : #ifdef _CHECK
; 89   :       computerMove.con.CheckEverything(0,computerMove.con.m_numNode,false);
; 90   : #endif
; 91   :       return;

  00204	e9 10 01 00 00	 jmp	 $LN1@GrabAnythi
$LN19@GrabAnythi:

; 92   :     };
; 93   :   };

  00209	e9 2b ff ff ff	 jmp	 $LN5@GrabAnythi
$LN6@GrabAnythi:

; 94   :   for (nn=0; nn<m_numNode; nn++)

  0020e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nn$[ebp], 0
  00215	eb 09		 jmp	 SHORT $LN10@GrabAnythi
$LN8@GrabAnythi:
  00217	8b 55 f8	 mov	 edx, DWORD PTR _nn$[ebp]
  0021a	83 c2 01	 add	 edx, 1
  0021d	89 55 f8	 mov	 DWORD PTR _nn$[ebp], edx
$LN10@GrabAnythi:
  00220	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00223	8b 4d f8	 mov	 ecx, DWORD PTR _nn$[ebp]
  00226	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00228	0f 8d eb 00 00
	00		 jge	 $LN1@GrabAnythi

; 95   :   {
; 96   :     //Now look for a chain from DEADEND to NODE
; 97   :     nnA = nd[nn].ix;

  0022e	8b 55 f8	 mov	 edx, DWORD PTR _nn$[ebp]
  00231	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00234	0f b6 8c 90 13
	10 00 00	 movzx	 ecx, BYTE PTR [eax+edx*4+4115]
  0023c	89 4d f4	 mov	 DWORD PTR _nnA$[ebp], ecx

; 98   :     for (int en=0; en<nd[nnA].ec; en++)

  0023f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _en$1[ebp], 0
  00246	eb 09		 jmp	 SHORT $LN13@GrabAnythi
$LN11@GrabAnythi:
  00248	8b 55 f0	 mov	 edx, DWORD PTR _en$1[ebp]
  0024b	83 c2 01	 add	 edx, 1
  0024e	89 55 f0	 mov	 DWORD PTR _en$1[ebp], edx
$LN13@GrabAnythi:
  00251	8b 45 f4	 mov	 eax, DWORD PTR _nnA$[ebp]
  00254	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00257	0f b6 94 81 10
	10 00 00	 movzx	 edx, BYTE PTR [ecx+eax*4+4112]
  0025f	39 55 f0	 cmp	 DWORD PTR _en$1[ebp], edx
  00262	0f 8d ac 00 00
	00		 jge	 $LN12@GrabAnythi

; 99   :     {
; 100  :       if (sd[nnA][en].ns == DEADEND)

  00268	8b 45 f4	 mov	 eax, DWORD PTR _nnA$[ebp]
  0026b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0026e	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  00275	8b 45 f0	 mov	 eax, DWORD PTR _en$1[ebp]
  00278	0f b6 0c 42	 movzx	 ecx, BYTE PTR [edx+eax*2]
  0027c	81 f9 f9 00 00
	00		 cmp	 ecx, 249		; 000000f9H
  00282	0f 85 87 00 00
	00		 jne	 $LN22@GrabAnythi

; 101  :       {
; 102  :         if (ed[nnA].e[en].el > 1)

  00288	8b 55 f4	 mov	 edx, DWORD PTR _nnA$[ebp]
  0028b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0028e	8d 4c d0 10	 lea	 ecx, DWORD PTR [eax+edx*8+16]
  00292	8b 55 f0	 mov	 edx, DWORD PTR _en$1[ebp]
  00295	0f b6 44 51 01	 movzx	 eax, BYTE PTR [ecx+edx*2+1]
  0029a	83 f8 01	 cmp	 eax, 1
  0029d	7e 31		 jle	 SHORT $LN23@GrabAnythi

; 103  :         {
; 104  :           computerMove.con = *this;

  0029f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002a2	51		 push	 ecx
  002a3	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  002a8	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=

; 105  :           computerMove.con.ed[nnA].e[en].el--;

  002ad	8b 55 f0	 mov	 edx, DWORD PTR _en$1[ebp]
  002b0	d1 e2		 shl	 edx, 1
  002b2	8b 45 f4	 mov	 eax, DWORD PTR _nnA$[ebp]
  002b5	8a 8c c2 19 00
	00 00		 mov	 cl, BYTE PTR ?computerMove@@3UPossibleMove@@A[edx+eax*8+25]
  002bc	80 e9 01	 sub	 cl, 1
  002bf	8b 55 f0	 mov	 edx, DWORD PTR _en$1[ebp]
  002c2	d1 e2		 shl	 edx, 1
  002c4	8b 45 f4	 mov	 eax, DWORD PTR _nnA$[ebp]
  002c7	88 8c c2 19 00
	00 00		 mov	 BYTE PTR ?computerMove@@3UPossibleMove@@A[edx+eax*8+25], cl

; 106  :         }

  002ce	eb 20		 jmp	 SHORT $LN24@GrabAnythi
$LN23@GrabAnythi:

; 107  :         else
; 108  :         {
; 109  :           computerMove.con = *this;

  002d0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d3	51		 push	 ecx
  002d4	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  002d9	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=

; 110  :           computerMove.con.DeleteEdge(nn,en);

  002de	8b 55 f0	 mov	 edx, DWORD PTR _en$1[ebp]
  002e1	52		 push	 edx
  002e2	8b 45 f8	 mov	 eax, DWORD PTR _nn$[ebp]
  002e5	50		 push	 eax
  002e6	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  002eb	e8 00 00 00 00	 call	 ?DeleteEdge@CON@@QAEXHH@Z ; CON::DeleteEdge
$LN24@GrabAnythi:

; 111  :         };
; 112  :         computerMove.con.Canon(0,computerMove.con.m_numNode);

  002f0	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?computerMove@@3UPossibleMove@@A+8
  002f6	51		 push	 ecx
  002f7	6a 00		 push	 0
  002f9	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  002fe	e8 00 00 00 00	 call	 ?Canon@CON@@QAEXHH@Z	; CON::Canon

; 113  : #ifdef _CHECK
; 114  :         computerMove.con.CheckEverything(0,computerMove.con.m_numNode,false);
; 115  : #endif
; 116  :         moveType = MT_GRABANYTHING;

  00303	c7 05 00 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?moveType@@3W4MOVE_TYPE@@A, 8 ; moveType

; 117  :         return;

  0030d	eb 0a		 jmp	 SHORT $LN1@GrabAnythi
$LN22@GrabAnythi:

; 118  :       };
; 119  :     };

  0030f	e9 34 ff ff ff	 jmp	 $LN11@GrabAnythi
$LN12@GrabAnythi:

; 120  :   };

  00314	e9 fe fe ff ff	 jmp	 $LN8@GrabAnythi
$LN1@GrabAnythi:

; 121  : }

  00319	83 c4 10	 add	 esp, 16			; 00000010H
  0031c	3b ec		 cmp	 ebp, esp
  0031e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00323	8b e5		 mov	 esp, ebp
  00325	5d		 pop	 ebp
  00326	c3		 ret	 0
?GrabAnything@CON@@QAEXXZ ENDP				; CON::GrabAnything
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Translate.cpp
_TEXT	SEGMENT
_ec$1 = -60						; size = 4
_en$2 = -56						; size = 4
_nnB$3 = -52						; size = 4
_nnA$4 = -48						; size = 4
_nn$5 = -44						; size = 4
_count$6 = -40						; size = 4
_linkStart$ = -36					; size = 4
_linksPerRow$ = -32					; size = 4
_boxNum$ = -28						; size = 4
_rowStart$ = -24					; size = 4
_height$ = -20						; size = 4
_width$ = -16						; size = 4
_col$ = -12						; size = 4
_row$ = -8						; size = 4
_this$ = -4						; size = 4
_db$ = 8						; size = 4
??4CON@@QAEAAV0@ABVDOTS_AND_BOXES@@@Z PROC		; CON::operator=
; _this$ = ecx

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	57		 push	 edi
  00007	51		 push	 ecx
  00008	8d 7d c4	 lea	 edi, DWORD PTR [ebp-60]
  0000b	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	59		 pop	 ecx
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 126  :   int row, col, width, height, rowStart, boxNum;
; 127  :   int linksPerRow, linkStart;
; 128  :   m_numNode = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 129  :   nd[GROUND].gn = GROUND;

  00024	b9 04 00 00 00	 mov	 ecx, 4
  00029	69 d1 fa 00 00
	00		 imul	 edx, ecx, 250
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	c6 84 10 11 10
	00 00 fa	 mov	 BYTE PTR [eax+edx+4113], 250 ; 000000faH

; 130  :   nd[DEADEND].gn = DEADEND;

  0003a	b9 04 00 00 00	 mov	 ecx, 4
  0003f	69 d1 f9 00 00
	00		 imul	 edx, ecx, 249
  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	c6 84 10 11 10
	00 00 f9	 mov	 BYTE PTR [eax+edx+4113], 249 ; 000000f9H

; 131  :   width = db.Width()-1;    // #boxes

  00050	8b 4d 08	 mov	 ecx, DWORD PTR _db$[ebp]
  00053	e8 00 00 00 00	 call	 ?Width@DOTS_AND_BOXES@@QBEHXZ ; DOTS_AND_BOXES::Width
  00058	83 e8 01	 sub	 eax, 1
  0005b	89 45 f0	 mov	 DWORD PTR _width$[ebp], eax

; 132  :   height = db.Height()-1;  // #boxes

  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _db$[ebp]
  00061	e8 00 00 00 00	 call	 ?Height@DOTS_AND_BOXES@@QBEHXZ ; DOTS_AND_BOXES::Height
  00066	83 e8 01	 sub	 eax, 1
  00069	89 45 ec	 mov	 DWORD PTR _height$[ebp], eax

; 133  :   m_neededToWin = width * height/2 + 1;

  0006c	8b 45 f0	 mov	 eax, DWORD PTR _width$[ebp]
  0006f	0f af 45 ec	 imul	 eax, DWORD PTR _height$[ebp]
  00073	99		 cdq
  00074	2b c2		 sub	 eax, edx
  00076	d1 f8		 sar	 eax, 1
  00078	83 c0 01	 add	 eax, 1
  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 134  :   //m_numJoint = width*height;
; 135  :   linksPerRow = 2*width+1;

  00081	8b 55 f0	 mov	 edx, DWORD PTR _width$[ebp]
  00084	8d 44 12 01	 lea	 eax, DWORD PTR [edx+edx+1]
  00088	89 45 e0	 mov	 DWORD PTR _linksPerRow$[ebp], eax

; 136  :   //nd[0].ec = 0;
; 137  :   //nd[0].ix = 0;
; 138  :   //nd[0].os = 0;
; 139  :   Clear(0);

  0008b	6a 00		 push	 0
  0008d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	e8 00 00 00 00	 call	 ?Clear@CON@@QAEXH@Z	; CON::Clear

; 140  :   //nd[1].ec = 0;
; 141  :   //nd[1].ix = 1;
; 142  :   //nd[1].os = 1;
; 143  : 
; 144  :   
; 145  :   // Central rows *********************************************
; 146  :   for (linkStart=width, rowStart=0, row=0; 

  00095	8b 4d f0	 mov	 ecx, DWORD PTR _width$[ebp]
  00098	89 4d dc	 mov	 DWORD PTR _linkStart$[ebp], ecx
  0009b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _rowStart$[ebp], 0
  000a2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _row$[ebp], 0
  000a9	eb 1b		 jmp	 SHORT $LN4@operator
$LN2@operator:

; 148  :        row++, rowStart+=width, linkStart+=linksPerRow)

  000ab	8b 55 f8	 mov	 edx, DWORD PTR _row$[ebp]
  000ae	83 c2 01	 add	 edx, 1
  000b1	89 55 f8	 mov	 DWORD PTR _row$[ebp], edx
  000b4	8b 45 e8	 mov	 eax, DWORD PTR _rowStart$[ebp]
  000b7	03 45 f0	 add	 eax, DWORD PTR _width$[ebp]
  000ba	89 45 e8	 mov	 DWORD PTR _rowStart$[ebp], eax
  000bd	8b 4d dc	 mov	 ecx, DWORD PTR _linkStart$[ebp]
  000c0	03 4d e0	 add	 ecx, DWORD PTR _linksPerRow$[ebp]
  000c3	89 4d dc	 mov	 DWORD PTR _linkStart$[ebp], ecx
$LN4@operator:

; 147  :        row<height; 

  000c6	8b 55 f8	 mov	 edx, DWORD PTR _row$[ebp]
  000c9	3b 55 ec	 cmp	 edx, DWORD PTR _height$[ebp]
  000cc	0f 8d f9 01 00
	00		 jge	 $LN3@operator

; 149  :   {
; 150  :     for (boxNum=rowStart,col=0; col<width; col++,boxNum++)

  000d2	8b 45 e8	 mov	 eax, DWORD PTR _rowStart$[ebp]
  000d5	89 45 e4	 mov	 DWORD PTR _boxNum$[ebp], eax
  000d8	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _col$[ebp], 0
  000df	eb 12		 jmp	 SHORT $LN7@operator
$LN5@operator:
  000e1	8b 4d f4	 mov	 ecx, DWORD PTR _col$[ebp]
  000e4	83 c1 01	 add	 ecx, 1
  000e7	89 4d f4	 mov	 DWORD PTR _col$[ebp], ecx
  000ea	8b 55 e4	 mov	 edx, DWORD PTR _boxNum$[ebp]
  000ed	83 c2 01	 add	 edx, 1
  000f0	89 55 e4	 mov	 DWORD PTR _boxNum$[ebp], edx
$LN7@operator:
  000f3	8b 45 f4	 mov	 eax, DWORD PTR _col$[ebp]
  000f6	3b 45 f0	 cmp	 eax, DWORD PTR _width$[ebp]
  000f9	0f 8d c7 01 00
	00		 jge	 $LN6@operator

; 151  :     {
; 152  : 
; 153  :       if (row == 0)

  000ff	83 7d f8 00	 cmp	 DWORD PTR _row$[ebp], 0
  00103	75 38		 jne	 SHORT $LN14@operator

; 154  :       {
; 155  :         if (col < width-1) 

  00105	8b 4d f0	 mov	 ecx, DWORD PTR _width$[ebp]
  00108	83 e9 01	 sub	 ecx, 1
  0010b	39 4d f4	 cmp	 DWORD PTR _col$[ebp], ecx
  0010e	7d 0f		 jge	 SHORT $LN15@operator

; 156  :         {
; 157  :           Clear(boxNum+1);

  00110	8b 55 e4	 mov	 edx, DWORD PTR _boxNum$[ebp]
  00113	83 c2 01	 add	 edx, 1
  00116	52		 push	 edx
  00117	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	e8 00 00 00 00	 call	 ?Clear@CON@@QAEXH@Z	; CON::Clear
$LN15@operator:

; 158  :         };
; 159  :         if (db.HLineType(col, 0) == LINE_NONE) AddGround(col);

  0011f	6a 00		 push	 0
  00121	8b 45 f4	 mov	 eax, DWORD PTR _col$[ebp]
  00124	50		 push	 eax
  00125	8b 4d 08	 mov	 ecx, DWORD PTR _db$[ebp]
  00128	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  0012d	85 c0		 test	 eax, eax
  0012f	75 0c		 jne	 SHORT $LN14@operator
  00131	8b 4d f4	 mov	 ecx, DWORD PTR _col$[ebp]
  00134	51		 push	 ecx
  00135	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00138	e8 00 00 00 00	 call	 ?AddGround@CON@@QAEXH@Z	; CON::AddGround
$LN14@operator:

; 160  :       };
; 161  : 
; 162  :       
; 163  :       if (row < height-1)

  0013d	8b 55 ec	 mov	 edx, DWORD PTR _height$[ebp]
  00140	83 ea 01	 sub	 edx, 1
  00143	39 55 f8	 cmp	 DWORD PTR _row$[ebp], edx
  00146	0f 8d be 00 00
	00		 jge	 $LN17@operator

; 164  :       {
; 165  :       
; 166  :         Clear(boxNum+width);

  0014c	8b 45 e4	 mov	 eax, DWORD PTR _boxNum$[ebp]
  0014f	03 45 f0	 add	 eax, DWORD PTR _width$[ebp]
  00152	50		 push	 eax
  00153	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00156	e8 00 00 00 00	 call	 ?Clear@CON@@QAEXH@Z	; CON::Clear

; 167  :         if (db.HLineType(col, row+1) == LINE_NONE) 

  0015b	8b 4d f8	 mov	 ecx, DWORD PTR _row$[ebp]
  0015e	83 c1 01	 add	 ecx, 1
  00161	51		 push	 ecx
  00162	8b 55 f4	 mov	 edx, DWORD PTR _col$[ebp]
  00165	52		 push	 edx
  00166	8b 4d 08	 mov	 ecx, DWORD PTR _db$[ebp]
  00169	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  0016e	85 c0		 test	 eax, eax
  00170	75 13		 jne	 SHORT $LN19@operator

; 168  :                          AddLink(boxNum, boxNum+width);

  00172	8b 45 e4	 mov	 eax, DWORD PTR _boxNum$[ebp]
  00175	03 45 f0	 add	 eax, DWORD PTR _width$[ebp]
  00178	50		 push	 eax
  00179	8b 4d e4	 mov	 ecx, DWORD PTR _boxNum$[ebp]
  0017c	51		 push	 ecx
  0017d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00180	e8 00 00 00 00	 call	 ?AddLink@CON@@QAEXHH@Z	; CON::AddLink
$LN19@operator:

; 169  :         if (col == 0)

  00185	83 7d f4 00	 cmp	 DWORD PTR _col$[ebp], 0
  00189	75 20		 jne	 SHORT $LN20@operator

; 170  :         {
; 171  :           if (db.VLineType(col, row) == LINE_NONE) AddGround(boxNum);

  0018b	8b 55 f8	 mov	 edx, DWORD PTR _row$[ebp]
  0018e	52		 push	 edx
  0018f	8b 45 f4	 mov	 eax, DWORD PTR _col$[ebp]
  00192	50		 push	 eax
  00193	8b 4d 08	 mov	 ecx, DWORD PTR _db$[ebp]
  00196	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  0019b	85 c0		 test	 eax, eax
  0019d	75 0c		 jne	 SHORT $LN20@operator
  0019f	8b 4d e4	 mov	 ecx, DWORD PTR _boxNum$[ebp]
  001a2	51		 push	 ecx
  001a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a6	e8 00 00 00 00	 call	 ?AddGround@CON@@QAEXH@Z	; CON::AddGround
$LN20@operator:

; 172  :         };
; 173  :         if (col < width-1)

  001ab	8b 55 f0	 mov	 edx, DWORD PTR _width$[ebp]
  001ae	83 ea 01	 sub	 edx, 1
  001b1	39 55 f4	 cmp	 DWORD PTR _col$[ebp], edx
  001b4	7d 2c		 jge	 SHORT $LN22@operator

; 174  :         {
; 175  :           if (db.VLineType(col+1, row) == LINE_NONE) AddLink(boxNum, boxNum+1);

  001b6	8b 45 f8	 mov	 eax, DWORD PTR _row$[ebp]
  001b9	50		 push	 eax
  001ba	8b 4d f4	 mov	 ecx, DWORD PTR _col$[ebp]
  001bd	83 c1 01	 add	 ecx, 1
  001c0	51		 push	 ecx
  001c1	8b 4d 08	 mov	 ecx, DWORD PTR _db$[ebp]
  001c4	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  001c9	85 c0		 test	 eax, eax
  001cb	75 13		 jne	 SHORT $LN24@operator
  001cd	8b 55 e4	 mov	 edx, DWORD PTR _boxNum$[ebp]
  001d0	83 c2 01	 add	 edx, 1
  001d3	52		 push	 edx
  001d4	8b 45 e4	 mov	 eax, DWORD PTR _boxNum$[ebp]
  001d7	50		 push	 eax
  001d8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001db	e8 00 00 00 00	 call	 ?AddLink@CON@@QAEXHH@Z	; CON::AddLink
$LN24@operator:

; 176  :         }

  001e0	eb 23		 jmp	 SHORT $LN23@operator
$LN22@operator:

; 177  :         else
; 178  :         {
; 179  :           if (db.VLineType(col+1, row) == LINE_NONE) AddGround(boxNum);

  001e2	8b 4d f8	 mov	 ecx, DWORD PTR _row$[ebp]
  001e5	51		 push	 ecx
  001e6	8b 55 f4	 mov	 edx, DWORD PTR _col$[ebp]
  001e9	83 c2 01	 add	 edx, 1
  001ec	52		 push	 edx
  001ed	8b 4d 08	 mov	 ecx, DWORD PTR _db$[ebp]
  001f0	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  001f5	85 c0		 test	 eax, eax
  001f7	75 0c		 jne	 SHORT $LN23@operator
  001f9	8b 45 e4	 mov	 eax, DWORD PTR _boxNum$[ebp]
  001fc	50		 push	 eax
  001fd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00200	e8 00 00 00 00	 call	 ?AddGround@CON@@QAEXH@Z	; CON::AddGround
$LN23@operator:

; 180  :         };
; 181  :       }

  00205	e9 b7 00 00 00	 jmp	 $LN18@operator
$LN17@operator:

; 182  :       else
; 183  :       {
; 184  : 
; 185  :         if (db.HLineType(col, row+1) == LINE_NONE) AddGround(boxNum);

  0020a	8b 4d f8	 mov	 ecx, DWORD PTR _row$[ebp]
  0020d	83 c1 01	 add	 ecx, 1
  00210	51		 push	 ecx
  00211	8b 55 f4	 mov	 edx, DWORD PTR _col$[ebp]
  00214	52		 push	 edx
  00215	8b 4d 08	 mov	 ecx, DWORD PTR _db$[ebp]
  00218	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  0021d	85 c0		 test	 eax, eax
  0021f	75 0c		 jne	 SHORT $LN26@operator
  00221	8b 45 e4	 mov	 eax, DWORD PTR _boxNum$[ebp]
  00224	50		 push	 eax
  00225	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00228	e8 00 00 00 00	 call	 ?AddGround@CON@@QAEXH@Z	; CON::AddGround
$LN26@operator:

; 186  :         if (col == 0)

  0022d	83 7d f4 00	 cmp	 DWORD PTR _col$[ebp], 0
  00231	75 20		 jne	 SHORT $LN27@operator

; 187  :         {
; 188  :           if (db.VLineType(col, row) == LINE_NONE) AddGround(boxNum);

  00233	8b 4d f8	 mov	 ecx, DWORD PTR _row$[ebp]
  00236	51		 push	 ecx
  00237	8b 55 f4	 mov	 edx, DWORD PTR _col$[ebp]
  0023a	52		 push	 edx
  0023b	8b 4d 08	 mov	 ecx, DWORD PTR _db$[ebp]
  0023e	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  00243	85 c0		 test	 eax, eax
  00245	75 0c		 jne	 SHORT $LN27@operator
  00247	8b 45 e4	 mov	 eax, DWORD PTR _boxNum$[ebp]
  0024a	50		 push	 eax
  0024b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0024e	e8 00 00 00 00	 call	 ?AddGround@CON@@QAEXH@Z	; CON::AddGround
$LN27@operator:

; 189  :         };
; 190  :         if (col < width-1)

  00253	8b 4d f0	 mov	 ecx, DWORD PTR _width$[ebp]
  00256	83 e9 01	 sub	 ecx, 1
  00259	39 4d f4	 cmp	 DWORD PTR _col$[ebp], ecx
  0025c	7d 40		 jge	 SHORT $LN29@operator

; 191  :         {
; 192  :           if (row == 0)

  0025e	83 7d f8 00	 cmp	 DWORD PTR _row$[ebp], 0
  00262	75 0e		 jne	 SHORT $LN31@operator

; 193  :           {
; 194  :             nd[boxNum+1].ec = 0;

  00264	8b 55 e4	 mov	 edx, DWORD PTR _boxNum$[ebp]
  00267	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0026a	c6 84 90 14 10
	00 00 00	 mov	 BYTE PTR [eax+edx*4+4116], 0
$LN31@operator:

; 195  :           };
; 196  :           if (db.VLineType(col+1, row) == LINE_NONE) AddLink(boxNum, boxNum+1);

  00272	8b 4d f8	 mov	 ecx, DWORD PTR _row$[ebp]
  00275	51		 push	 ecx
  00276	8b 55 f4	 mov	 edx, DWORD PTR _col$[ebp]
  00279	83 c2 01	 add	 edx, 1
  0027c	52		 push	 edx
  0027d	8b 4d 08	 mov	 ecx, DWORD PTR _db$[ebp]
  00280	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  00285	85 c0		 test	 eax, eax
  00287	75 13		 jne	 SHORT $LN32@operator
  00289	8b 45 e4	 mov	 eax, DWORD PTR _boxNum$[ebp]
  0028c	83 c0 01	 add	 eax, 1
  0028f	50		 push	 eax
  00290	8b 4d e4	 mov	 ecx, DWORD PTR _boxNum$[ebp]
  00293	51		 push	 ecx
  00294	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00297	e8 00 00 00 00	 call	 ?AddLink@CON@@QAEXHH@Z	; CON::AddLink
$LN32@operator:

; 197  :         }

  0029c	eb 23		 jmp	 SHORT $LN18@operator
$LN29@operator:

; 198  :         else
; 199  :         {
; 200  :           if (db.VLineType(col+1, row) == LINE_NONE) AddGround(boxNum);

  0029e	8b 55 f8	 mov	 edx, DWORD PTR _row$[ebp]
  002a1	52		 push	 edx
  002a2	8b 45 f4	 mov	 eax, DWORD PTR _col$[ebp]
  002a5	83 c0 01	 add	 eax, 1
  002a8	50		 push	 eax
  002a9	8b 4d 08	 mov	 ecx, DWORD PTR _db$[ebp]
  002ac	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  002b1	85 c0		 test	 eax, eax
  002b3	75 0c		 jne	 SHORT $LN18@operator
  002b5	8b 4d e4	 mov	 ecx, DWORD PTR _boxNum$[ebp]
  002b8	51		 push	 ecx
  002b9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002bc	e8 00 00 00 00	 call	 ?AddGround@CON@@QAEXH@Z	; CON::AddGround
$LN18@operator:

; 201  :         };
; 202  :       };
; 203  :     };

  002c1	e9 1b fe ff ff	 jmp	 $LN5@operator
$LN6@operator:

; 204  :   };

  002c6	e9 e0 fd ff ff	 jmp	 $LN2@operator
$LN3@operator:

; 205  :   m_numNode = width*height; 

  002cb	8b 55 f0	 mov	 edx, DWORD PTR _width$[ebp]
  002ce	0f af 55 ec	 imul	 edx, DWORD PTR _height$[ebp]
  002d2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002d5	89 10		 mov	 DWORD PTR [eax], edx

; 206  :   Compress();//Remove unused nodes.

  002d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002da	e8 00 00 00 00	 call	 ?Compress@CON@@QAEXXZ	; CON::Compress

; 207  : #ifdef NS_DUMP
; 208  : //  DUMP("About to form chains",0,0,0,0,m_numNode);
; 209  : #endif
; 210  :   _FormChains();

  002df	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002e2	e8 00 00 00 00	 call	 ?_FormChains@CON@@QAEXXZ ; CON::_FormChains

; 211  : #ifdef NS_DUMP
; 212  : //  DUMP("Finished forming chains",0,0,0,0,m_numNode);
; 213  : #endif
; 214  :   Canon(0,m_numNode);

  002e7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002ea	8b 11		 mov	 edx, DWORD PTR [ecx]
  002ec	52		 push	 edx
  002ed	6a 00		 push	 0
  002ef	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002f2	e8 00 00 00 00	 call	 ?Canon@CON@@QAEXHH@Z	; CON::Canon

; 215  : #ifdef _CHECK
; 216  :   CheckEverything(0,m_numNode,false);
; 217  : #endif
; 218  :   {
; 219  :     ui count = 0;

  002f7	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _count$6[ebp], 0

; 220  :     int nn, nnA, nnB, en;
; 221  :     for (nn=0; nn<m_numNode; nn++)

  002fe	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _nn$5[ebp], 0
  00305	eb 09		 jmp	 SHORT $LN10@operator
$LN8@operator:
  00307	8b 45 d4	 mov	 eax, DWORD PTR _nn$5[ebp]
  0030a	83 c0 01	 add	 eax, 1
  0030d	89 45 d4	 mov	 DWORD PTR _nn$5[ebp], eax
$LN10@operator:
  00310	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00313	8b 55 d4	 mov	 edx, DWORD PTR _nn$5[ebp]
  00316	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00318	0f 8d e2 00 00
	00		 jge	 $LN9@operator

; 222  :     {
; 223  :       nnA = nd[nn].ix;

  0031e	8b 45 d4	 mov	 eax, DWORD PTR _nn$5[ebp]
  00321	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00324	0f b6 94 81 13
	10 00 00	 movzx	 edx, BYTE PTR [ecx+eax*4+4115]
  0032c	89 55 d0	 mov	 DWORD PTR _nnA$4[ebp], edx

; 224  :       if (IS_ISOLATED(sd[nnA][0].ns))

  0032f	8b 45 d0	 mov	 eax, DWORD PTR _nnA$4[ebp]
  00332	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00335	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  0033c	b8 02 00 00 00	 mov	 eax, 2
  00341	6b c8 00	 imul	 ecx, eax, 0
  00344	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  00348	81 fa fa 00 00
	00		 cmp	 edx, 250		; 000000faH
  0034e	7e 25		 jle	 SHORT $LN34@operator

; 225  :       {
; 226  :         count += 2*ed[nnA].e[0].el;

  00350	8b 45 d0	 mov	 eax, DWORD PTR _nnA$4[ebp]
  00353	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00356	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  0035a	b8 02 00 00 00	 mov	 eax, 2
  0035f	6b c8 00	 imul	 ecx, eax, 0
  00362	0f b6 54 0a 01	 movzx	 edx, BYTE PTR [edx+ecx+1]
  00367	8b 45 d8	 mov	 eax, DWORD PTR _count$6[ebp]
  0036a	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0036d	89 4d d8	 mov	 DWORD PTR _count$6[ebp], ecx

; 227  :       }

  00370	e9 86 00 00 00	 jmp	 $LN35@operator
$LN34@operator:

; 228  :       else
; 229  :       {
; 230  :         int ec;
; 231  :         count += 2;

  00375	8b 55 d8	 mov	 edx, DWORD PTR _count$6[ebp]
  00378	83 c2 02	 add	 edx, 2
  0037b	89 55 d8	 mov	 DWORD PTR _count$6[ebp], edx

; 232  :         ec = nd[nnA].ec;

  0037e	8b 45 d0	 mov	 eax, DWORD PTR _nnA$4[ebp]
  00381	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00384	0f b6 94 81 10
	10 00 00	 movzx	 edx, BYTE PTR [ecx+eax*4+4112]
  0038c	89 55 c4	 mov	 DWORD PTR _ec$1[ebp], edx

; 233  :         for (en=0; en<ec; en++)

  0038f	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _en$2[ebp], 0
  00396	eb 09		 jmp	 SHORT $LN13@operator
$LN11@operator:
  00398	8b 45 c8	 mov	 eax, DWORD PTR _en$2[ebp]
  0039b	83 c0 01	 add	 eax, 1
  0039e	89 45 c8	 mov	 DWORD PTR _en$2[ebp], eax
$LN13@operator:
  003a1	8b 4d c8	 mov	 ecx, DWORD PTR _en$2[ebp]
  003a4	3b 4d c4	 cmp	 ecx, DWORD PTR _ec$1[ebp]
  003a7	7d 52		 jge	 SHORT $LN35@operator

; 234  :         {
; 235  :           nnB = sd[nnA][en].ns;

  003a9	8b 55 d0	 mov	 edx, DWORD PTR _nnA$4[ebp]
  003ac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003af	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  003b6	8b 55 c8	 mov	 edx, DWORD PTR _en$2[ebp]
  003b9	0f b6 04 51	 movzx	 eax, BYTE PTR [ecx+edx*2]
  003bd	89 45 cc	 mov	 DWORD PTR _nnB$3[ebp], eax

; 236  :           if (!IS_A_NODE(nnB))

  003c0	81 7d cc f9 00
	00 00		 cmp	 DWORD PTR _nnB$3[ebp], 249 ; 000000f9H
  003c7	7c 18		 jl	 SHORT $LN36@operator

; 237  :           {
; 238  :             count += ed[nnA].e[en].el;

  003c9	8b 4d d0	 mov	 ecx, DWORD PTR _nnA$4[ebp]
  003cc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003cf	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  003d3	8b 4d c8	 mov	 ecx, DWORD PTR _en$2[ebp]
  003d6	0f b6 54 48 01	 movzx	 edx, BYTE PTR [eax+ecx*2+1]
  003db	03 55 d8	 add	 edx, DWORD PTR _count$6[ebp]
  003de	89 55 d8	 mov	 DWORD PTR _count$6[ebp], edx
$LN36@operator:

; 239  :           };
; 240  :           count += ed[nnA].e[en].el;

  003e1	8b 45 d0	 mov	 eax, DWORD PTR _nnA$4[ebp]
  003e4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003e7	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  003eb	8b 45 c8	 mov	 eax, DWORD PTR _en$2[ebp]
  003ee	0f b6 4c 42 01	 movzx	 ecx, BYTE PTR [edx+eax*2+1]
  003f3	03 4d d8	 add	 ecx, DWORD PTR _count$6[ebp]
  003f6	89 4d d8	 mov	 DWORD PTR _count$6[ebp], ecx

; 241  :         };

  003f9	eb 9d		 jmp	 SHORT $LN11@operator
$LN35@operator:

; 242  :       };
; 243  :     };

  003fb	e9 07 ff ff ff	 jmp	 $LN8@operator
$LN9@operator:

; 244  :     m_coinsRemaining = count/2;

  00400	8b 55 d8	 mov	 edx, DWORD PTR _count$6[ebp]
  00403	d1 ea		 shr	 edx, 1
  00405	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00408	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 245  :   };
; 246  : #ifdef _CHECK
; 247  :   CheckEverything(0, m_numNode, false);
; 248  : #endif
; 249  :   return *this;

  0040b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 250  : }

  0040e	5f		 pop	 edi
  0040f	83 c4 3c	 add	 esp, 60			; 0000003cH
  00412	3b ec		 cmp	 ebp, esp
  00414	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00419	8b e5		 mov	 esp, ebp
  0041b	5d		 pop	 ebp
  0041c	c2 04 00	 ret	 4
??4CON@@QAEAAV0@ABVDOTS_AND_BOXES@@@Z ENDP		; CON::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Translate.cpp
_TEXT	SEGMENT
_en$ = -8						; size = 4
_this$ = -4						; size = 4
_boxNum$ = 8						; size = 4
?AddGround@CON@@QAEXH@Z PROC				; CON::AddGround
; _this$ = ecx

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 11   :   int en;
; 12   :   ASSERT(nd[boxNum].ec < 4);

  00017	8b 45 08	 mov	 eax, DWORD PTR _boxNum$[ebp]
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	0f b6 94 81 10
	10 00 00	 movzx	 edx, BYTE PTR [ecx+eax*4+4112]
  00025	83 fa 04	 cmp	 edx, 4
  00028	7c 11		 jl	 SHORT $LN3@AddGround
  0002a	6a 0c		 push	 12			; 0000000cH
  0002c	68 00 00 00 00	 push	 OFFSET $SG225416
  00031	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00036	85 c0		 test	 eax, eax
  00038	74 01		 je	 SHORT $LN3@AddGround
  0003a	cc		 int	 3
$LN3@AddGround:

; 13   :   en = nd[boxNum].ec++;

  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _boxNum$[ebp]
  0003e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00041	0f b6 84 8a 10
	10 00 00	 movzx	 eax, BYTE PTR [edx+ecx*4+4112]
  00049	89 45 f8	 mov	 DWORD PTR _en$[ebp], eax
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _boxNum$[ebp]
  0004f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00052	0f b6 84 8a 10
	10 00 00	 movzx	 eax, BYTE PTR [edx+ecx*4+4112]
  0005a	04 01		 add	 al, 1
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _boxNum$[ebp]
  0005f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00062	88 84 8a 10 10
	00 00		 mov	 BYTE PTR [edx+ecx*4+4112], al

; 14   :   sd[boxNum][en].ns = GROUND;

  00069	8b 45 08	 mov	 eax, DWORD PTR _boxNum$[ebp]
  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  00076	8b 45 f8	 mov	 eax, DWORD PTR _en$[ebp]
  00079	c6 04 42 fa	 mov	 BYTE PTR [edx+eax*2], 250 ; 000000faH

; 15   :   sd[boxNum][en].ne = UNUSED;

  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _boxNum$[ebp]
  00080	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00083	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  0008a	8b 4d f8	 mov	 ecx, DWORD PTR _en$[ebp]
  0008d	c6 44 48 01 ff	 mov	 BYTE PTR [eax+ecx*2+1], 255 ; 000000ffH

; 16   :   ed[boxNum].e[en].el = 0;

  00092	8b 55 08	 mov	 edx, DWORD PTR _boxNum$[ebp]
  00095	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00098	8d 4c d0 10	 lea	 ecx, DWORD PTR [eax+edx*8+16]
  0009c	8b 55 f8	 mov	 edx, DWORD PTR _en$[ebp]
  0009f	c6 44 51 01 00	 mov	 BYTE PTR [ecx+edx*2+1], 0

; 17   :   ed[boxNum].e[en].ng = GROUND;

  000a4	8b 45 08	 mov	 eax, DWORD PTR _boxNum$[ebp]
  000a7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  000ae	8b 45 f8	 mov	 eax, DWORD PTR _en$[ebp]
  000b1	c6 04 42 fa	 mov	 BYTE PTR [edx+eax*2], 250 ; 000000faH

; 18   : }

  000b5	83 c4 08	 add	 esp, 8
  000b8	3b ec		 cmp	 ebp, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c2 04 00	 ret	 4
?AddGround@CON@@QAEXH@Z ENDP				; CON::AddGround
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Translate.cpp
_TEXT	SEGMENT
_en2$ = -12						; size = 4
_en1$ = -8						; size = 4
_this$ = -4						; size = 4
_boxNum1$ = 8						; size = 4
_boxNum2$ = 12						; size = 4
?AddLink@CON@@QAEXHH@Z PROC				; CON::AddLink
; _this$ = ecx

; 23   : { // 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 24   :   int en1, en2;
; 25   :   ASSERT(nd[boxNum1].ec < 4);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _boxNum1$[ebp]
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	0f b6 94 81 10
	10 00 00	 movzx	 edx, BYTE PTR [ecx+eax*4+4112]
  0002c	83 fa 04	 cmp	 edx, 4
  0002f	7c 11		 jl	 SHORT $LN3@AddLink
  00031	6a 19		 push	 25			; 00000019H
  00033	68 00 00 00 00	 push	 OFFSET $SG225432
  00038	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0003d	85 c0		 test	 eax, eax
  0003f	74 01		 je	 SHORT $LN3@AddLink
  00041	cc		 int	 3
$LN3@AddLink:

; 26   :   ASSERT(nd[boxNum2].ec < 4);

  00042	8b 4d 0c	 mov	 ecx, DWORD PTR _boxNum2$[ebp]
  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	0f b6 84 8a 10
	10 00 00	 movzx	 eax, BYTE PTR [edx+ecx*4+4112]
  00050	83 f8 04	 cmp	 eax, 4
  00053	7c 11		 jl	 SHORT $LN4@AddLink
  00055	6a 1a		 push	 26			; 0000001aH
  00057	68 00 00 00 00	 push	 OFFSET $SG225433
  0005c	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00061	85 c0		 test	 eax, eax
  00063	74 01		 je	 SHORT $LN4@AddLink
  00065	cc		 int	 3
$LN4@AddLink:

; 27   :   en1 = nd[boxNum1].ec++;

  00066	8b 55 08	 mov	 edx, DWORD PTR _boxNum1$[ebp]
  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	0f b6 8c 90 10
	10 00 00	 movzx	 ecx, BYTE PTR [eax+edx*4+4112]
  00074	89 4d f8	 mov	 DWORD PTR _en1$[ebp], ecx
  00077	8b 55 08	 mov	 edx, DWORD PTR _boxNum1$[ebp]
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	8a 8c 90 10 10
	00 00		 mov	 cl, BYTE PTR [eax+edx*4+4112]
  00084	80 c1 01	 add	 cl, 1
  00087	8b 55 08	 mov	 edx, DWORD PTR _boxNum1$[ebp]
  0008a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008d	88 8c 90 10 10
	00 00		 mov	 BYTE PTR [eax+edx*4+4112], cl

; 28   :   en2 = nd[boxNum2].ec++;

  00094	8b 4d 0c	 mov	 ecx, DWORD PTR _boxNum2$[ebp]
  00097	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009a	0f b6 84 8a 10
	10 00 00	 movzx	 eax, BYTE PTR [edx+ecx*4+4112]
  000a2	89 45 f4	 mov	 DWORD PTR _en2$[ebp], eax
  000a5	8b 4d 0c	 mov	 ecx, DWORD PTR _boxNum2$[ebp]
  000a8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ab	8a 84 8a 10 10
	00 00		 mov	 al, BYTE PTR [edx+ecx*4+4112]
  000b2	04 01		 add	 al, 1
  000b4	8b 4d 0c	 mov	 ecx, DWORD PTR _boxNum2$[ebp]
  000b7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ba	88 84 8a 10 10
	00 00		 mov	 BYTE PTR [edx+ecx*4+4112], al

; 29   :   sd[boxNum1][en1].ns = (STOPNUM)boxNum2;

  000c1	8b 45 08	 mov	 eax, DWORD PTR _boxNum1$[ebp]
  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  000ce	8b 45 f8	 mov	 eax, DWORD PTR _en1$[ebp]
  000d1	8a 4d 0c	 mov	 cl, BYTE PTR _boxNum2$[ebp]
  000d4	88 0c 42	 mov	 BYTE PTR [edx+eax*2], cl

; 30   :   ed[boxNum1].e[en1].ng = (STOPNUM)boxNum2;

  000d7	8b 55 08	 mov	 edx, DWORD PTR _boxNum1$[ebp]
  000da	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dd	8d 4c d0 10	 lea	 ecx, DWORD PTR [eax+edx*8+16]
  000e1	8b 55 f8	 mov	 edx, DWORD PTR _en1$[ebp]
  000e4	8a 45 0c	 mov	 al, BYTE PTR _boxNum2$[ebp]
  000e7	88 04 51	 mov	 BYTE PTR [ecx+edx*2], al

; 31   :   sd[boxNum1][en1].ne = (EDGENUM)en2;

  000ea	8b 4d 08	 mov	 ecx, DWORD PTR _boxNum1$[ebp]
  000ed	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f0	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  000f7	8b 4d f8	 mov	 ecx, DWORD PTR _en1$[ebp]
  000fa	8a 55 f4	 mov	 dl, BYTE PTR _en2$[ebp]
  000fd	88 54 48 01	 mov	 BYTE PTR [eax+ecx*2+1], dl

; 32   :   ed[boxNum1].e[en1].el = 0;

  00101	8b 45 08	 mov	 eax, DWORD PTR _boxNum1$[ebp]
  00104	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00107	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  0010b	8b 45 f8	 mov	 eax, DWORD PTR _en1$[ebp]
  0010e	c6 44 42 01 00	 mov	 BYTE PTR [edx+eax*2+1], 0

; 33   :   sd[boxNum2][en2].ns = (STOPNUM)boxNum1;

  00113	8b 4d 0c	 mov	 ecx, DWORD PTR _boxNum2$[ebp]
  00116	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00119	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  00120	8b 4d f4	 mov	 ecx, DWORD PTR _en2$[ebp]
  00123	8a 55 08	 mov	 dl, BYTE PTR _boxNum1$[ebp]
  00126	88 14 48	 mov	 BYTE PTR [eax+ecx*2], dl

; 34   :   ed[boxNum2].e[en2].ng = (STOPNUM)boxNum1;

  00129	8b 45 0c	 mov	 eax, DWORD PTR _boxNum2$[ebp]
  0012c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012f	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  00133	8b 45 f4	 mov	 eax, DWORD PTR _en2$[ebp]
  00136	8a 4d 08	 mov	 cl, BYTE PTR _boxNum1$[ebp]
  00139	88 0c 42	 mov	 BYTE PTR [edx+eax*2], cl

; 35   :   sd[boxNum2][en2].ne = (EDGENUM)en1;

  0013c	8b 55 0c	 mov	 edx, DWORD PTR _boxNum2$[ebp]
  0013f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00142	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  00149	8b 55 f4	 mov	 edx, DWORD PTR _en2$[ebp]
  0014c	0f b6 45 f8	 movzx	 eax, BYTE PTR _en1$[ebp]
  00150	88 44 51 01	 mov	 BYTE PTR [ecx+edx*2+1], al

; 36   :   ed[boxNum2].e[en2].el = 0;

  00154	8b 4d 0c	 mov	 ecx, DWORD PTR _boxNum2$[ebp]
  00157	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0015a	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  0015e	8b 4d f4	 mov	 ecx, DWORD PTR _en2$[ebp]
  00161	c6 44 48 01 00	 mov	 BYTE PTR [eax+ecx*2+1], 0

; 37   : }

  00166	83 c4 0c	 add	 esp, 12			; 0000000cH
  00169	3b ec		 cmp	 ebp, esp
  0016b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00170	8b e5		 mov	 esp, ebp
  00172	5d		 pop	 ebp
  00173	c2 08 00	 ret	 8
?AddLink@CON@@QAEXHH@Z ENDP				; CON::AddLink
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\NIMCON.h
;	COMDAT ?Clear@CON@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nn$ = 8						; size = 4
?Clear@CON@@QAEXH@Z PROC				; CON::Clear, COMDAT
; _this$ = ecx

; 239  :   {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 240  :     nd[nn].Clear();

  0000e	8b 45 08	 mov	 eax, DWORD PTR _nn$[ebp]
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8d 8c 81 10 10
	00 00		 lea	 ecx, DWORD PTR [ecx+eax*4+4112]
  0001b	e8 00 00 00 00	 call	 ?Clear@NODEDATA@@QAEXXZ	; NODEDATA::Clear

; 241  :     *((ui64 *)sd[nn]) = UNUSED8;

  00020	8b 55 08	 mov	 edx, DWORD PTR _nn$[ebp]
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 c9 ff	 or	 ecx, -1
  00029	c7 84 d0 10 08
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [eax+edx*8+2064], -1
  00034	89 8c d0 14 08
	00 00		 mov	 DWORD PTR [eax+edx*8+2068], ecx

; 242  :     ed[nn].Clear();

  0003b	8b 55 08	 mov	 edx, DWORD PTR _nn$[ebp]
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8d 4c d0 10	 lea	 ecx, DWORD PTR [eax+edx*8+16]
  00045	e8 00 00 00 00	 call	 ?Clear@EDGEDATA@@QAEXXZ	; EDGEDATA::Clear

; 243  :     nd[nn].ix = (STOPNUM)nn;

  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _nn$[ebp]
  0004d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00050	8a 45 08	 mov	 al, BYTE PTR _nn$[ebp]
  00053	88 84 8a 13 10
	00 00		 mov	 BYTE PTR [edx+ecx*4+4115], al

; 244  :     nd[nn].os = (STOPNUM)nn;

  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _nn$[ebp]
  0005d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00060	0f b6 45 08	 movzx	 eax, BYTE PTR _nn$[ebp]
  00064	88 84 8a 12 10
	00 00		 mov	 BYTE PTR [edx+ecx*4+4114], al

; 245  :   };

  0006b	83 c4 04	 add	 esp, 4
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
?Clear@CON@@QAEXH@Z ENDP				; CON::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\NIMCON.h
;	COMDAT ?Clear@NODEDATA@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@NODEDATA@@QAEXXZ PROC				; NODEDATA::Clear, COMDAT
; _this$ = ecx

; 195  :   inline void Clear(void){*((ui32 *)this)=UNUSED4;ec=0;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?Clear@NODEDATA@@QAEXXZ ENDP				; NODEDATA::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\NIMCON.h
;	COMDAT ?Clear@EDGEDATA@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@EDGEDATA@@QAEXXZ PROC				; EDGEDATA::Clear, COMDAT
; _this$ = ecx

; 175  :   inline void Clear(void){*((ui64 *)this)=UNUSED8;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c9 ff	 or	 ecx, -1
  0000d	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00013	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?Clear@EDGEDATA@@QAEXXZ ENDP				; EDGEDATA::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_col$ = 8						; size = 4
_row$ = 12						; size = 4
?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z PROC	; DOTS_AND_BOXES::HLineType, COMDAT
; _this$ = ecx

; 101  :   INLINE LINE_TYPE HLineType(int col, int row)const{return (LINE_TYPE)m_hlines[row*(m_width-1) + col];};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000d	83 e9 01	 sub	 ecx, 1
  00010	0f af 4d 0c	 imul	 ecx, DWORD PTR _row$[ebp]
  00014	03 4d 08	 add	 ecx, DWORD PTR _col$[ebp]
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001d	0f b6 04 08	 movzx	 eax, BYTE PTR [eax+ecx]
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ENDP	; DOTS_AND_BOXES::HLineType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_col$ = 8						; size = 4
_row$ = 12						; size = 4
?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z PROC	; DOTS_AND_BOXES::VLineType, COMDAT
; _this$ = ecx

; 97   :   INLINE LINE_TYPE VLineType(int col, int row)const{return (LINE_TYPE)m_vlines[row*m_width + col];};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _row$[ebp]
  0000d	0f af 48 10	 imul	 ecx, DWORD PTR [eax+16]
  00011	03 4d 08	 add	 ecx, DWORD PTR _col$[ebp]
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0001a	0f b6 04 08	 movzx	 eax, BYTE PTR [eax+ecx]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ENDP	; DOTS_AND_BOXES::VLineType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?Height@DOTS_AND_BOXES@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Height@DOTS_AND_BOXES@@QBEHXZ PROC			; DOTS_AND_BOXES::Height, COMDAT
; _this$ = ecx

; 93   :   INLINE int Height(void) const {return m_height;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Height@DOTS_AND_BOXES@@QBEHXZ ENDP			; DOTS_AND_BOXES::Height
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?Width@DOTS_AND_BOXES@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Width@DOTS_AND_BOXES@@QBEHXZ PROC			; DOTS_AND_BOXES::Width, COMDAT
; _this$ = ecx

; 92   :   INLINE int Width(void) const {return m_width;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Width@DOTS_AND_BOXES@@QBEHXZ ENDP			; DOTS_AND_BOXES::Width
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File G:\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\atlmfc\include\afx.h
;	COMDAT ?AfxAssertFailedLine@@YGHPBDH@Z
_TEXT	SEGMENT
_bResult$ = -44						; size = 4
_bQuit$ = -40						; size = 4
_msg$ = -32						; size = 28
_lpszFileName$ = 8					; size = 4
_nLine$ = 12						; size = 4
?AfxAssertFailedLine@@YGHPBDH@Z PROC			; AfxAssertFailedLine, COMDAT

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d d4	 lea	 edi, DWORD PTR [ebp-44]
  0000b	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd

; 313  : 	// we remove WM_QUIT because if it is in the queue then the message box
; 314  : 	// won't display
; 315  : 	MSG msg;
; 316  : 	BOOL bQuit = PeekMessage(&msg, NULL, WM_QUIT, WM_QUIT, PM_REMOVE);

  00017	8b f4		 mov	 esi, esp
  00019	6a 01		 push	 1
  0001b	6a 12		 push	 18			; 00000012H
  0001d	6a 12		 push	 18			; 00000012H
  0001f	6a 00		 push	 0
  00021	8d 45 e0	 lea	 eax, DWORD PTR _msg$[ebp]
  00024	50		 push	 eax
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PeekMessageA@20
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00032	89 45 d8	 mov	 DWORD PTR _bQuit$[ebp], eax

; 317  : 	BOOL bResult = _CrtDbgReport(_CRT_ASSERT, lpszFileName, nLine, NULL, NULL);

  00035	8b f4		 mov	 esi, esp
  00037	6a 00		 push	 0
  00039	6a 00		 push	 0
  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _nLine$[ebp]
  0003e	51		 push	 ecx
  0003f	8b 55 08	 mov	 edx, DWORD PTR _lpszFileName$[ebp]
  00042	52		 push	 edx
  00043	6a 02		 push	 2
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0004b	83 c4 14	 add	 esp, 20			; 00000014H
  0004e	3b f4		 cmp	 esi, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	89 45 d4	 mov	 DWORD PTR _bResult$[ebp], eax

; 318  : 	if (bQuit)

  00058	83 7d d8 00	 cmp	 DWORD PTR _bQuit$[ebp], 0
  0005c	74 13		 je	 SHORT $LN2@AfxAssertF

; 319  : 		PostQuitMessage((int)msg.wParam);

  0005e	8b f4		 mov	 esi, esp
  00060	8b 45 e8	 mov	 eax, DWORD PTR _msg$[ebp+8]
  00063	50		 push	 eax
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4
  0006a	3b f4		 cmp	 esi, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@AfxAssertF:

; 320  : 	return bResult;

  00071	8b 45 d4	 mov	 eax, DWORD PTR _bResult$[ebp]

; 321  : }

  00074	52		 push	 edx
  00075	8b cd		 mov	 ecx, ebp
  00077	50		 push	 eax
  00078	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@AfxAssertF
  0007e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00083	58		 pop	 eax
  00084	5a		 pop	 edx
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	83 c4 2c	 add	 esp, 44			; 0000002cH
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 08 00	 ret	 8
  00097	90		 npad	 1
$LN6@AfxAssertF:
  00098	01 00 00 00	 DD	 1
  0009c	00 00 00 00	 DD	 $LN5@AfxAssertF
$LN5@AfxAssertF:
  000a0	e0 ff ff ff	 DD	 -32			; ffffffe0H
  000a4	1c 00 00 00	 DD	 28			; 0000001cH
  000a8	00 00 00 00	 DD	 $LN4@AfxAssertF
$LN4@AfxAssertF:
  000ac	6d		 DB	 109			; 0000006dH
  000ad	73		 DB	 115			; 00000073H
  000ae	67		 DB	 103			; 00000067H
  000af	00		 DB	 0
?AfxAssertFailedLine@@YGHPBDH@Z ENDP			; AfxAssertFailedLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Translate.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Translate.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
