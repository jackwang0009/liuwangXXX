; Listing generated by Microsoft (R) Optimizing Compiler Version 19.35.32217.1 

	TITLE	C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\Debug\SWEvaluate.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG225452 DB	'Unknown capture type', 00H
	ORG $+3
$SG225539 DB	'C:\Users\15485\Desktop\', 0b9H, 0a4H, 0b3H, 0ccH, 0d6H, 0aeH
	DB	0d0H, 0c7H, 0b5H, 0e3H, 0b8H, 0f1H, 0c6H, 0e5H, '\DotBoxLib\SW'
	DB	'Evaluate.cpp', 00H
	ORG $+1
$SG225540 DB	'C:\Users\15485\Desktop\', 0b9H, 0a4H, 0b3H, 0ccH, 0d6H, 0aeH
	DB	0d0H, 0c7H, 0b5H, 0e3H, 0b8H, 0f1H, 0c6H, 0e5H, '\DotBoxLib\SW'
	DB	'Evaluate.cpp', 00H
	ORG $+1
$SG225589 DB	'Capturable chain not two long', 00H
	ORG $+2
$SG225591 DB	'MoveStackExceeded', 00H
	ORG $+2
$SG225597 DB	'Capturable chain not four long', 00H
	ORG $+1
$SG225599 DB	'MoveStackExceeded', 00H
	ORG $+2
$SG225602 DB	'CheckSWCapture non-node', 00H
$SG225605 DB	'Capturable chain not two long', 00H
	ORG $+2
$SG225607 DB	'MoveStackExceeded', 00H
	ORG $+2
$SG225717 DB	'Unknown isolated chain type', 00H
$SG225725 DB	'MoveStackExceeded', 00H
	ORG $+2
$SG225732 DB	'MoveStackExceeded', 00H
	ORG $+2
$SG225734 DB	'Unknown isolated chain', 00H
	ORG $+1
$SG225740 DB	'Capturable to joint', 00H
$SG225747 DB	'MoveStackExceeded', 00H
	ORG $+2
$SG225762 DB	'C:\Users\15485\Desktop\', 0b9H, 0a4H, 0b3H, 0ccH, 0d6H, 0aeH
	DB	0d0H, 0c7H, 0b5H, 0e3H, 0b8H, 0f1H, 0c6H, 0e5H, '\DotBoxLib\SW'
	DB	'Evaluate.cpp', 00H
	ORG $+1
$SG225763 DB	'C:\Users\15485\Desktop\', 0b9H, 0a4H, 0b3H, 0ccH, 0d6H, 0aeH
	DB	0d0H, 0c7H, 0b5H, 0e3H, 0b8H, 0f1H, 0c6H, 0e5H, '\DotBoxLib\SW'
	DB	'Evaluate.cpp', 00H
	ORG $+1
$SG225779 DB	'C:\Users\15485\Desktop\', 0b9H, 0a4H, 0b3H, 0ccH, 0d6H, 0aeH
	DB	0d0H, 0c7H, 0b5H, 0e3H, 0b8H, 0f1H, 0c6H, 0e5H, '\DotBoxLib\SW'
	DB	'Evaluate.cpp', 00H
	ORG $+1
$SG225809 DB	'Capture more than all the coins', 00H
$SG225814 DB	'Nobody won!', 00H
$SG225852 DB	'MoveStackExceeded', 00H
	ORG $+2
$SG225855 DB	'Unknown isolated chain', 00H
	ORG $+1
$SG225861 DB	'MoveStackExceeded', 00H
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?AfxAssertFailedLine@@YGHPBDH@Z			; AfxAssertFailedLine
PUBLIC	??8EDGE@@QBE_NABU0@@Z				; EDGE::operator==
PUBLIC	??8EDGEDATA@@QBE_NABU0@@Z			; EDGEDATA::operator==
PUBLIC	?Capture@CON@@QAEXHH@Z				; CON::Capture
PUBLIC	?ObviousCapture@CON@@QAEXXZ			; CON::ObviousCapture
PUBLIC	?MYCHOICE@CON@@QAE?AUSWVALUE@@IIIIPAUPossibleMove@@@Z ; CON::MYCHOICE
PUBLIC	?SWEvaluateMove@CON@@QAE?AUSWVALUE@@IIPAUPossibleMove@@@Z ; CON::SWEvaluateMove
PUBLIC	?SWEvaluateAllMoves@CON@@QBE?AUSWVALUE@@IIPAUPossibleMove@@@Z ; CON::SWEvaluateAllMoves
PUBLIC	?CheckSWCapture@CON@@QBE?AUSWVALUE@@IIPAUPossibleMove@@@Z ; CON::CheckSWCapture
PUBLIC	?MeasureRope@CON@@QAEHXZ			; CON::MeasureRope
PUBLIC	??OPossibleMove@@QBE_NABU0@@Z			; PossibleMove::operator>
PUBLIC	??0PossibleMove@@QAE@XZ				; PossibleMove::PossibleMove
PUBLIC	??1PossibleMove@@QAE@XZ				; PossibleMove::~PossibleMove
PUBLIC	??0NIMCON@@QAE@XZ				; NIMCON::NIMCON
PUBLIC	??1NIMCON@@QAE@XZ				; NIMCON::~NIMCON
PUBLIC	??0MarkAvailableMoveStack@@QAE@XZ		; MarkAvailableMoveStack::MarkAvailableMoveStack
PUBLIC	??1MarkAvailableMoveStack@@QAE@XZ		; MarkAvailableMoveStack::~MarkAvailableMoveStack
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	?NotImplemented@@YAXPAD@Z:PROC			; NotImplemented
EXTRN	?ImplementationError@@YAXPBD@Z:PROC		; ImplementationError
EXTRN	?Exists@SWHASHTABLE@@QAEH_K@Z:PROC		; SWHASHTABLE::Exists
EXTRN	?Value@SWHASHTABLE@@QAEXHPAUSWVALUE@@@Z:PROC	; SWHASHTABLE::Value
EXTRN	?EnterValue@SWHASHTABLE@@QAEX_KPAUSWVALUE@@@Z:PROC ; SWHASHTABLE::EnterValue
EXTRN	?UpdateValue@SWHASHTABLE@@QAEXI_KPAUSWVALUE@@@Z:PROC ; SWHASHTABLE::UpdateValue
EXTRN	?DeleteEdge@CON@@QAEXHH@Z:PROC			; CON::DeleteEdge
EXTRN	?DeleteNode@CON@@QAEXH@Z:PROC			; CON::DeleteNode
EXTRN	??0CON@@QAE@XZ:PROC				; CON::CON
EXTRN	??1CON@@QAE@XZ:PROC				; CON::~CON
EXTRN	??4CON@@QAEAAV0@ABV0@@Z:PROC			; CON::operator=
EXTRN	?Canon@CON@@QAEXHH@Z:PROC			; CON::Canon
EXTRN	?SWHash@CON@@QAE_KXZ:PROC			; CON::SWHash
EXTRN	?NimVal@NIMCON@@QAEHPBVCON@@@Z:PROC		; NIMCON::NimVal
EXTRN	?MyRandom@@YAII@Z:PROC				; MyRandom
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	?swHashTable@@3PAVSWHASHTABLE@@A:DWORD		; swHashTable
EXTRN	?timeLimit@@3_JA:QWORD				; timeLimit
EXTRN	?currentTime@@3_JA:QWORD			; currentTime
EXTRN	?searchAborted@@3_NA:BYTE			; searchAborted
EXTRN	?stopThinking@@3_NA:BYTE			; stopThinking
EXTRN	?enableDump@@3HA:DWORD				; enableDump
EXTRN	?computerMove@@3UPossibleMove@@A:BYTE		; computerMove
EXTRN	?availableMoveStack@@3HA:DWORD			; availableMoveStack
EXTRN	?moveType@@3W4MOVE_TYPE@@A:DWORD		; moveType
EXTRN	___security_cookie:DWORD
;	COMDAT ?count@?1??SWEvaluateMove@CON@@QAE?AUSWVALUE@@IIPAUPossibleMove@@@Z@4HA
_BSS	SEGMENT
?count@?1??SWEvaluateMove@CON@@QAE?AUSWVALUE@@IIPAUPossibleMove@@@Z@4HA DD 01H DUP (?) ; `CON::SWEvaluateMove'::`2'::count
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__unwindfunclet$?MeasureRope@CON@@QAEHXZ$0
	DD	032H
	DD	03fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?MeasureRope@CON@@QAEHXZ
	DD	037H
	DD	0415H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?CheckSWCapture@CON@@QBE?AUSWVALUE@@IIPAUPossibleMove@@@Z
	DD	01fH
	DD	048aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__unwindfunclet$?SWEvaluateAllMoves@CON@@QBE?AUSWVALUE@@IIPAUPossibleMove@@@Z$0
	DD	024H
	DD	031H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?SWEvaluateAllMoves@CON@@QBE?AUSWVALUE@@IIPAUPossibleMove@@@Z
	DD	038H
	DD	0ec8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?SWEvaluateMove@CON@@QAE?AUSWVALUE@@IIPAUPossibleMove@@@Z
	DD	01fH
	DD	0352H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__unwindfunclet$?MYCHOICE@CON@@QAE?AUSWVALUE@@IIIIPAUPossibleMove@@@Z$0
	DD	019H
	DD	026H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?MYCHOICE@CON@@QAE?AUSWVALUE@@IIIIPAUPossibleMove@@@Z
	DD	037H
	DD	042aH
voltbl	ENDS
xdata$x	SEGMENT
__unwindtable$?MYCHOICE@CON@@QAE?AUSWVALUE@@IIIIPAUPossibleMove@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MYCHOICE@CON@@QAE?AUSWVALUE@@IIIIPAUPossibleMove@@@Z$0
__unwindtable$?MeasureRope@CON@@QAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MeasureRope@CON@@QAEHXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?MeasureRope@CON@@QAEHXZ$1
__unwindtable$?SWEvaluateAllMoves@CON@@QBE?AUSWVALUE@@IIPAUPossibleMove@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SWEvaluateAllMoves@CON@@QBE?AUSWVALUE@@IIPAUPossibleMove@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SWEvaluateAllMoves@CON@@QBE?AUSWVALUE@@IIPAUPossibleMove@@@Z$1
__ehfuncinfo$?MeasureRope@CON@@QAEHXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?MeasureRope@CON@@QAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SWEvaluateAllMoves@CON@@QBE?AUSWVALUE@@IIPAUPossibleMove@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SWEvaluateAllMoves@CON@@QBE?AUSWVALUE@@IIPAUPossibleMove@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?MYCHOICE@CON@@QAE?AUSWVALUE@@IIIIPAUPossibleMove@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MYCHOICE@CON@@QAE?AUSWVALUE@@IIIIPAUPossibleMove@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\SWEvaluate.cpp
;	COMDAT ??1MarkAvailableMoveStack@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1MarkAvailableMoveStack@@QAE@XZ PROC			; MarkAvailableMoveStack::~MarkAvailableMoveStack, COMDAT
; _this$ = ecx

; 583  :   ~MarkAvailableMoveStack(void){availableMoveStack = remember;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	89 0d 00 00 00
	00		 mov	 DWORD PTR ?availableMoveStack@@3HA, ecx ; availableMoveStack
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??1MarkAvailableMoveStack@@QAE@XZ ENDP			; MarkAvailableMoveStack::~MarkAvailableMoveStack
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\SWEvaluate.cpp
;	COMDAT ??0MarkAvailableMoveStack@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0MarkAvailableMoveStack@@QAE@XZ PROC			; MarkAvailableMoveStack::MarkAvailableMoveStack, COMDAT
; _this$ = ecx

; 582  :   MarkAvailableMoveStack(void){remember = availableMoveStack;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?availableMoveStack@@3HA ; availableMoveStack
  00010	89 08		 mov	 DWORD PTR [eax], ecx
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??0MarkAvailableMoveStack@@QAE@XZ ENDP			; MarkAvailableMoveStack::MarkAvailableMoveStack
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1NIMCON@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1NIMCON@@QAE@XZ PROC					; NIMCON::~NIMCON, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1CON@@QAE@XZ		; CON::~CON
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1NIMCON@@QAE@XZ ENDP					; NIMCON::~NIMCON
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0NIMCON@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0NIMCON@@QAE@XZ PROC					; NIMCON::NIMCON, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0CON@@QAE@XZ		; CON::CON
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0NIMCON@@QAE@XZ ENDP					; NIMCON::NIMCON
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1PossibleMove@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1PossibleMove@@QAE@XZ PROC				; PossibleMove::~PossibleMove, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	83 c1 08	 add	 ecx, 8
  00014	e8 00 00 00 00	 call	 ??1CON@@QAE@XZ		; CON::~CON
  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??1PossibleMove@@QAE@XZ ENDP				; PossibleMove::~PossibleMove
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0PossibleMove@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0PossibleMove@@QAE@XZ PROC				; PossibleMove::PossibleMove, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	83 c1 08	 add	 ecx, 8
  00014	e8 00 00 00 00	 call	 ??0CON@@QAE@XZ		; CON::CON
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	83 c4 04	 add	 esp, 4
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0PossibleMove@@QAE@XZ ENDP				; PossibleMove::PossibleMove
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\NIMCON.h
;	COMDAT ??OPossibleMove@@QBE_NABU0@@Z
_TEXT	SEGMENT
tv86 = -16						; size = 4
tv81 = -12						; size = 4
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_pm$ = 8						; size = 4
??OPossibleMove@@QBE_NABU0@@Z PROC			; PossibleMove::operator>, COMDAT
; _this$ = ecx

; 344  :   {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 345  :     if (nimval==0)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 30		 jne	 SHORT $LN2@operator

; 346  :     {
; 347  :       if (pm.nimval==0) return offering>pm.offering;

  00012	8b 4d 08	 mov	 ecx, DWORD PTR _pm$[ebp]
  00015	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00019	75 21		 jne	 SHORT $LN4@operator
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	8b 45 08	 mov	 eax, DWORD PTR _pm$[ebp]
  00021	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00023	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00025	7e 09		 jle	 SHORT $LN8@operator
  00027	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  0002e	eb 07		 jmp	 SHORT $LN9@operator
$LN8@operator:
  00030	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN9@operator:
  00037	8a 45 f8	 mov	 al, BYTE PTR tv71[ebp]
  0003a	eb 61		 jmp	 SHORT $LN1@operator
$LN4@operator:

; 348  :       return false;

  0003c	32 c0		 xor	 al, al
  0003e	eb 5d		 jmp	 SHORT $LN1@operator

; 349  :     }

  00040	eb 5b		 jmp	 SHORT $LN1@operator
$LN2@operator:

; 350  :     else
; 351  :     {
; 352  :       if (pm.nimval==0) return true;

  00042	8b 55 08	 mov	 edx, DWORD PTR _pm$[ebp]
  00045	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00049	75 04		 jne	 SHORT $LN5@operator
  0004b	b0 01		 mov	 al, 1
  0004d	eb 4e		 jmp	 SHORT $LN1@operator
$LN5@operator:

; 353  :       if (offering==pm.offering) return nimval<pm.nimval;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _pm$[ebp]
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00059	75 23		 jne	 SHORT $LN6@operator
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _pm$[ebp]
  00061	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00064	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00067	7d 09		 jge	 SHORT $LN10@operator
  00069	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv81[ebp], 1
  00070	eb 07		 jmp	 SHORT $LN11@operator
$LN10@operator:
  00072	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$LN11@operator:
  00079	8a 45 f4	 mov	 al, BYTE PTR tv81[ebp]
  0007c	eb 1f		 jmp	 SHORT $LN1@operator
$LN6@operator:

; 354  :       return offering>pm.offering;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 4d 08	 mov	 ecx, DWORD PTR _pm$[ebp]
  00084	8b 10		 mov	 edx, DWORD PTR [eax]
  00086	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00088	7e 09		 jle	 SHORT $LN12@operator
  0008a	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv86[ebp], 1
  00091	eb 07		 jmp	 SHORT $LN13@operator
$LN12@operator:
  00093	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
$LN13@operator:
  0009a	8a 45 f0	 mov	 al, BYTE PTR tv86[ebp]
$LN1@operator:

; 355  :     };
; 356  :   };

  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 04 00	 ret	 4
??OPossibleMove@@QBE_NABU0@@Z ENDP			; PossibleMove::operator>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\SWEvaluate.cpp
_TEXT	SEGMENT
$T2 = -520020						; size = 4
_nimcon$3 = -520012					; size = 5136
_n$4 = -514872						; size = 4
_len$5 = -514868					; size = 4
_len$6 = -514864					; size = 4
_nnB$7 = -514860					; size = 4
_ec$8 = -514856						; size = 4
_en$9 = -514852						; size = 4
_ropeCount$ = -514848					; size = 4
_cpm$ = -514844						; size = 4
_pm$ = -514836						; size = 514800
_npm$ = -32						; size = 4
_nnA$ = -28						; size = 4
_nn$ = -24						; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?MeasureRope@CON@@QAEHXZ PROC				; CON::MeasureRope
; _this$ = ecx

; 1121 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MeasureRope@CON@@QAEHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 48 ef 07 00	 mov	 eax, 520008		; 0007ef48H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	57		 push	 edi
  0001c	51		 push	 ecx
  0001d	8d bd ac 10 f8
	ff		 lea	 edi, DWORD PTR [ebp-520020]
  00023	b9 d2 fb 01 00	 mov	 ecx, 130002		; 0001fbd2H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	59		 pop	 ecx
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	50		 push	 eax
  0003b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00044	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1122 :   int nn, nnA;
; 1123 :   int npm;
; 1124 :   PossibleMove pm[100];

  00047	68 00 00 00 00	 push	 OFFSET ??1PossibleMove@@QAE@XZ
  0004c	68 00 00 00 00	 push	 OFFSET ??0PossibleMove@@QAE@XZ
  00051	6a 64		 push	 100			; 00000064H
  00053	68 1c 14 00 00	 push	 5148			; 0000141cH
  00058	8d 85 ec 24 f8
	ff		 lea	 eax, DWORD PTR _pm$[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  00064	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1125 :   PossibleMove *cpm = pm-1;

  0006b	8d 8d ec 24 f8
	ff		 lea	 ecx, DWORD PTR _pm$[ebp]
  00071	81 e9 1c 14 00
	00		 sub	 ecx, 5148		; 0000141cH
  00077	89 8d e4 24 f8
	ff		 mov	 DWORD PTR _cpm$[ebp], ecx

; 1126 :   int ropeCount = 0;

  0007d	c7 85 e0 24 f8
	ff 00 00 00 00	 mov	 DWORD PTR _ropeCount$[ebp], 0

; 1127 : #ifdef _CHECK
; 1128 :   CheckEverything(0, m_numNode, true);
; 1129 : #endif
; 1130 : //  int loopCount = 0, chainCount = 0; //Isolated loops and chains
; 1131 : //  LINKTYPE lt;
; 1132 :   {
; 1133 :   //There are generally no capturing moves.  
; 1134 :   //The previous mover would have removed them at 
; 1135 :   //less cost than having us search for them.
; 1136 :   //However, at startup the user may have presented
; 1137 :   //us with capturable coins.  If we find any
; 1138 :   //during our tour of the nodes then we quit right
; 1139 :   //there and quit trying any other moves.  Taking
; 1140 :   //them has to be the right thing to do.  If we
; 1141 :   //have any choice we will both try taking them all
; 1142 :   //and try the hard-hearted handout.
; 1143 :   // 
; 1144 :   //We go throungh the nodes and make list of all
; 1145 :   //possible positions after a single move.  We rate each
; 1146 :   //of the possibilities.  The rating is based on
; 1147 :   //two things:
; 1148 :   // 1 - The nimstring value - smaller is better.
; 1149 :   // 2 - The number of coins offered our opponent - smaller is better.
; 1150 :   // 3   provided both are short or both are long.
; 1151 :     for (nn=0; nn<m_numNode; nn++)

  00087	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _nn$[ebp], 0
  0008e	eb 09		 jmp	 SHORT $LN4@MeasureRop
$LN2@MeasureRop:
  00090	8b 55 e8	 mov	 edx, DWORD PTR _nn$[ebp]
  00093	83 c2 01	 add	 edx, 1
  00096	89 55 e8	 mov	 DWORD PTR _nn$[ebp], edx
$LN4@MeasureRop:
  00099	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0009c	8b 4d e8	 mov	 ecx, DWORD PTR _nn$[ebp]
  0009f	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000a1	0f 8d 7a 02 00
	00		 jge	 $LN3@MeasureRop

; 1152 :     {
; 1153 :       int en, ec, nnB;
; 1154 :       nnA = nd[nn].ix;

  000a7	8b 55 e8	 mov	 edx, DWORD PTR _nn$[ebp]
  000aa	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	0f b6 8c 90 13
	10 00 00	 movzx	 ecx, BYTE PTR [eax+edx*4+4115]
  000b5	89 4d e4	 mov	 DWORD PTR _nnA$[ebp], ecx

; 1155 :       if (IS_ISOLATED(sd[nnA][0].ns))

  000b8	8b 55 e4	 mov	 edx, DWORD PTR _nnA$[ebp]
  000bb	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000be	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  000c5	ba 02 00 00 00	 mov	 edx, 2
  000ca	6b c2 00	 imul	 eax, edx, 0
  000cd	0f b6 0c 01	 movzx	 ecx, BYTE PTR [ecx+eax]
  000d1	81 f9 fa 00 00
	00		 cmp	 ecx, 250		; 000000faH
  000d7	0f 8e fb 00 00
	00		 jle	 $LN11@MeasureRop

; 1156 :       {
; 1157 :         //ROPE if (nn < m_numNode-1)
; 1158 :         //ROPE {
; 1159 :         //ROPE   nnB = nd[nn+1].ix;
; 1160 :         //ROPE   if (sd[nnA][0].ns == sd[nnB][0].ns)
; 1161 :         //ROPE   {
; 1162 :         //ROPE     //The shorter one comes later.
; 1163 :         //ROPE     int longLen;
; 1164 :         //ROPE     if (sd[nnA][0].ns == GND_GND) longLen = 3;
; 1165 :         //ROPE     else if (sd[nnA][0].ns == LOOP) longLen = 4;
; 1166 :         //ROPE     else 
; 1167 :         //ROPE     {
; 1168 :         //ROPE       longLen = 0; //keep compiler quiet
; 1169 :         //ROPE       ImplementationError("Unknown isolated chain type");
; 1170 :         //ROPE     };
; 1171 :         //ROPE     if ((ed[nnA].e[0].el < longLen) || (ed[nnB].e[0].el >= longLen))
; 1172 :         //ROPE     {
; 1173 :         //ROPE       continue;
; 1174 :         //ROPE     };
; 1175 :         //ROPE   };
; 1176 :         //ROPE };
; 1177 :         if (sd[nnA][0].ns == GND_GND)

  000dd	8b 55 e4	 mov	 edx, DWORD PTR _nnA$[ebp]
  000e0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e3	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  000ea	ba 02 00 00 00	 mov	 edx, 2
  000ef	6b c2 00	 imul	 eax, edx, 0
  000f2	0f b6 0c 01	 movzx	 ecx, BYTE PTR [ecx+eax]
  000f6	81 f9 fd 00 00
	00		 cmp	 ecx, 253		; 000000fdH
  000fc	0f 85 a1 00 00
	00		 jne	 $LN12@MeasureRop

; 1178 :         {
; 1179 :           int len;
; 1180 :           len = ed[nnA].e[0].el;

  00102	8b 55 e4	 mov	 edx, DWORD PTR _nnA$[ebp]
  00105	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00108	8d 4c d0 10	 lea	 ecx, DWORD PTR [eax+edx*8+16]
  0010c	ba 02 00 00 00	 mov	 edx, 2
  00111	6b c2 00	 imul	 eax, edx, 0
  00114	0f b6 4c 01 01	 movzx	 ecx, BYTE PTR [ecx+eax+1]
  00119	89 8d d0 24 f8
	ff		 mov	 DWORD PTR _len$6[ebp], ecx

; 1181 :           //ROPE if (len + hisScore >= m_neededToWin) 
; 1182 :           //ROPE {
; 1183 :           //ROPE   if (len < result.player2Min) result.player2Min = (ui16)len;
; 1184 :           //ROPE   continue;
; 1185 :           //ROPE };
; 1186 :           if (len > 2) 

  0011f	83 bd d0 24 f8
	ff 02		 cmp	 DWORD PTR _len$6[ebp], 2
  00126	7e 05		 jle	 SHORT $LN14@MeasureRop

; 1187 :           {
; 1188 :             continue;

  00128	e9 63 ff ff ff	 jmp	 $LN2@MeasureRop
$LN14@MeasureRop:

; 1189 :           };
; 1190 :           COPYPOS

  0012d	8b 95 e4 24 f8
	ff		 mov	 edx, DWORD PTR _cpm$[ebp]
  00133	81 c2 1c 14 00
	00		 add	 edx, 5148		; 0000141cH
  00139	89 95 e4 24 f8
	ff		 mov	 DWORD PTR _cpm$[ebp], edx
  0013f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00142	50		 push	 eax
  00143	8b 8d e4 24 f8
	ff		 mov	 ecx, DWORD PTR _cpm$[ebp]
  00149	83 c1 08	 add	 ecx, 8
  0014c	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=
  00151	8b 8d e4 24 f8
	ff		 mov	 ecx, DWORD PTR _cpm$[ebp]
  00157	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0015e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?availableMoveStack@@3HA ; availableMoveStack
  00164	83 ea 01	 sub	 edx, 1
  00167	89 15 00 00 00
	00		 mov	 DWORD PTR ?availableMoveStack@@3HA, edx ; availableMoveStack
  0016d	75 0d		 jne	 SHORT $LN15@MeasureRop
  0016f	68 00 00 00 00	 push	 OFFSET $SG225852
  00174	e8 00 00 00 00	 call	 ?ImplementationError@@YAXPBD@Z ; ImplementationError
  00179	83 c4 04	 add	 esp, 4
$LN15@MeasureRop:

; 1191 :           cpm->offering = len;

  0017c	8b 85 e4 24 f8
	ff		 mov	 eax, DWORD PTR _cpm$[ebp]
  00182	8b 8d d0 24 f8
	ff		 mov	 ecx, DWORD PTR _len$6[ebp]
  00188	89 08		 mov	 DWORD PTR [eax], ecx

; 1192 :           cpm->con.DeleteNode(nn);

  0018a	8b 55 e8	 mov	 edx, DWORD PTR _nn$[ebp]
  0018d	52		 push	 edx
  0018e	8b 8d e4 24 f8
	ff		 mov	 ecx, DWORD PTR _cpm$[ebp]
  00194	83 c1 08	 add	 ecx, 8
  00197	e8 00 00 00 00	 call	 ?DeleteNode@CON@@QAEXH@Z ; CON::DeleteNode

; 1193 :           continue;

  0019c	e9 ef fe ff ff	 jmp	 $LN2@MeasureRop

; 1194 :         }

  001a1	eb 35		 jmp	 SHORT $LN11@MeasureRop
$LN12@MeasureRop:

; 1195 :         else if (sd[nnA][0].ns == LOOP)

  001a3	8b 45 e4	 mov	 eax, DWORD PTR _nnA$[ebp]
  001a6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001a9	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  001b0	b8 02 00 00 00	 mov	 eax, 2
  001b5	6b c8 00	 imul	 ecx, eax, 0
  001b8	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  001bc	81 fa fe 00 00
	00		 cmp	 edx, 254		; 000000feH
  001c2	75 07		 jne	 SHORT $LN16@MeasureRop

; 1196 :         {
; 1197 :           continue;

  001c4	e9 c7 fe ff ff	 jmp	 $LN2@MeasureRop

; 1198 :         }

  001c9	eb 0d		 jmp	 SHORT $LN11@MeasureRop
$LN16@MeasureRop:

; 1199 :         else
; 1200 :         {
; 1201 :           NotImplemented("Unknown isolated chain");

  001cb	68 00 00 00 00	 push	 OFFSET $SG225855
  001d0	e8 00 00 00 00	 call	 ?NotImplemented@@YAXPAD@Z ; NotImplemented
  001d5	83 c4 04	 add	 esp, 4
$LN11@MeasureRop:

; 1202 :         };
; 1203 :       };
; 1204 :       //ROPE if ((nn>0) && (ed[nnA] == ed[nd[nn-1].ix])) continue;
; 1205 :       ec = nd[nnA].ec;

  001d8	8b 45 e4	 mov	 eax, DWORD PTR _nnA$[ebp]
  001db	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001de	0f b6 94 81 10
	10 00 00	 movzx	 edx, BYTE PTR [ecx+eax*4+4112]
  001e6	89 95 d8 24 f8
	ff		 mov	 DWORD PTR _ec$8[ebp], edx

; 1206 :       for (en=0; en<ec; en++)

  001ec	c7 85 dc 24 f8
	ff 00 00 00 00	 mov	 DWORD PTR _en$9[ebp], 0
  001f6	eb 0f		 jmp	 SHORT $LN7@MeasureRop
$LN5@MeasureRop:
  001f8	8b 85 dc 24 f8
	ff		 mov	 eax, DWORD PTR _en$9[ebp]
  001fe	83 c0 01	 add	 eax, 1
  00201	89 85 dc 24 f8
	ff		 mov	 DWORD PTR _en$9[ebp], eax
$LN7@MeasureRop:
  00207	8b 8d dc 24 f8
	ff		 mov	 ecx, DWORD PTR _en$9[ebp]
  0020d	3b 8d d8 24 f8
	ff		 cmp	 ecx, DWORD PTR _ec$8[ebp]
  00213	0f 8d 03 01 00
	00		 jge	 $LN6@MeasureRop

; 1207 :       {
; 1208 :         int len;
; 1209 :         //ROPE if ((en>0) && (ed[nnA].e[en-1] == ed[nnA].e[en])) 
; 1210 :         //ROPE {
; 1211 :         //ROPE   if (sd[nnA][en-1].ns != nnA)
; 1212 :         //ROPE   {
; 1213 :         //ROPE     continue;
; 1214 :         //ROPE   };
; 1215 :         //ROPE };
; 1216 :         nnB = sd[nnA][en].ns;

  00219	8b 55 e4	 mov	 edx, DWORD PTR _nnA$[ebp]
  0021c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0021f	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  00226	8b 95 dc 24 f8
	ff		 mov	 edx, DWORD PTR _en$9[ebp]
  0022c	0f b6 04 51	 movzx	 eax, BYTE PTR [ecx+edx*2]
  00230	89 85 d4 24 f8
	ff		 mov	 DWORD PTR _nnB$7[ebp], eax

; 1217 :         if (IS_A_NODE(nnB) && (nd[nnB].os < nn)) continue; //Only one direction, please

  00236	81 bd d4 24 f8
	ff f9 00 00 00	 cmp	 DWORD PTR _nnB$7[ebp], 249 ; 000000f9H
  00240	7d 18		 jge	 SHORT $LN18@MeasureRop
  00242	8b 8d d4 24 f8
	ff		 mov	 ecx, DWORD PTR _nnB$7[ebp]
  00248	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0024b	0f b6 84 8a 12
	10 00 00	 movzx	 eax, BYTE PTR [edx+ecx*4+4114]
  00253	3b 45 e8	 cmp	 eax, DWORD PTR _nn$[ebp]
  00256	7d 02		 jge	 SHORT $LN18@MeasureRop
  00258	eb 9e		 jmp	 SHORT $LN5@MeasureRop
$LN18@MeasureRop:

; 1218 :         if (nnB == DEADEND)

  0025a	81 bd d4 24 f8
	ff f9 00 00 00	 cmp	 DWORD PTR _nnB$7[ebp], 249 ; 000000f9H
  00264	75 02		 jne	 SHORT $LN19@MeasureRop

; 1219 :         {
; 1220 :           //Well, this is unexpected.;
; 1221 :           continue;

  00266	eb 90		 jmp	 SHORT $LN5@MeasureRop
$LN19@MeasureRop:

; 1222 :         };
; 1223 :         len = ed[nnA].e[en].el;

  00268	8b 4d e4	 mov	 ecx, DWORD PTR _nnA$[ebp]
  0026b	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0026e	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  00272	8b 8d dc 24 f8
	ff		 mov	 ecx, DWORD PTR _en$9[ebp]
  00278	0f b6 54 48 01	 movzx	 edx, BYTE PTR [eax+ecx*2+1]
  0027d	89 95 cc 24 f8
	ff		 mov	 DWORD PTR _len$5[ebp], edx

; 1224 :         if (nnB == nnA)

  00283	8b 85 d4 24 f8
	ff		 mov	 eax, DWORD PTR _nnB$7[ebp]
  00289	3b 45 e4	 cmp	 eax, DWORD PTR _nnA$[ebp]
  0028c	75 05		 jne	 SHORT $LN20@MeasureRop

; 1225 :         {
; 1226 :           //A loop to ourselves.  A loony move at best.
; 1227 :           continue;

  0028e	e9 65 ff ff ff	 jmp	 $LN5@MeasureRop
$LN20@MeasureRop:

; 1228 :         };
; 1229 :         //ROPE if (len + hisScore >= m_neededToWin) 
; 1230 :         //ROPE {
; 1231 :         //ROPE   if (len < result.player2Min) result.player2Min = (ui16)len;
; 1232 :         //ROPE   continue;
; 1233 :         //ROPE };
; 1234 :         if (len > 2) continue;

  00293	83 bd cc 24 f8
	ff 02		 cmp	 DWORD PTR _len$5[ebp], 2
  0029a	7e 05		 jle	 SHORT $LN21@MeasureRop
  0029c	e9 57 ff ff ff	 jmp	 $LN5@MeasureRop
$LN21@MeasureRop:

; 1235 :         COPYPOS; //

  002a1	8b 8d e4 24 f8
	ff		 mov	 ecx, DWORD PTR _cpm$[ebp]
  002a7	81 c1 1c 14 00
	00		 add	 ecx, 5148		; 0000141cH
  002ad	89 8d e4 24 f8
	ff		 mov	 DWORD PTR _cpm$[ebp], ecx
  002b3	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  002b6	52		 push	 edx
  002b7	8b 8d e4 24 f8
	ff		 mov	 ecx, DWORD PTR _cpm$[ebp]
  002bd	83 c1 08	 add	 ecx, 8
  002c0	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=
  002c5	8b 85 e4 24 f8
	ff		 mov	 eax, DWORD PTR _cpm$[ebp]
  002cb	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  002d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?availableMoveStack@@3HA ; availableMoveStack
  002d8	83 e9 01	 sub	 ecx, 1
  002db	89 0d 00 00 00
	00		 mov	 DWORD PTR ?availableMoveStack@@3HA, ecx ; availableMoveStack
  002e1	75 0d		 jne	 SHORT $LN22@MeasureRop
  002e3	68 00 00 00 00	 push	 OFFSET $SG225861
  002e8	e8 00 00 00 00	 call	 ?ImplementationError@@YAXPBD@Z ; ImplementationError
  002ed	83 c4 04	 add	 esp, 4
$LN22@MeasureRop:

; 1236 :         cpm->offering = len;

  002f0	8b 95 e4 24 f8
	ff		 mov	 edx, DWORD PTR _cpm$[ebp]
  002f6	8b 85 cc 24 f8
	ff		 mov	 eax, DWORD PTR _len$5[ebp]
  002fc	89 02		 mov	 DWORD PTR [edx], eax

; 1237 :         cpm->con.DeleteEdge(nn, en);

  002fe	8b 8d dc 24 f8
	ff		 mov	 ecx, DWORD PTR _en$9[ebp]
  00304	51		 push	 ecx
  00305	8b 55 e8	 mov	 edx, DWORD PTR _nn$[ebp]
  00308	52		 push	 edx
  00309	8b 8d e4 24 f8
	ff		 mov	 ecx, DWORD PTR _cpm$[ebp]
  0030f	83 c1 08	 add	 ecx, 8
  00312	e8 00 00 00 00	 call	 ?DeleteEdge@CON@@QAEXHH@Z ; CON::DeleteEdge

; 1238 :       }; //for each link	hisScore	0x0000000d

  00317	e9 dc fe ff ff	 jmp	 $LN5@MeasureRop
$LN6@MeasureRop:

; 1239 : 
; 1240 :     };

  0031c	e9 6f fd ff ff	 jmp	 $LN2@MeasureRop
$LN3@MeasureRop:

; 1241 :   };
; 1242 :   npm = cpm - pm + 1;

  00321	8b 85 e4 24 f8
	ff		 mov	 eax, DWORD PTR _cpm$[ebp]
  00327	8d 8d ec 24 f8
	ff		 lea	 ecx, DWORD PTR _pm$[ebp]
  0032d	2b c1		 sub	 eax, ecx
  0032f	99		 cdq
  00330	b9 1c 14 00 00	 mov	 ecx, 5148		; 0000141cH
  00335	f7 f9		 idiv	 ecx
  00337	83 c0 01	 add	 eax, 1
  0033a	89 45 e0	 mov	 DWORD PTR _npm$[ebp], eax

; 1243 :   //if (npm == 0) 
; 1244 :   //{
; 1245 :   //  result.player2Min = 0;
; 1246 :   //};
; 1247 :   for (int n=0; n<npm; n++)

  0033d	c7 85 c8 24 f8
	ff 00 00 00 00	 mov	 DWORD PTR _n$4[ebp], 0
  00347	eb 0f		 jmp	 SHORT $LN10@MeasureRop
$LN8@MeasureRop:
  00349	8b 95 c8 24 f8
	ff		 mov	 edx, DWORD PTR _n$4[ebp]
  0034f	83 c2 01	 add	 edx, 1
  00352	89 95 c8 24 f8
	ff		 mov	 DWORD PTR _n$4[ebp], edx
$LN10@MeasureRop:
  00358	8b 85 c8 24 f8
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  0035e	3b 45 e0	 cmp	 eax, DWORD PTR _npm$[ebp]
  00361	7d 64		 jge	 SHORT $LN9@MeasureRop

; 1248 :   {
; 1249 :     NIMCON nimcon;

  00363	8d 8d b4 10 f8
	ff		 lea	 ecx, DWORD PTR _nimcon$3[ebp]
  00369	e8 00 00 00 00	 call	 ??0NIMCON@@QAE@XZ
  0036e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 1250 :     if (pm[n].con.m_numNode != 0)

  00372	69 8d c8 24 f8
	ff 1c 14 00 00	 imul	 ecx, DWORD PTR _n$4[ebp], 5148
  0037c	83 bc 0d f4 24
	f8 ff 00	 cmp	 DWORD PTR _pm$[ebp+ecx+8], 0
  00384	74 30		 je	 SHORT $LN23@MeasureRop

; 1251 :     {
; 1252 :       if (nimcon.NimVal(&pm[n].con) != 0) ropeCount++;

  00386	69 95 c8 24 f8
	ff 1c 14 00 00	 imul	 edx, DWORD PTR _n$4[ebp], 5148
  00390	8d 84 15 f4 24
	f8 ff		 lea	 eax, DWORD PTR _pm$[ebp+edx+8]
  00397	50		 push	 eax
  00398	8d 8d b4 10 f8
	ff		 lea	 ecx, DWORD PTR _nimcon$3[ebp]
  0039e	e8 00 00 00 00	 call	 ?NimVal@NIMCON@@QAEHPBVCON@@@Z ; NIMCON::NimVal
  003a3	85 c0		 test	 eax, eax
  003a5	74 0f		 je	 SHORT $LN23@MeasureRop
  003a7	8b 8d e0 24 f8
	ff		 mov	 ecx, DWORD PTR _ropeCount$[ebp]
  003ad	83 c1 01	 add	 ecx, 1
  003b0	89 8d e0 24 f8
	ff		 mov	 DWORD PTR _ropeCount$[ebp], ecx
$LN23@MeasureRop:

; 1253 :     };
; 1254 :   };

  003b6	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  003ba	8d 8d b4 10 f8
	ff		 lea	 ecx, DWORD PTR _nimcon$3[ebp]
  003c0	e8 00 00 00 00	 call	 ??1NIMCON@@QAE@XZ
  003c5	eb 82		 jmp	 SHORT $LN8@MeasureRop
$LN9@MeasureRop:

; 1255 :   return ropeCount;

  003c7	8b 95 e0 24 f8
	ff		 mov	 edx, DWORD PTR _ropeCount$[ebp]
  003cd	89 95 ac 10 f8
	ff		 mov	 DWORD PTR $T2[ebp], edx
  003d3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003da	68 00 00 00 00	 push	 OFFSET ??1PossibleMove@@QAE@XZ
  003df	6a 64		 push	 100			; 00000064H
  003e1	68 1c 14 00 00	 push	 5148			; 0000141cH
  003e6	8d 85 ec 24 f8
	ff		 lea	 eax, DWORD PTR _pm$[ebp]
  003ec	50		 push	 eax
  003ed	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  003f2	8b 85 ac 10 f8
	ff		 mov	 eax, DWORD PTR $T2[ebp]

; 1256 : }

  003f8	52		 push	 edx
  003f9	8b cd		 mov	 ecx, ebp
  003fb	50		 push	 eax
  003fc	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN32@MeasureRop
  00402	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00407	58		 pop	 eax
  00408	5a		 pop	 edx
  00409	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0040c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00413	59		 pop	 ecx
  00414	5f		 pop	 edi
  00415	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00418	33 cd		 xor	 ecx, ebp
  0041a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0041f	81 c4 54 ef 07
	00		 add	 esp, 520020		; 0007ef54H
  00425	3b ec		 cmp	 ebp, esp
  00427	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0042c	8b e5		 mov	 esp, ebp
  0042e	5d		 pop	 ebp
  0042f	c3		 ret	 0
$LN32@MeasureRop:
  00430	02 00 00 00	 DD	 2
  00434	00 00 00 00	 DD	 $LN31@MeasureRop
$LN31@MeasureRop:
  00438	ec 24 f8 ff	 DD	 -514836			; fff824ecH
  0043c	f0 da 07 00	 DD	 514800			; 0007daf0H
  00440	00 00 00 00	 DD	 $LN28@MeasureRop
  00444	b4 10 f8 ff	 DD	 -520012			; fff810b4H
  00448	10 14 00 00	 DD	 5136			; 00001410H
  0044c	00 00 00 00	 DD	 $LN29@MeasureRop
$LN29@MeasureRop:
  00450	6e		 DB	 110			; 0000006eH
  00451	69		 DB	 105			; 00000069H
  00452	6d		 DB	 109			; 0000006dH
  00453	63		 DB	 99			; 00000063H
  00454	6f		 DB	 111			; 0000006fH
  00455	6e		 DB	 110			; 0000006eH
  00456	00		 DB	 0
$LN28@MeasureRop:
  00457	70		 DB	 112			; 00000070H
  00458	6d		 DB	 109			; 0000006dH
  00459	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?MeasureRope@CON@@QAEHXZ$0:
  00000	68 00 00 00 00	 push	 OFFSET ??1PossibleMove@@QAE@XZ
  00005	6a 64		 push	 100			; 00000064H
  00007	68 1c 14 00 00	 push	 5148			; 0000141cH
  0000c	8d 85 ec 24 f8
	ff		 lea	 eax, DWORD PTR _pm$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00018	c3		 ret	 0
__unwindfunclet$?MeasureRope@CON@@QAEHXZ$1:
  00019	8d 8d b4 10 f8
	ff		 lea	 ecx, DWORD PTR _nimcon$3[ebp]
  0001f	e9 00 00 00 00	 jmp	 ??1NIMCON@@QAE@XZ
  00024	cc		 int	 3
  00025	cc		 int	 3
  00026	cc		 int	 3
  00027	cc		 int	 3
  00028	cc		 int	 3
__ehhandler$?MeasureRope@CON@@QAEHXZ:
  00029	90		 npad	 1
  0002a	90		 npad	 1
  0002b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00032	8b 8a b0 10 f8
	ff		 mov	 ecx, DWORD PTR [edx-520016]
  00038	33 c8		 xor	 ecx, eax
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00042	33 c8		 xor	 ecx, eax
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MeasureRope@CON@@QAEHXZ
  0004e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MeasureRope@CON@@QAEHXZ ENDP				; CON::MeasureRope
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\SWEvaluate.cpp
_TEXT	SEGMENT
$T1 = -124						; size = 20
_len$2 = -104						; size = 4
$T3 = -100						; size = 20
_len$4 = -80						; size = 4
$T5 = -76						; size = 20
_len$6 = -56						; size = 4
_en$7 = -52						; size = 4
_nnA$8 = -48						; size = 4
_cpm$ = -44						; size = 4
_nn$ = -40						; size = 4
_result$ = -32						; size = 20
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_player1Score$ = 12					; size = 4
_player2Score$ = 16					; size = 4
_pm$ = 20						; size = 4
?CheckSWCapture@CON@@QBE?AUSWVALUE@@IIPAUPossibleMove@@@Z PROC ; CON::CheckSWCapture
; _this$ = ecx

; 497  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	57		 push	 edi
  00007	51		 push	 ecx
  00008	8d 7d 84	 lea	 edi, DWORD PTR [ebp-124]
  0000b	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	59		 pop	 ecx
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00022	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 498  :   SWVALUE result;
; 499  :   int nn;
; 500  :   PossibleMove *cpm = pm-1;

  00025	8b 45 14	 mov	 eax, DWORD PTR _pm$[ebp]
  00028	2d 1c 14 00 00	 sub	 eax, 5148		; 0000141cH
  0002d	89 45 d4	 mov	 DWORD PTR _cpm$[ebp], eax

; 501  : #ifdef SW_DUMP
; 502  :   static int id=0;
; 503  :   int myId = ++id;
; 504  : //  LOGUIUI("SWEvaluateAllMoves id=%d",myId,0);
; 505  :   this->DUMP("CheckSWCapture",myId,player1Score,player2Score,0,m_numNode);
; 506  : #endif
; 507  :   for (nn=0; nn<m_numNode; nn++)

  00030	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _nn$[ebp], 0
  00037	eb 09		 jmp	 SHORT $LN4@CheckSWCap
$LN2@CheckSWCap:
  00039	8b 4d d8	 mov	 ecx, DWORD PTR _nn$[ebp]
  0003c	83 c1 01	 add	 ecx, 1
  0003f	89 4d d8	 mov	 DWORD PTR _nn$[ebp], ecx
$LN4@CheckSWCap:
  00042	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00045	8b 45 d8	 mov	 eax, DWORD PTR _nn$[ebp]
  00048	3b 02		 cmp	 eax, DWORD PTR [edx]
  0004a	0f 8d fe 03 00
	00		 jge	 $LN3@CheckSWCap

; 508  :   {
; 509  :     int nnA, en;
; 510  :     nnA = nd[nn].ix;

  00050	8b 4d d8	 mov	 ecx, DWORD PTR _nn$[ebp]
  00053	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00056	0f b6 84 8a 13
	10 00 00	 movzx	 eax, BYTE PTR [edx+ecx*4+4115]
  0005e	89 45 d0	 mov	 DWORD PTR _nnA$8[ebp], eax

; 511  :     if (IS_ISOLATED(sd[nnA][0].ns))

  00061	8b 4d d0	 mov	 ecx, DWORD PTR _nnA$8[ebp]
  00064	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00067	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  0006e	b9 02 00 00 00	 mov	 ecx, 2
  00073	6b d1 00	 imul	 edx, ecx, 0
  00076	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  0007a	3d fa 00 00 00	 cmp	 eax, 250		; 000000faH
  0007f	0f 8e 90 02 00
	00		 jle	 $LN8@CheckSWCap

; 512  :     {
; 513  :       if (sd[nnA][0].ns == GND_DE)

  00085	8b 4d d0	 mov	 ecx, DWORD PTR _nnA$8[ebp]
  00088	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0008b	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  00092	b9 02 00 00 00	 mov	 ecx, 2
  00097	6b d1 00	 imul	 edx, ecx, 0
  0009a	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  0009e	3d fc 00 00 00	 cmp	 eax, 252		; 000000fcH
  000a3	0f 85 fc 00 00
	00		 jne	 $LN9@CheckSWCap

; 514  :       {
; 515  :         int len;
; 516  :         len = ed[nnA].e[0].el;

  000a9	8b 4d d0	 mov	 ecx, DWORD PTR _nnA$8[ebp]
  000ac	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000af	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  000b3	b9 02 00 00 00	 mov	 ecx, 2
  000b8	6b d1 00	 imul	 edx, ecx, 0
  000bb	0f b6 44 10 01	 movzx	 eax, BYTE PTR [eax+edx+1]
  000c0	89 45 c8	 mov	 DWORD PTR _len$6[ebp], eax

; 517  :         if (len!= 2)

  000c3	83 7d c8 02	 cmp	 DWORD PTR _len$6[ebp], 2
  000c7	74 0d		 je	 SHORT $LN11@CheckSWCap

; 518  :         {//We should have found this easy capture before getting here!
; 519  :           ImplementationError("Capturable chain not two long");

  000c9	68 00 00 00 00	 push	 OFFSET $SG225589
  000ce	e8 00 00 00 00	 call	 ?ImplementationError@@YAXPBD@Z ; ImplementationError
  000d3	83 c4 04	 add	 esp, 4
$LN11@CheckSWCap:

; 520  :         };
; 521  :         COPYPOS

  000d6	8b 4d d4	 mov	 ecx, DWORD PTR _cpm$[ebp]
  000d9	81 c1 1c 14 00
	00		 add	 ecx, 5148		; 0000141cH
  000df	89 4d d4	 mov	 DWORD PTR _cpm$[ebp], ecx
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000e5	52		 push	 edx
  000e6	8b 4d d4	 mov	 ecx, DWORD PTR _cpm$[ebp]
  000e9	83 c1 08	 add	 ecx, 8
  000ec	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=
  000f1	8b 45 d4	 mov	 eax, DWORD PTR _cpm$[ebp]
  000f4	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  000fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?availableMoveStack@@3HA ; availableMoveStack
  00101	83 e9 01	 sub	 ecx, 1
  00104	89 0d 00 00 00
	00		 mov	 DWORD PTR ?availableMoveStack@@3HA, ecx ; availableMoveStack
  0010a	75 0d		 jne	 SHORT $LN12@CheckSWCap
  0010c	68 00 00 00 00	 push	 OFFSET $SG225591
  00111	e8 00 00 00 00	 call	 ?ImplementationError@@YAXPBD@Z ; ImplementationError
  00116	83 c4 04	 add	 esp, 4
$LN12@CheckSWCap:

; 522  :         cpm->con.DeleteNode(nd[nnA].os);

  00119	8b 55 d0	 mov	 edx, DWORD PTR _nnA$8[ebp]
  0011c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0011f	0f b6 8c 90 12
	10 00 00	 movzx	 ecx, BYTE PTR [eax+edx*4+4114]
  00127	51		 push	 ecx
  00128	8b 4d d4	 mov	 ecx, DWORD PTR _cpm$[ebp]
  0012b	83 c1 08	 add	 ecx, 8
  0012e	e8 00 00 00 00	 call	 ?DeleteNode@CON@@QAEXH@Z ; CON::DeleteNode

; 523  :         result = cpm->con.MYCHOICE(player1Score, player2Score, len, 2, pm);

  00133	8b 55 14	 mov	 edx, DWORD PTR _pm$[ebp]
  00136	52		 push	 edx
  00137	6a 02		 push	 2
  00139	8b 45 c8	 mov	 eax, DWORD PTR _len$6[ebp]
  0013c	50		 push	 eax
  0013d	8b 4d 10	 mov	 ecx, DWORD PTR _player2Score$[ebp]
  00140	51		 push	 ecx
  00141	8b 55 0c	 mov	 edx, DWORD PTR _player1Score$[ebp]
  00144	52		 push	 edx
  00145	8d 45 b4	 lea	 eax, DWORD PTR $T5[ebp]
  00148	50		 push	 eax
  00149	8b 4d d4	 mov	 ecx, DWORD PTR _cpm$[ebp]
  0014c	83 c1 08	 add	 ecx, 8
  0014f	e8 00 00 00 00	 call	 ?MYCHOICE@CON@@QAE?AUSWVALUE@@IIIIPAUPossibleMove@@@Z ; CON::MYCHOICE
  00154	8b 08		 mov	 ecx, DWORD PTR [eax]
  00156	89 4d e0	 mov	 DWORD PTR _result$[ebp], ecx
  00159	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0015c	89 55 e4	 mov	 DWORD PTR _result$[ebp+4], edx
  0015f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00162	89 4d e8	 mov	 DWORD PTR _result$[ebp+8], ecx
  00165	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00168	89 55 ec	 mov	 DWORD PTR _result$[ebp+12], edx
  0016b	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0016e	89 45 f0	 mov	 DWORD PTR _result$[ebp+16], eax

; 524  :         result.bestMove = 0;

  00171	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _result$[ebp+4], 0

; 525  :         return result;

  00178	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0017b	8b 55 e0	 mov	 edx, DWORD PTR _result$[ebp]
  0017e	89 11		 mov	 DWORD PTR [ecx], edx
  00180	8b 45 e4	 mov	 eax, DWORD PTR _result$[ebp+4]
  00183	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00186	8b 55 e8	 mov	 edx, DWORD PTR _result$[ebp+8]
  00189	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0018c	8b 45 ec	 mov	 eax, DWORD PTR _result$[ebp+12]
  0018f	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00192	8b 55 f0	 mov	 edx, DWORD PTR _result$[ebp+16]
  00195	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  00198	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0019b	e9 d8 02 00 00	 jmp	 $LN1@CheckSWCap

; 526  :       }

  001a0	e9 70 01 00 00	 jmp	 $LN8@CheckSWCap
$LN9@CheckSWCap:

; 527  :       else if (sd[nnA][0].ns == GND_GND)

  001a5	8b 45 d0	 mov	 eax, DWORD PTR _nnA$8[ebp]
  001a8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ab	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  001b2	b8 02 00 00 00	 mov	 eax, 2
  001b7	6b c8 00	 imul	 ecx, eax, 0
  001ba	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  001be	81 fa fd 00 00
	00		 cmp	 edx, 253		; 000000fdH
  001c4	75 0a		 jne	 SHORT $LN13@CheckSWCap

; 528  :       {
; 529  :         continue;

  001c6	e9 6e fe ff ff	 jmp	 $LN2@CheckSWCap

; 530  :       }

  001cb	e9 45 01 00 00	 jmp	 $LN8@CheckSWCap
$LN13@CheckSWCap:

; 531  :       else if (sd[nnA][0].ns == DE_DE)

  001d0	8b 45 d0	 mov	 eax, DWORD PTR _nnA$8[ebp]
  001d3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001d6	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  001dd	b8 02 00 00 00	 mov	 eax, 2
  001e2	6b c8 00	 imul	 ecx, eax, 0
  001e5	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  001e9	81 fa fb 00 00
	00		 cmp	 edx, 251		; 000000fbH
  001ef	0f 85 eb 00 00
	00		 jne	 $LN15@CheckSWCap

; 532  :       {
; 533  :         int len;
; 534  :         len = ed[nnA].e[0].el;

  001f5	8b 45 d0	 mov	 eax, DWORD PTR _nnA$8[ebp]
  001f8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001fb	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  001ff	b8 02 00 00 00	 mov	 eax, 2
  00204	6b c8 00	 imul	 ecx, eax, 0
  00207	0f b6 54 0a 01	 movzx	 edx, BYTE PTR [edx+ecx+1]
  0020c	89 55 b0	 mov	 DWORD PTR _len$4[ebp], edx

; 535  :         if (len!= 4)

  0020f	83 7d b0 04	 cmp	 DWORD PTR _len$4[ebp], 4
  00213	74 0d		 je	 SHORT $LN17@CheckSWCap

; 536  :         {//We should have found this easy capture before getting here!
; 537  :           ImplementationError("Capturable chain not four long");

  00215	68 00 00 00 00	 push	 OFFSET $SG225597
  0021a	e8 00 00 00 00	 call	 ?ImplementationError@@YAXPBD@Z ; ImplementationError
  0021f	83 c4 04	 add	 esp, 4
$LN17@CheckSWCap:

; 538  :         };
; 539  :         COPYPOS

  00222	8b 45 d4	 mov	 eax, DWORD PTR _cpm$[ebp]
  00225	05 1c 14 00 00	 add	 eax, 5148		; 0000141cH
  0022a	89 45 d4	 mov	 DWORD PTR _cpm$[ebp], eax
  0022d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00230	51		 push	 ecx
  00231	8b 4d d4	 mov	 ecx, DWORD PTR _cpm$[ebp]
  00234	83 c1 08	 add	 ecx, 8
  00237	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=
  0023c	8b 55 d4	 mov	 edx, DWORD PTR _cpm$[ebp]
  0023f	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
  00246	a1 00 00 00 00	 mov	 eax, DWORD PTR ?availableMoveStack@@3HA ; availableMoveStack
  0024b	83 e8 01	 sub	 eax, 1
  0024e	a3 00 00 00 00	 mov	 DWORD PTR ?availableMoveStack@@3HA, eax ; availableMoveStack
  00253	75 0d		 jne	 SHORT $LN18@CheckSWCap
  00255	68 00 00 00 00	 push	 OFFSET $SG225599
  0025a	e8 00 00 00 00	 call	 ?ImplementationError@@YAXPBD@Z ; ImplementationError
  0025f	83 c4 04	 add	 esp, 4
$LN18@CheckSWCap:

; 540  :         cpm->con.DeleteNode(nn);

  00262	8b 4d d8	 mov	 ecx, DWORD PTR _nn$[ebp]
  00265	51		 push	 ecx
  00266	8b 4d d4	 mov	 ecx, DWORD PTR _cpm$[ebp]
  00269	83 c1 08	 add	 ecx, 8
  0026c	e8 00 00 00 00	 call	 ?DeleteNode@CON@@QAEXH@Z ; CON::DeleteNode

; 541  :         result = cpm->con.MYCHOICE(player1Score, player2Score, len, 4, pm);

  00271	8b 55 14	 mov	 edx, DWORD PTR _pm$[ebp]
  00274	52		 push	 edx
  00275	6a 04		 push	 4
  00277	8b 45 b0	 mov	 eax, DWORD PTR _len$4[ebp]
  0027a	50		 push	 eax
  0027b	8b 4d 10	 mov	 ecx, DWORD PTR _player2Score$[ebp]
  0027e	51		 push	 ecx
  0027f	8b 55 0c	 mov	 edx, DWORD PTR _player1Score$[ebp]
  00282	52		 push	 edx
  00283	8d 45 9c	 lea	 eax, DWORD PTR $T3[ebp]
  00286	50		 push	 eax
  00287	8b 4d d4	 mov	 ecx, DWORD PTR _cpm$[ebp]
  0028a	83 c1 08	 add	 ecx, 8
  0028d	e8 00 00 00 00	 call	 ?MYCHOICE@CON@@QAE?AUSWVALUE@@IIIIPAUPossibleMove@@@Z ; CON::MYCHOICE
  00292	8b 08		 mov	 ecx, DWORD PTR [eax]
  00294	89 4d e0	 mov	 DWORD PTR _result$[ebp], ecx
  00297	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0029a	89 55 e4	 mov	 DWORD PTR _result$[ebp+4], edx
  0029d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002a0	89 4d e8	 mov	 DWORD PTR _result$[ebp+8], ecx
  002a3	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  002a6	89 55 ec	 mov	 DWORD PTR _result$[ebp+12], edx
  002a9	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  002ac	89 45 f0	 mov	 DWORD PTR _result$[ebp+16], eax

; 542  :         result.bestMove = 0;

  002af	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _result$[ebp+4], 0

; 543  :         return result;

  002b6	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  002b9	8b 55 e0	 mov	 edx, DWORD PTR _result$[ebp]
  002bc	89 11		 mov	 DWORD PTR [ecx], edx
  002be	8b 45 e4	 mov	 eax, DWORD PTR _result$[ebp+4]
  002c1	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  002c4	8b 55 e8	 mov	 edx, DWORD PTR _result$[ebp+8]
  002c7	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  002ca	8b 45 ec	 mov	 eax, DWORD PTR _result$[ebp+12]
  002cd	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  002d0	8b 55 f0	 mov	 edx, DWORD PTR _result$[ebp+16]
  002d3	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  002d6	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002d9	e9 9a 01 00 00	 jmp	 $LN1@CheckSWCap

; 544  :       }

  002de	eb 35		 jmp	 SHORT $LN8@CheckSWCap
$LN15@CheckSWCap:

; 545  :       else if (sd[nnA][0].ns == LOOP)

  002e0	8b 45 d0	 mov	 eax, DWORD PTR _nnA$8[ebp]
  002e3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002e6	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  002ed	b8 02 00 00 00	 mov	 eax, 2
  002f2	6b c8 00	 imul	 ecx, eax, 0
  002f5	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  002f9	81 fa fe 00 00
	00		 cmp	 edx, 254		; 000000feH
  002ff	75 07		 jne	 SHORT $LN19@CheckSWCap

; 546  :       {
; 547  :         continue;

  00301	e9 33 fd ff ff	 jmp	 $LN2@CheckSWCap

; 548  :       }

  00306	eb 0d		 jmp	 SHORT $LN8@CheckSWCap
$LN19@CheckSWCap:

; 549  :       else
; 550  :       {
; 551  :         NotImplemented("CheckSWCapture non-node");

  00308	68 00 00 00 00	 push	 OFFSET $SG225602
  0030d	e8 00 00 00 00	 call	 ?NotImplemented@@YAXPAD@Z ; NotImplemented
  00312	83 c4 04	 add	 esp, 4
$LN8@CheckSWCap:

; 552  :       };
; 553  :     };
; 554  :     for (en=nd[nnA].ec-1; en>=0; en--)

  00315	8b 45 d0	 mov	 eax, DWORD PTR _nnA$8[ebp]
  00318	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0031b	0f b6 94 81 10
	10 00 00	 movzx	 edx, BYTE PTR [ecx+eax*4+4112]
  00323	83 ea 01	 sub	 edx, 1
  00326	89 55 cc	 mov	 DWORD PTR _en$7[ebp], edx
  00329	eb 09		 jmp	 SHORT $LN7@CheckSWCap
$LN5@CheckSWCap:
  0032b	8b 45 cc	 mov	 eax, DWORD PTR _en$7[ebp]
  0032e	83 e8 01	 sub	 eax, 1
  00331	89 45 cc	 mov	 DWORD PTR _en$7[ebp], eax
$LN7@CheckSWCap:
  00334	83 7d cc 00	 cmp	 DWORD PTR _en$7[ebp], 0
  00338	0f 8c 0b 01 00
	00		 jl	 $LN6@CheckSWCap

; 555  :     {
; 556  :       if (sd[nnA][en].ns != DEADEND) continue;

  0033e	8b 4d d0	 mov	 ecx, DWORD PTR _nnA$8[ebp]
  00341	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00344	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  0034b	8b 4d cc	 mov	 ecx, DWORD PTR _en$7[ebp]
  0034e	0f b6 14 48	 movzx	 edx, BYTE PTR [eax+ecx*2]
  00352	81 fa f9 00 00
	00		 cmp	 edx, 249		; 000000f9H
  00358	74 02		 je	 SHORT $LN21@CheckSWCap
  0035a	eb cf		 jmp	 SHORT $LN5@CheckSWCap
$LN21@CheckSWCap:

; 557  :       {
; 558  :         int len;
; 559  :         len = ed[nnA].e[en].el;

  0035c	8b 45 d0	 mov	 eax, DWORD PTR _nnA$8[ebp]
  0035f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00362	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  00366	8b 45 cc	 mov	 eax, DWORD PTR _en$7[ebp]
  00369	0f b6 4c 42 01	 movzx	 ecx, BYTE PTR [edx+eax*2+1]
  0036e	89 4d 98	 mov	 DWORD PTR _len$2[ebp], ecx

; 560  :         if (len!= 2)

  00371	83 7d 98 02	 cmp	 DWORD PTR _len$2[ebp], 2
  00375	74 0d		 je	 SHORT $LN22@CheckSWCap

; 561  :         {//We should have found this easy capture before getting here!
; 562  :           ImplementationError("Capturable chain not two long");

  00377	68 00 00 00 00	 push	 OFFSET $SG225605
  0037c	e8 00 00 00 00	 call	 ?ImplementationError@@YAXPBD@Z ; ImplementationError
  00381	83 c4 04	 add	 esp, 4
$LN22@CheckSWCap:

; 563  :         };
; 564  :         COPYPOS

  00384	8b 55 d4	 mov	 edx, DWORD PTR _cpm$[ebp]
  00387	81 c2 1c 14 00
	00		 add	 edx, 5148		; 0000141cH
  0038d	89 55 d4	 mov	 DWORD PTR _cpm$[ebp], edx
  00390	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00393	50		 push	 eax
  00394	8b 4d d4	 mov	 ecx, DWORD PTR _cpm$[ebp]
  00397	83 c1 08	 add	 ecx, 8
  0039a	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=
  0039f	8b 4d d4	 mov	 ecx, DWORD PTR _cpm$[ebp]
  003a2	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  003a9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?availableMoveStack@@3HA ; availableMoveStack
  003af	83 ea 01	 sub	 edx, 1
  003b2	89 15 00 00 00
	00		 mov	 DWORD PTR ?availableMoveStack@@3HA, edx ; availableMoveStack
  003b8	75 0d		 jne	 SHORT $LN23@CheckSWCap
  003ba	68 00 00 00 00	 push	 OFFSET $SG225607
  003bf	e8 00 00 00 00	 call	 ?ImplementationError@@YAXPBD@Z ; ImplementationError
  003c4	83 c4 04	 add	 esp, 4
$LN23@CheckSWCap:

; 565  :         cpm->con.DeleteEdge(nn, en);

  003c7	8b 45 cc	 mov	 eax, DWORD PTR _en$7[ebp]
  003ca	50		 push	 eax
  003cb	8b 4d d8	 mov	 ecx, DWORD PTR _nn$[ebp]
  003ce	51		 push	 ecx
  003cf	8b 4d d4	 mov	 ecx, DWORD PTR _cpm$[ebp]
  003d2	83 c1 08	 add	 ecx, 8
  003d5	e8 00 00 00 00	 call	 ?DeleteEdge@CON@@QAEXHH@Z ; CON::DeleteEdge

; 566  :         result = cpm->con.MYCHOICE(player1Score, player2Score, len, 2, pm);

  003da	8b 55 14	 mov	 edx, DWORD PTR _pm$[ebp]
  003dd	52		 push	 edx
  003de	6a 02		 push	 2
  003e0	8b 45 98	 mov	 eax, DWORD PTR _len$2[ebp]
  003e3	50		 push	 eax
  003e4	8b 4d 10	 mov	 ecx, DWORD PTR _player2Score$[ebp]
  003e7	51		 push	 ecx
  003e8	8b 55 0c	 mov	 edx, DWORD PTR _player1Score$[ebp]
  003eb	52		 push	 edx
  003ec	8d 45 84	 lea	 eax, DWORD PTR $T1[ebp]
  003ef	50		 push	 eax
  003f0	8b 4d d4	 mov	 ecx, DWORD PTR _cpm$[ebp]
  003f3	83 c1 08	 add	 ecx, 8
  003f6	e8 00 00 00 00	 call	 ?MYCHOICE@CON@@QAE?AUSWVALUE@@IIIIPAUPossibleMove@@@Z ; CON::MYCHOICE
  003fb	8b 08		 mov	 ecx, DWORD PTR [eax]
  003fd	89 4d e0	 mov	 DWORD PTR _result$[ebp], ecx
  00400	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00403	89 55 e4	 mov	 DWORD PTR _result$[ebp+4], edx
  00406	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00409	89 4d e8	 mov	 DWORD PTR _result$[ebp+8], ecx
  0040c	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0040f	89 55 ec	 mov	 DWORD PTR _result$[ebp+12], edx
  00412	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00415	89 45 f0	 mov	 DWORD PTR _result$[ebp+16], eax

; 567  :         result.bestMove = 0;

  00418	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _result$[ebp+4], 0

; 568  :         return result;

  0041f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00422	8b 55 e0	 mov	 edx, DWORD PTR _result$[ebp]
  00425	89 11		 mov	 DWORD PTR [ecx], edx
  00427	8b 45 e4	 mov	 eax, DWORD PTR _result$[ebp+4]
  0042a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0042d	8b 55 e8	 mov	 edx, DWORD PTR _result$[ebp+8]
  00430	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00433	8b 45 ec	 mov	 eax, DWORD PTR _result$[ebp+12]
  00436	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00439	8b 55 f0	 mov	 edx, DWORD PTR _result$[ebp+16]
  0043c	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0043f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00442	eb 34		 jmp	 SHORT $LN1@CheckSWCap

; 569  :       }
; 570  :     }; //for (en)

  00444	e9 e2 fe ff ff	 jmp	 $LN5@CheckSWCap
$LN6@CheckSWCap:

; 571  :   }; //for (nn)

  00449	e9 eb fb ff ff	 jmp	 $LN2@CheckSWCap
$LN3@CheckSWCap:

; 572  :   result.moveType = MT_NONE;

  0044e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _result$[ebp+8], 0

; 573  :   return result;

  00455	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00458	8b 4d e0	 mov	 ecx, DWORD PTR _result$[ebp]
  0045b	89 08		 mov	 DWORD PTR [eax], ecx
  0045d	8b 55 e4	 mov	 edx, DWORD PTR _result$[ebp+4]
  00460	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00463	8b 4d e8	 mov	 ecx, DWORD PTR _result$[ebp+8]
  00466	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00469	8b 55 ec	 mov	 edx, DWORD PTR _result$[ebp+12]
  0046c	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0046f	8b 4d f0	 mov	 ecx, DWORD PTR _result$[ebp+16]
  00472	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00475	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@CheckSWCap:

; 574  : }

  00478	52		 push	 edx
  00479	8b cd		 mov	 ecx, ebp
  0047b	50		 push	 eax
  0047c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@CheckSWCap
  00482	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00487	58		 pop	 eax
  00488	5a		 pop	 edx
  00489	5f		 pop	 edi
  0048a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0048d	33 cd		 xor	 ecx, ebp
  0048f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00494	83 c4 7c	 add	 esp, 124		; 0000007cH
  00497	3b ec		 cmp	 ebp, esp
  00499	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0049e	8b e5		 mov	 esp, ebp
  004a0	5d		 pop	 ebp
  004a1	c2 10 00	 ret	 16			; 00000010H
$LN27@CheckSWCap:
  004a4	01 00 00 00	 DD	 1
  004a8	00 00 00 00	 DD	 $LN26@CheckSWCap
$LN26@CheckSWCap:
  004ac	e0 ff ff ff	 DD	 -32			; ffffffe0H
  004b0	14 00 00 00	 DD	 20			; 00000014H
  004b4	00 00 00 00	 DD	 $LN25@CheckSWCap
$LN25@CheckSWCap:
  004b8	72		 DB	 114			; 00000072H
  004b9	65		 DB	 101			; 00000065H
  004ba	73		 DB	 115			; 00000073H
  004bb	75		 DB	 117			; 00000075H
  004bc	6c		 DB	 108			; 0000006cH
  004bd	74		 DB	 116			; 00000074H
  004be	00		 DB	 0
?CheckSWCapture@CON@@QBE?AUSWVALUE@@IIPAUPossibleMove@@@Z ENDP ; CON::CheckSWCapture
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\SWEvaluate.cpp
_TEXT	SEGMENT
$T2 = -5908						; size = 20
$T3 = -5888						; size = 20
_decline$4 = -5868					; size = 4
_total$5 = -5864					; size = 4
_ourNewMin$6 = -5860					; size = 4
_ourNewMinW$7 = -5856					; size = 4
_ourNewMinV$8 = -5852					; size = 4
_hisNewMinW$9 = -5848					; size = 4
_hisNewMinV$10 = -5844					; size = 4
_hisNewScoreW$11 = -5840				; size = 4
_hisNewScoreV$12 = -5836				; size = 4
_w$13 = -5828						; size = 20
_v$14 = -5800						; size = 20
$T15 = -5776						; size = 20
_value$16 = -5752					; size = 20
_cpm$17 = -5728						; size = 4
_n$18 = -5724						; size = 4
_t$19 = -5717						; size = 1
_k$20 = -5716						; size = 4
_j$21 = -5712						; size = 4
_i$22 = -5708						; size = 4
_ns$23 = -5704						; size = 4
_nimcon$24 = -5696					; size = 5136
_n$25 = -556						; size = 4
_len$26 = -552						; size = 4
_len$27 = -548						; size = 4
_len$28 = -544						; size = 4
_longLen$29 = -540					; size = 4
_nnB$30 = -536						; size = 4
_ec$31 = -532						; size = 4
_en$32 = -528						; size = 4
_result$ = -520						; size = 20
_mams$ = -492						; size = 4
_npm$ = -484						; size = 4
_sortedMoves$ = -476					; size = 440
_cpm$ = -32						; size = 4
_nnA$ = -28						; size = 4
_nn$ = -24						; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_ourScore$ = 12						; size = 4
_hisScore$ = 16						; size = 4
_pm$ = 20						; size = 4
?SWEvaluateAllMoves@CON@@QBE?AUSWVALUE@@IIPAUPossibleMove@@@Z PROC ; CON::SWEvaluateAllMoves
; _this$ = ecx

; 589  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SWEvaluateAllMoves@CON@@QBE?AUSWVALUE@@IIPAUPossibleMove@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 08 17 00 00	 mov	 eax, 5896		; 00001708H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	51		 push	 ecx
  0001e	8d bd ec e8 ff
	ff		 lea	 edi, DWORD PTR [ebp-5908]
  00024	b9 c2 05 00 00	 mov	 ecx, 1474		; 000005c2H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	59		 pop	 ecx
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00036	33 c5		 xor	 eax, ebp
  00038	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003b	50		 push	 eax
  0003c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00045	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 590  :   int nn, nnA;
; 591  :   PossibleMove *cpm = pm-1;

  00048	8b 45 14	 mov	 eax, DWORD PTR _pm$[ebp]
  0004b	2d 1c 14 00 00	 sub	 eax, 5148		; 0000141cH
  00050	89 45 e0	 mov	 DWORD PTR _cpm$[ebp], eax

; 592  :   ui8 sortedMoves[MAX_NODES*4];
; 593  :   int npm;
; 594  : #ifdef _DEBUG
; 595  :   MarkAvailableMoveStack mams;

  00053	8d 8d 14 fe ff
	ff		 lea	 ecx, DWORD PTR _mams$[ebp]
  00059	e8 00 00 00 00	 call	 ??0MarkAvailableMoveStack@@QAE@XZ ; MarkAvailableMoveStack::MarkAvailableMoveStack
  0005e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 596  : #endif
; 597  : #ifdef _CHECK
; 598  :   CheckEverything(0, m_numNode, true);
; 599  : #endif
; 600  : #ifdef SW_DUMP
; 601  :   static int id=0;
; 602  :   int myId = ++id;
; 603  :   if (myId == 459749)
; 604  :   {
; 605  :     int kkk=1;
; 606  :   };
; 607  :   LOGUIUI("SWEvaluateAllMoves id=%d",myId,0);
; 608  :   this->DUMP("EvaluateAllMoves",myId,ourScore,hisScore,0,m_numNode);
; 609  : //  enableDump = false;
; 610  : #endif
; 611  : //  int loopCount = 0, chainCount = 0; //Isolated loops and chains
; 612  : //  LINKTYPE lt;
; 613  :   SWVALUE result;
; 614  :   result.player1Min = 0;

  00065	33 c9		 xor	 ecx, ecx
  00067	66 89 8d f8 fd
	ff ff		 mov	 WORD PTR _result$[ebp], cx

; 615  :   result.player2Min = MAX_NODES + 1;

  0006e	ba 6f 00 00 00	 mov	 edx, 111		; 0000006fH
  00073	66 89 95 fa fd
	ff ff		 mov	 WORD PTR _result$[ebp+2], dx

; 616  :   result.bestMove = -1;

  0007a	c7 85 fc fd ff
	ff ff ff ff ff	 mov	 DWORD PTR _result$[ebp+4], -1

; 617  :   result.numPossibleMove = 0;

  00084	c7 85 04 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _result$[ebp+12], 0

; 618  :   result.allNimvalComputed = true;

  0008e	c6 85 08 fe ff
	ff 01		 mov	 BYTE PTR _result$[ebp+16], 1

; 619  :   {
; 620  :   //There are generally no capturing moves.  
; 621  :   //The previous mover would have removed them at 
; 622  :   //less cost than having us search for them.
; 623  :   //However, at startup the user may have presented
; 624  :   //us with capturable coins.  If we find any
; 625  :   //during our tour of the nodes then we quit right
; 626  :   //there and quit trying any other moves.  Taking
; 627  :   //them has to be the right thing to do.  If we
; 628  :   //have any choice we will both try taking them all
; 629  :   //and try the hard-hearted handout.
; 630  :   // 
; 631  :   //We go throungh the nodes and make list of all
; 632  :   //possible positions after a single move.  We rate each
; 633  :   //of the possibilities.  The rating is based on
; 634  :   //two things:
; 635  :   // 1 - The nimstring value - smaller is better.
; 636  :   // 2 - The number of coins offered our opponent - smaller is better.
; 637  :   // 3   provided both are short or both are long.
; 638  :     for (nn=0; nn<m_numNode; nn++)

  00095	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _nn$[ebp], 0
  0009c	eb 09		 jmp	 SHORT $LN4@SWEvaluate
$LN2@SWEvaluate:
  0009e	8b 45 e8	 mov	 eax, DWORD PTR _nn$[ebp]
  000a1	83 c0 01	 add	 eax, 1
  000a4	89 45 e8	 mov	 DWORD PTR _nn$[ebp], eax
$LN4@SWEvaluate:
  000a7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	8b 55 e8	 mov	 edx, DWORD PTR _nn$[ebp]
  000ad	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000af	0f 8d 6d 05 00
	00		 jge	 $LN3@SWEvaluate

; 639  :     {
; 640  :       int en, ec, nnB;
; 641  :       nnA = nd[nn].ix;

  000b5	8b 45 e8	 mov	 eax, DWORD PTR _nn$[ebp]
  000b8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	0f b6 94 81 13
	10 00 00	 movzx	 edx, BYTE PTR [ecx+eax*4+4115]
  000c3	89 55 e4	 mov	 DWORD PTR _nnA$[ebp], edx

; 642  :       if (IS_ISOLATED(sd[nnA][0].ns))

  000c6	8b 45 e4	 mov	 eax, DWORD PTR _nnA$[ebp]
  000c9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000cc	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  000d3	b8 02 00 00 00	 mov	 eax, 2
  000d8	6b c8 00	 imul	 ecx, eax, 0
  000db	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  000df	81 fa fa 00 00
	00		 cmp	 edx, 250		; 000000faH
  000e5	0f 8e 01 03 00
	00		 jle	 $LN26@SWEvaluate

; 643  :       {
; 644  :         if (nn < m_numNode-1)

  000eb	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000ee	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f0	83 e9 01	 sub	 ecx, 1
  000f3	39 4d e8	 cmp	 DWORD PTR _nn$[ebp], ecx
  000f6	0f 8d 08 01 00
	00		 jge	 $LN27@SWEvaluate

; 645  :         {
; 646  :           nnB = nd[nn+1].ix;

  000fc	8b 55 e8	 mov	 edx, DWORD PTR _nn$[ebp]
  000ff	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00102	0f b6 8c 90 17
	10 00 00	 movzx	 ecx, BYTE PTR [eax+edx*4+4119]
  0010a	89 8d e8 fd ff
	ff		 mov	 DWORD PTR _nnB$30[ebp], ecx

; 647  :           if (sd[nnA][0].ns == sd[nnB][0].ns)

  00110	8b 55 e4	 mov	 edx, DWORD PTR _nnA$[ebp]
  00113	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00116	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  0011d	ba 02 00 00 00	 mov	 edx, 2
  00122	6b c2 00	 imul	 eax, edx, 0
  00125	0f b6 0c 01	 movzx	 ecx, BYTE PTR [ecx+eax]
  00129	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR _nnB$30[ebp]
  0012f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00132	8d 94 d0 10 08
	00 00		 lea	 edx, DWORD PTR [eax+edx*8+2064]
  00139	b8 02 00 00 00	 mov	 eax, 2
  0013e	6b c0 00	 imul	 eax, eax, 0
  00141	0f b6 14 02	 movzx	 edx, BYTE PTR [edx+eax]
  00145	3b ca		 cmp	 ecx, edx
  00147	0f 85 b7 00 00
	00		 jne	 $LN27@SWEvaluate

; 648  :           {
; 649  :             //The shorter one comes later.
; 650  :             int longLen;
; 651  :             if (sd[nnA][0].ns == GND_GND) longLen = 3;

  0014d	8b 45 e4	 mov	 eax, DWORD PTR _nnA$[ebp]
  00150	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00153	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  0015a	b8 02 00 00 00	 mov	 eax, 2
  0015f	6b c8 00	 imul	 ecx, eax, 0
  00162	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  00166	81 fa fd 00 00
	00		 cmp	 edx, 253		; 000000fdH
  0016c	75 0c		 jne	 SHORT $LN29@SWEvaluate
  0016e	c7 85 e4 fd ff
	ff 03 00 00 00	 mov	 DWORD PTR _longLen$29[ebp], 3
  00178	eb 44		 jmp	 SHORT $LN30@SWEvaluate
$LN29@SWEvaluate:

; 652  :             else if (sd[nnA][0].ns == LOOP) longLen = 4;

  0017a	8b 45 e4	 mov	 eax, DWORD PTR _nnA$[ebp]
  0017d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00180	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  00187	b8 02 00 00 00	 mov	 eax, 2
  0018c	6b c8 00	 imul	 ecx, eax, 0
  0018f	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  00193	81 fa fe 00 00
	00		 cmp	 edx, 254		; 000000feH
  00199	75 0c		 jne	 SHORT $LN31@SWEvaluate
  0019b	c7 85 e4 fd ff
	ff 04 00 00 00	 mov	 DWORD PTR _longLen$29[ebp], 4
  001a5	eb 17		 jmp	 SHORT $LN30@SWEvaluate
$LN31@SWEvaluate:

; 653  :             else 
; 654  :             {
; 655  :               longLen = 0; //keep compiler quiet

  001a7	c7 85 e4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _longLen$29[ebp], 0

; 656  :               ImplementationError("Unknown isolated chain type");

  001b1	68 00 00 00 00	 push	 OFFSET $SG225717
  001b6	e8 00 00 00 00	 call	 ?ImplementationError@@YAXPBD@Z ; ImplementationError
  001bb	83 c4 04	 add	 esp, 4
$LN30@SWEvaluate:

; 657  :             };
; 658  :             if ((ed[nnA].e[0].el < longLen) || (ed[nnB].e[0].el >= longLen))

  001be	8b 45 e4	 mov	 eax, DWORD PTR _nnA$[ebp]
  001c1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001c4	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  001c8	b8 02 00 00 00	 mov	 eax, 2
  001cd	6b c8 00	 imul	 ecx, eax, 0
  001d0	0f b6 54 0a 01	 movzx	 edx, BYTE PTR [edx+ecx+1]
  001d5	3b 95 e4 fd ff
	ff		 cmp	 edx, DWORD PTR _longLen$29[ebp]
  001db	7c 22		 jl	 SHORT $LN34@SWEvaluate
  001dd	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _nnB$30[ebp]
  001e3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001e6	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  001ea	b8 02 00 00 00	 mov	 eax, 2
  001ef	6b c8 00	 imul	 ecx, eax, 0
  001f2	0f b6 54 0a 01	 movzx	 edx, BYTE PTR [edx+ecx+1]
  001f7	3b 95 e4 fd ff
	ff		 cmp	 edx, DWORD PTR _longLen$29[ebp]
  001fd	7c 05		 jl	 SHORT $LN27@SWEvaluate
$LN34@SWEvaluate:

; 659  :             {
; 660  :               continue;

  001ff	e9 9a fe ff ff	 jmp	 $LN2@SWEvaluate
$LN27@SWEvaluate:

; 661  :             };
; 662  :           };
; 663  :         };
; 664  :         if (sd[nnA][0].ns == GND_GND)

  00204	8b 45 e4	 mov	 eax, DWORD PTR _nnA$[ebp]
  00207	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0020a	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  00211	b8 02 00 00 00	 mov	 eax, 2
  00216	6b c8 00	 imul	 ecx, eax, 0
  00219	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  0021d	81 fa fd 00 00
	00		 cmp	 edx, 253		; 000000fdH
  00223	0f 85 ca 00 00
	00		 jne	 $LN35@SWEvaluate

; 665  :         {
; 666  :           int len;
; 667  :           len = ed[nnA].e[0].el;

  00229	8b 45 e4	 mov	 eax, DWORD PTR _nnA$[ebp]
  0022c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0022f	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  00233	b8 02 00 00 00	 mov	 eax, 2
  00238	6b c8 00	 imul	 ecx, eax, 0
  0023b	0f b6 54 0a 01	 movzx	 edx, BYTE PTR [edx+ecx+1]
  00240	89 95 e0 fd ff
	ff		 mov	 DWORD PTR _len$28[ebp], edx

; 668  :           if (len + hisScore >= m_neededToWin) 

  00246	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _len$28[ebp]
  0024c	03 45 10	 add	 eax, DWORD PTR _hisScore$[ebp]
  0024f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00252	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00255	72 22		 jb	 SHORT $LN37@SWEvaluate

; 669  :           {
; 670  :             if (len < result.player2Min) result.player2Min = (ui16)len;

  00257	0f b7 95 fa fd
	ff ff		 movzx	 edx, WORD PTR _result$[ebp+2]
  0025e	39 95 e0 fd ff
	ff		 cmp	 DWORD PTR _len$28[ebp], edx
  00264	7d 0e		 jge	 SHORT $LN38@SWEvaluate
  00266	66 8b 85 e0 fd
	ff ff		 mov	 ax, WORD PTR _len$28[ebp]
  0026d	66 89 85 fa fd
	ff ff		 mov	 WORD PTR _result$[ebp+2], ax
$LN38@SWEvaluate:

; 671  :             continue;

  00274	e9 25 fe ff ff	 jmp	 $LN2@SWEvaluate
$LN37@SWEvaluate:

; 672  :           };
; 673  :           COPYPOS

  00279	8b 4d e0	 mov	 ecx, DWORD PTR _cpm$[ebp]
  0027c	81 c1 1c 14 00
	00		 add	 ecx, 5148		; 0000141cH
  00282	89 4d e0	 mov	 DWORD PTR _cpm$[ebp], ecx
  00285	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00288	52		 push	 edx
  00289	8b 4d e0	 mov	 ecx, DWORD PTR _cpm$[ebp]
  0028c	83 c1 08	 add	 ecx, 8
  0028f	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=
  00294	8b 45 e0	 mov	 eax, DWORD PTR _cpm$[ebp]
  00297	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0029e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?availableMoveStack@@3HA ; availableMoveStack
  002a4	83 e9 01	 sub	 ecx, 1
  002a7	89 0d 00 00 00
	00		 mov	 DWORD PTR ?availableMoveStack@@3HA, ecx ; availableMoveStack
  002ad	75 0d		 jne	 SHORT $LN39@SWEvaluate
  002af	68 00 00 00 00	 push	 OFFSET $SG225725
  002b4	e8 00 00 00 00	 call	 ?ImplementationError@@YAXPBD@Z ; ImplementationError
  002b9	83 c4 04	 add	 esp, 4
$LN39@SWEvaluate:

; 674  :           cpm->offering = len;

  002bc	8b 55 e0	 mov	 edx, DWORD PTR _cpm$[ebp]
  002bf	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _len$28[ebp]
  002c5	89 02		 mov	 DWORD PTR [edx], eax

; 675  :           if (len > 2) cpm->nimval = LOONY2;

  002c7	83 bd e0 fd ff
	ff 02		 cmp	 DWORD PTR _len$28[ebp], 2
  002ce	7e 0a		 jle	 SHORT $LN40@SWEvaluate
  002d0	8b 4d e0	 mov	 ecx, DWORD PTR _cpm$[ebp]
  002d3	c7 41 04 fe ff
	ff ff		 mov	 DWORD PTR [ecx+4], -2	; fffffffeH
$LN40@SWEvaluate:

; 676  :           cpm->con.DeleteNode(nn);

  002da	8b 55 e8	 mov	 edx, DWORD PTR _nn$[ebp]
  002dd	52		 push	 edx
  002de	8b 4d e0	 mov	 ecx, DWORD PTR _cpm$[ebp]
  002e1	83 c1 08	 add	 ecx, 8
  002e4	e8 00 00 00 00	 call	 ?DeleteNode@CON@@QAEXH@Z ; CON::DeleteNode

; 677  :           continue;

  002e9	e9 b0 fd ff ff	 jmp	 $LN2@SWEvaluate

; 678  :         }

  002ee	e9 f9 00 00 00	 jmp	 $LN26@SWEvaluate
$LN35@SWEvaluate:

; 679  :         else if (sd[nnA][0].ns == LOOP)

  002f3	8b 45 e4	 mov	 eax, DWORD PTR _nnA$[ebp]
  002f6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002f9	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  00300	b8 02 00 00 00	 mov	 eax, 2
  00305	6b c8 00	 imul	 ecx, eax, 0
  00308	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  0030c	81 fa fe 00 00
	00		 cmp	 edx, 254		; 000000feH
  00312	0f 85 c7 00 00
	00		 jne	 $LN41@SWEvaluate

; 680  :         {
; 681  :           int len;
; 682  :           len = ed[nnA].e[0].el;

  00318	8b 45 e4	 mov	 eax, DWORD PTR _nnA$[ebp]
  0031b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0031e	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  00322	b8 02 00 00 00	 mov	 eax, 2
  00327	6b c8 00	 imul	 ecx, eax, 0
  0032a	0f b6 54 0a 01	 movzx	 edx, BYTE PTR [edx+ecx+1]
  0032f	89 95 dc fd ff
	ff		 mov	 DWORD PTR _len$27[ebp], edx

; 683  :           if (len + hisScore >= m_neededToWin)

  00335	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _len$27[ebp]
  0033b	03 45 10	 add	 eax, DWORD PTR _hisScore$[ebp]
  0033e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00341	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00344	72 22		 jb	 SHORT $LN43@SWEvaluate

; 684  :           {
; 685  :             if (len < result.player2Min) result.player2Min = (ui16)len;

  00346	0f b7 95 fa fd
	ff ff		 movzx	 edx, WORD PTR _result$[ebp+2]
  0034d	39 95 dc fd ff
	ff		 cmp	 DWORD PTR _len$27[ebp], edx
  00353	7d 0e		 jge	 SHORT $LN44@SWEvaluate
  00355	66 8b 85 dc fd
	ff ff		 mov	 ax, WORD PTR _len$27[ebp]
  0035c	66 89 85 fa fd
	ff ff		 mov	 WORD PTR _result$[ebp+2], ax
$LN44@SWEvaluate:

; 686  :             continue;

  00363	e9 36 fd ff ff	 jmp	 $LN2@SWEvaluate
$LN43@SWEvaluate:

; 687  :           };
; 688  :           COPYPOS

  00368	8b 4d e0	 mov	 ecx, DWORD PTR _cpm$[ebp]
  0036b	81 c1 1c 14 00
	00		 add	 ecx, 5148		; 0000141cH
  00371	89 4d e0	 mov	 DWORD PTR _cpm$[ebp], ecx
  00374	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00377	52		 push	 edx
  00378	8b 4d e0	 mov	 ecx, DWORD PTR _cpm$[ebp]
  0037b	83 c1 08	 add	 ecx, 8
  0037e	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=
  00383	8b 45 e0	 mov	 eax, DWORD PTR _cpm$[ebp]
  00386	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0038d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?availableMoveStack@@3HA ; availableMoveStack
  00393	83 e9 01	 sub	 ecx, 1
  00396	89 0d 00 00 00
	00		 mov	 DWORD PTR ?availableMoveStack@@3HA, ecx ; availableMoveStack
  0039c	75 0d		 jne	 SHORT $LN45@SWEvaluate
  0039e	68 00 00 00 00	 push	 OFFSET $SG225732
  003a3	e8 00 00 00 00	 call	 ?ImplementationError@@YAXPBD@Z ; ImplementationError
  003a8	83 c4 04	 add	 esp, 4
$LN45@SWEvaluate:

; 689  :           cpm->offering = len;

  003ab	8b 55 e0	 mov	 edx, DWORD PTR _cpm$[ebp]
  003ae	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _len$27[ebp]
  003b4	89 02		 mov	 DWORD PTR [edx], eax

; 690  :           if (len > 3) cpm->nimval = LOONY4;

  003b6	83 bd dc fd ff
	ff 03		 cmp	 DWORD PTR _len$27[ebp], 3
  003bd	7e 0a		 jle	 SHORT $LN46@SWEvaluate
  003bf	8b 4d e0	 mov	 ecx, DWORD PTR _cpm$[ebp]
  003c2	c7 41 04 fc ff
	ff ff		 mov	 DWORD PTR [ecx+4], -4	; fffffffcH
$LN46@SWEvaluate:

; 691  :           cpm->con.DeleteNode(nn);

  003c9	8b 55 e8	 mov	 edx, DWORD PTR _nn$[ebp]
  003cc	52		 push	 edx
  003cd	8b 4d e0	 mov	 ecx, DWORD PTR _cpm$[ebp]
  003d0	83 c1 08	 add	 ecx, 8
  003d3	e8 00 00 00 00	 call	 ?DeleteNode@CON@@QAEXH@Z ; CON::DeleteNode

; 692  :           continue;

  003d8	e9 c1 fc ff ff	 jmp	 $LN2@SWEvaluate

; 693  :         }

  003dd	eb 0d		 jmp	 SHORT $LN26@SWEvaluate
$LN41@SWEvaluate:

; 694  :         else
; 695  :         {
; 696  :           NotImplemented("Unknown isolated chain");

  003df	68 00 00 00 00	 push	 OFFSET $SG225734
  003e4	e8 00 00 00 00	 call	 ?NotImplemented@@YAXPAD@Z ; NotImplemented
  003e9	83 c4 04	 add	 esp, 4
$LN26@SWEvaluate:

; 697  :         };
; 698  :       };
; 699  :       if ((nn>0) && (ed[nnA] == ed[nd[nn-1].ix])) continue;

  003ec	83 7d e8 00	 cmp	 DWORD PTR _nn$[ebp], 0
  003f0	7e 31		 jle	 SHORT $LN47@SWEvaluate
  003f2	8b 45 e8	 mov	 eax, DWORD PTR _nn$[ebp]
  003f5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  003f8	0f b6 94 81 0f
	10 00 00	 movzx	 edx, BYTE PTR [ecx+eax*4+4111]
  00400	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00403	8d 4c d0 10	 lea	 ecx, DWORD PTR [eax+edx*8+16]
  00407	51		 push	 ecx
  00408	8b 55 e4	 mov	 edx, DWORD PTR _nnA$[ebp]
  0040b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0040e	8d 4c d0 10	 lea	 ecx, DWORD PTR [eax+edx*8+16]
  00412	e8 00 00 00 00	 call	 ??8EDGEDATA@@QBE_NABU0@@Z ; EDGEDATA::operator==
  00417	0f b6 c8	 movzx	 ecx, al
  0041a	85 c9		 test	 ecx, ecx
  0041c	74 05		 je	 SHORT $LN47@SWEvaluate
  0041e	e9 7b fc ff ff	 jmp	 $LN2@SWEvaluate
$LN47@SWEvaluate:

; 700  :       ec = nd[nnA].ec;

  00423	8b 55 e4	 mov	 edx, DWORD PTR _nnA$[ebp]
  00426	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00429	0f b6 8c 90 10
	10 00 00	 movzx	 ecx, BYTE PTR [eax+edx*4+4112]
  00431	89 8d ec fd ff
	ff		 mov	 DWORD PTR _ec$31[ebp], ecx

; 701  :       for (en=0; en<ec; en++)

  00437	c7 85 f0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _en$32[ebp], 0
  00441	eb 0f		 jmp	 SHORT $LN7@SWEvaluate
$LN5@SWEvaluate:
  00443	8b 95 f0 fd ff
	ff		 mov	 edx, DWORD PTR _en$32[ebp]
  00449	83 c2 01	 add	 edx, 1
  0044c	89 95 f0 fd ff
	ff		 mov	 DWORD PTR _en$32[ebp], edx
$LN7@SWEvaluate:
  00452	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _en$32[ebp]
  00458	3b 85 ec fd ff
	ff		 cmp	 eax, DWORD PTR _ec$31[ebp]
  0045e	0f 8d b9 01 00
	00		 jge	 $LN6@SWEvaluate

; 702  :       {
; 703  :         int len;
; 704  :         if ((en>0) && (ed[nnA].e[en-1] == ed[nnA].e[en])) 

  00464	83 bd f0 fd ff
	ff 00		 cmp	 DWORD PTR _en$32[ebp], 0
  0046b	7e 53		 jle	 SHORT $LN48@SWEvaluate
  0046d	8b 4d e4	 mov	 ecx, DWORD PTR _nnA$[ebp]
  00470	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00473	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  00477	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _en$32[ebp]
  0047d	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  00480	52		 push	 edx
  00481	8b 45 e4	 mov	 eax, DWORD PTR _nnA$[ebp]
  00484	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00487	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  0048b	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _en$32[ebp]
  00491	8d 4c 42 fe	 lea	 ecx, DWORD PTR [edx+eax*2-2]
  00495	e8 00 00 00 00	 call	 ??8EDGE@@QBE_NABU0@@Z	; EDGE::operator==
  0049a	0f b6 c8	 movzx	 ecx, al
  0049d	85 c9		 test	 ecx, ecx
  0049f	74 1f		 je	 SHORT $LN48@SWEvaluate

; 705  :         {
; 706  :           if (sd[nnA][en-1].ns != nnA)

  004a1	8b 55 e4	 mov	 edx, DWORD PTR _nnA$[ebp]
  004a4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  004a7	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  004ae	8b 95 f0 fd ff
	ff		 mov	 edx, DWORD PTR _en$32[ebp]
  004b4	0f b6 44 51 fe	 movzx	 eax, BYTE PTR [ecx+edx*2-2]
  004b9	3b 45 e4	 cmp	 eax, DWORD PTR _nnA$[ebp]
  004bc	74 02		 je	 SHORT $LN48@SWEvaluate

; 707  :           {
; 708  :             continue;

  004be	eb 83		 jmp	 SHORT $LN5@SWEvaluate
$LN48@SWEvaluate:

; 709  :           };
; 710  :         };
; 711  :         nnB = sd[nnA][en].ns;

  004c0	8b 4d e4	 mov	 ecx, DWORD PTR _nnA$[ebp]
  004c3	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  004c6	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  004cd	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _en$32[ebp]
  004d3	0f b6 14 48	 movzx	 edx, BYTE PTR [eax+ecx*2]
  004d7	89 95 e8 fd ff
	ff		 mov	 DWORD PTR _nnB$30[ebp], edx

; 712  :         if (IS_A_NODE(nnB) && (nd[nnB].os < nn)) continue; //Only one direction, please

  004dd	81 bd e8 fd ff
	ff f9 00 00 00	 cmp	 DWORD PTR _nnB$30[ebp], 249 ; 000000f9H
  004e7	7d 1b		 jge	 SHORT $LN50@SWEvaluate
  004e9	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _nnB$30[ebp]
  004ef	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  004f2	0f b6 94 81 12
	10 00 00	 movzx	 edx, BYTE PTR [ecx+eax*4+4114]
  004fa	3b 55 e8	 cmp	 edx, DWORD PTR _nn$[ebp]
  004fd	7d 05		 jge	 SHORT $LN50@SWEvaluate
  004ff	e9 3f ff ff ff	 jmp	 $LN5@SWEvaluate
$LN50@SWEvaluate:

; 713  :         if (nnB == DEADEND)

  00504	81 bd e8 fd ff
	ff f9 00 00 00	 cmp	 DWORD PTR _nnB$30[ebp], 249 ; 000000f9H
  0050e	75 0d		 jne	 SHORT $LN51@SWEvaluate

; 714  :         {
; 715  :           //Well, this is unexpected (in general).  But taking
; 716  :           //all these coins and/or offering a double-cross
; 717  :           //is guaranteed to be a proper move.
; 718  :           //LOGUIUI("Zero Length string=%d, link=%d", stringNum, ln);
; 719  :           NotImplemented("Capturable to joint");

  00510	68 00 00 00 00	 push	 OFFSET $SG225740
  00515	e8 00 00 00 00	 call	 ?NotImplemented@@YAXPAD@Z ; NotImplemented
  0051a	83 c4 04	 add	 esp, 4
$LN51@SWEvaluate:

; 720  :         };
; 721  :         len = ed[nnA].e[en].el;

  0051d	8b 45 e4	 mov	 eax, DWORD PTR _nnA$[ebp]
  00520	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00523	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  00527	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _en$32[ebp]
  0052d	0f b6 4c 42 01	 movzx	 ecx, BYTE PTR [edx+eax*2+1]
  00532	89 8d d8 fd ff
	ff		 mov	 DWORD PTR _len$26[ebp], ecx

; 722  :         if (nnB == nnA)

  00538	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR _nnB$30[ebp]
  0053e	3b 55 e4	 cmp	 edx, DWORD PTR _nnA$[ebp]
  00541	75 2b		 jne	 SHORT $LN52@SWEvaluate

; 723  :         {
; 724  :           //A loop to ourselves.  A loony move at best.
; 725  :           if (ec == 3) 

  00543	83 bd ec fd ff
	ff 03		 cmp	 DWORD PTR _ec$31[ebp], 3
  0054a	75 22		 jne	 SHORT $LN52@SWEvaluate

; 726  :           {
; 727  :             if (m_coinsRemaining < result.player2Min) 

  0054c	0f b7 85 fa fd
	ff ff		 movzx	 eax, WORD PTR _result$[ebp+2]
  00553	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00556	39 41 04	 cmp	 DWORD PTR [ecx+4], eax
  00559	73 0e		 jae	 SHORT $LN54@SWEvaluate

; 728  :                          result.player2Min = (ui16)m_coinsRemaining;

  0055b	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0055e	66 8b 42 04	 mov	 ax, WORD PTR [edx+4]
  00562	66 89 85 fa fd
	ff ff		 mov	 WORD PTR _result$[ebp+2], ax
$LN54@SWEvaluate:

; 729  :             continue; //I cannot see how this would help us

  00569	e9 d5 fe ff ff	 jmp	 $LN5@SWEvaluate
$LN52@SWEvaluate:

; 730  :           };
; 731  :         };
; 732  :         if (len + hisScore >= m_neededToWin) 

  0056e	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _len$26[ebp]
  00574	03 4d 10	 add	 ecx, DWORD PTR _hisScore$[ebp]
  00577	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0057a	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  0057d	72 22		 jb	 SHORT $LN55@SWEvaluate

; 733  :         {
; 734  :           if (len < result.player2Min) result.player2Min = (ui16)len;

  0057f	0f b7 85 fa fd
	ff ff		 movzx	 eax, WORD PTR _result$[ebp+2]
  00586	39 85 d8 fd ff
	ff		 cmp	 DWORD PTR _len$26[ebp], eax
  0058c	7d 0e		 jge	 SHORT $LN56@SWEvaluate
  0058e	66 8b 8d d8 fd
	ff ff		 mov	 cx, WORD PTR _len$26[ebp]
  00595	66 89 8d fa fd
	ff ff		 mov	 WORD PTR _result$[ebp+2], cx
$LN56@SWEvaluate:

; 735  :           continue;

  0059c	e9 a2 fe ff ff	 jmp	 $LN5@SWEvaluate
$LN55@SWEvaluate:

; 736  :         };
; 737  :         COPYPOS

  005a1	8b 55 e0	 mov	 edx, DWORD PTR _cpm$[ebp]
  005a4	81 c2 1c 14 00
	00		 add	 edx, 5148		; 0000141cH
  005aa	89 55 e0	 mov	 DWORD PTR _cpm$[ebp], edx
  005ad	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  005b0	50		 push	 eax
  005b1	8b 4d e0	 mov	 ecx, DWORD PTR _cpm$[ebp]
  005b4	83 c1 08	 add	 ecx, 8
  005b7	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=
  005bc	8b 4d e0	 mov	 ecx, DWORD PTR _cpm$[ebp]
  005bf	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  005c6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?availableMoveStack@@3HA ; availableMoveStack
  005cc	83 ea 01	 sub	 edx, 1
  005cf	89 15 00 00 00
	00		 mov	 DWORD PTR ?availableMoveStack@@3HA, edx ; availableMoveStack
  005d5	75 0d		 jne	 SHORT $LN57@SWEvaluate
  005d7	68 00 00 00 00	 push	 OFFSET $SG225747
  005dc	e8 00 00 00 00	 call	 ?ImplementationError@@YAXPBD@Z ; ImplementationError
  005e1	83 c4 04	 add	 esp, 4
$LN57@SWEvaluate:

; 738  :         cpm->offering = len;

  005e4	8b 45 e0	 mov	 eax, DWORD PTR _cpm$[ebp]
  005e7	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _len$26[ebp]
  005ed	89 08		 mov	 DWORD PTR [eax], ecx

; 739  :         if (len > 2) cpm->nimval = LOONY2;

  005ef	83 bd d8 fd ff
	ff 02		 cmp	 DWORD PTR _len$26[ebp], 2
  005f6	7e 0a		 jle	 SHORT $LN58@SWEvaluate
  005f8	8b 55 e0	 mov	 edx, DWORD PTR _cpm$[ebp]
  005fb	c7 42 04 fe ff
	ff ff		 mov	 DWORD PTR [edx+4], -2	; fffffffeH
$LN58@SWEvaluate:

; 740  :         cpm->con.DeleteEdge(nn, en);

  00602	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _en$32[ebp]
  00608	50		 push	 eax
  00609	8b 4d e8	 mov	 ecx, DWORD PTR _nn$[ebp]
  0060c	51		 push	 ecx
  0060d	8b 4d e0	 mov	 ecx, DWORD PTR _cpm$[ebp]
  00610	83 c1 08	 add	 ecx, 8
  00613	e8 00 00 00 00	 call	 ?DeleteEdge@CON@@QAEXHH@Z ; CON::DeleteEdge

; 741  :       }; //for each link	hisScore	0x0000000d

  00618	e9 26 fe ff ff	 jmp	 $LN5@SWEvaluate
$LN6@SWEvaluate:

; 742  : 
; 743  :     };

  0061d	e9 7c fa ff ff	 jmp	 $LN2@SWEvaluate
$LN3@SWEvaluate:

; 744  :   };
; 745  :   npm = cpm - pm + 1;

  00622	8b 45 e0	 mov	 eax, DWORD PTR _cpm$[ebp]
  00625	2b 45 14	 sub	 eax, DWORD PTR _pm$[ebp]
  00628	99		 cdq
  00629	b9 1c 14 00 00	 mov	 ecx, 5148		; 0000141cH
  0062e	f7 f9		 idiv	 ecx
  00630	83 c0 01	 add	 eax, 1
  00633	89 85 1c fe ff
	ff		 mov	 DWORD PTR _npm$[ebp], eax

; 746  :   //if (npm == 0) 
; 747  :   //{
; 748  :   //  result.player2Min = 0;
; 749  :   //};
; 750  :   result.numPossibleMove = npm;

  00639	8b 95 1c fe ff
	ff		 mov	 edx, DWORD PTR _npm$[ebp]
  0063f	89 95 04 fe ff
	ff		 mov	 DWORD PTR _result$[ebp+12], edx

; 751  :   {
; 752  :     //Sort the possible moves.
; 753  :     int n;
; 754  :     for (n=0; n<npm; n++)

  00645	c7 85 d4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$25[ebp], 0
  0064f	eb 0f		 jmp	 SHORT $LN10@SWEvaluate
$LN8@SWEvaluate:
  00651	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _n$25[ebp]
  00657	83 c0 01	 add	 eax, 1
  0065a	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _n$25[ebp], eax
$LN10@SWEvaluate:
  00660	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _n$25[ebp]
  00666	3b 8d 1c fe ff
	ff		 cmp	 ecx, DWORD PTR _npm$[ebp]
  0066c	0f 8d 1c 01 00
	00		 jge	 $LN9@SWEvaluate

; 755  :     {
; 756  :       NIMCON nimcon;

  00672	8d 8d c0 e9 ff
	ff		 lea	 ecx, DWORD PTR _nimcon$24[ebp]
  00678	e8 00 00 00 00	 call	 ??0NIMCON@@QAE@XZ
  0067d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 757  :       sortedMoves[n] = (ui8)n;

  00681	8b 95 d4 fd ff
	ff		 mov	 edx, DWORD PTR _n$25[ebp]
  00687	8a 85 d4 fd ff
	ff		 mov	 al, BYTE PTR _n$25[ebp]
  0068d	88 84 15 24 fe
	ff ff		 mov	 BYTE PTR _sortedMoves$[ebp+edx], al

; 758  :       if (pm[n].nimval == 0)

  00694	69 8d d4 fd ff
	ff 1c 14 00 00	 imul	 ecx, DWORD PTR _n$25[ebp], 5148
  0069e	8b 55 14	 mov	 edx, DWORD PTR _pm$[ebp]
  006a1	83 7c 0a 04 00	 cmp	 DWORD PTR [edx+ecx+4], 0
  006a6	0f 85 ce 00 00
	00		 jne	 $LN59@SWEvaluate

; 759  :       {
; 760  :         if (pm[n].con.m_numNode != 0)

  006ac	69 85 d4 fd ff
	ff 1c 14 00 00	 imul	 eax, DWORD PTR _n$25[ebp], 5148
  006b6	8b 4d 14	 mov	 ecx, DWORD PTR _pm$[ebp]
  006b9	83 7c 01 08 00	 cmp	 DWORD PTR [ecx+eax+8], 0
  006be	0f 84 b6 00 00
	00		 je	 $LN59@SWEvaluate

; 761  :         {
; 762  :           pm[n].nimval = nimcon.NimVal(&pm[n].con);

  006c4	69 95 d4 fd ff
	ff 1c 14 00 00	 imul	 edx, DWORD PTR _n$25[ebp], 5148
  006ce	8b 45 14	 mov	 eax, DWORD PTR _pm$[ebp]
  006d1	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  006d5	51		 push	 ecx
  006d6	8d 8d c0 e9 ff
	ff		 lea	 ecx, DWORD PTR _nimcon$24[ebp]
  006dc	e8 00 00 00 00	 call	 ?NimVal@NIMCON@@QAEHPBVCON@@@Z ; NIMCON::NimVal
  006e1	69 95 d4 fd ff
	ff 1c 14 00 00	 imul	 edx, DWORD PTR _n$25[ebp], 5148
  006eb	8b 4d 14	 mov	 ecx, DWORD PTR _pm$[ebp]
  006ee	89 44 11 04	 mov	 DWORD PTR [ecx+edx+4], eax

; 763  :           if (pm[n].nimval == 99)

  006f2	69 95 d4 fd ff
	ff 1c 14 00 00	 imul	 edx, DWORD PTR _n$25[ebp], 5148
  006fc	8b 45 14	 mov	 eax, DWORD PTR _pm$[ebp]
  006ff	83 7c 10 04 63	 cmp	 DWORD PTR [eax+edx+4], 99 ; 00000063H
  00704	75 74		 jne	 SHORT $LN59@SWEvaluate

; 764  :           {
; 765  :             result.numPossibleMove = n; //The only ones we have computed.

  00706	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _n$25[ebp]
  0070c	89 8d 04 fe ff
	ff		 mov	 DWORD PTR _result$[ebp+12], ecx

; 766  :             result.player2Min = 0;

  00712	33 d2		 xor	 edx, edx
  00714	66 89 95 fa fd
	ff ff		 mov	 WORD PTR _result$[ebp+2], dx

; 767  :             result.allNimvalComputed = false;

  0071b	c6 85 08 fe ff
	ff 00		 mov	 BYTE PTR _result$[ebp+16], 0

; 768  :             return result;

  00722	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00725	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR _result$[ebp]
  0072b	89 08		 mov	 DWORD PTR [eax], ecx
  0072d	8b 95 fc fd ff
	ff		 mov	 edx, DWORD PTR _result$[ebp+4]
  00733	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00736	8b 8d 00 fe ff
	ff		 mov	 ecx, DWORD PTR _result$[ebp+8]
  0073c	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0073f	8b 95 04 fe ff
	ff		 mov	 edx, DWORD PTR _result$[ebp+12]
  00745	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00748	8b 8d 08 fe ff
	ff		 mov	 ecx, DWORD PTR _result$[ebp+16]
  0074e	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00751	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00755	8d 8d c0 e9 ff
	ff		 lea	 ecx, DWORD PTR _nimcon$24[ebp]
  0075b	e8 00 00 00 00	 call	 ??1NIMCON@@QAE@XZ
  00760	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00767	8d 8d 14 fe ff
	ff		 lea	 ecx, DWORD PTR _mams$[ebp]
  0076d	e8 00 00 00 00	 call	 ??1MarkAvailableMoveStack@@QAE@XZ ; MarkAvailableMoveStack::~MarkAvailableMoveStack
  00772	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00775	e9 30 07 00 00	 jmp	 $LN1@SWEvaluate
$LN59@SWEvaluate:

; 769  :           };
; 770  :         };
; 771  :       };
; 772  :     };

  0077a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0077e	8d 8d c0 e9 ff
	ff		 lea	 ecx, DWORD PTR _nimcon$24[ebp]
  00784	e8 00 00 00 00	 call	 ??1NIMCON@@QAE@XZ
  00789	e9 c3 fe ff ff	 jmp	 $LN8@SWEvaluate
$LN9@SWEvaluate:

; 773  :     //Now that we have the nimval and the offering for
; 774  :     //each of the possible move, we will sort the possible
; 775  :     //moves so that we try the best moves first.
; 776  :     //A nimval of zero is best.  Then the lower offer is better.
; 777  :     //Then bigger nimvals are better (the Enough Rope principle).
; 778  :     {
; 779  :       unsigned int ns, i, j;
; 780  :       int k;
; 781  :       ui8 t;
; 782  :       for (ns=npm/2; ns>0; ns/=2)

  0078e	8b 85 1c fe ff
	ff		 mov	 eax, DWORD PTR _npm$[ebp]
  00794	99		 cdq
  00795	2b c2		 sub	 eax, edx
  00797	d1 f8		 sar	 eax, 1
  00799	89 85 b8 e9 ff
	ff		 mov	 DWORD PTR _ns$23[ebp], eax
  0079f	eb 0e		 jmp	 SHORT $LN13@SWEvaluate
$LN11@SWEvaluate:
  007a1	8b 95 b8 e9 ff
	ff		 mov	 edx, DWORD PTR _ns$23[ebp]
  007a7	d1 ea		 shr	 edx, 1
  007a9	89 95 b8 e9 ff
	ff		 mov	 DWORD PTR _ns$23[ebp], edx
$LN13@SWEvaluate:
  007af	83 bd b8 e9 ff
	ff 00		 cmp	 DWORD PTR _ns$23[ebp], 0
  007b6	0f 86 6a 01 00
	00		 jbe	 $LN12@SWEvaluate

; 783  :       {
; 784  :         for (i=0; i<ns; i++)

  007bc	c7 85 b4 e9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$22[ebp], 0
  007c6	eb 0f		 jmp	 SHORT $LN16@SWEvaluate
$LN14@SWEvaluate:
  007c8	8b 85 b4 e9 ff
	ff		 mov	 eax, DWORD PTR _i$22[ebp]
  007ce	83 c0 01	 add	 eax, 1
  007d1	89 85 b4 e9 ff
	ff		 mov	 DWORD PTR _i$22[ebp], eax
$LN16@SWEvaluate:
  007d7	8b 8d b4 e9 ff
	ff		 mov	 ecx, DWORD PTR _i$22[ebp]
  007dd	3b 8d b8 e9 ff
	ff		 cmp	 ecx, DWORD PTR _ns$23[ebp]
  007e3	0f 83 38 01 00
	00		 jae	 $LN15@SWEvaluate

; 785  :         {
; 786  :           for (j=i; j<npm-ns; j+=ns)

  007e9	8b 95 b4 e9 ff
	ff		 mov	 edx, DWORD PTR _i$22[ebp]
  007ef	89 95 b0 e9 ff
	ff		 mov	 DWORD PTR _j$21[ebp], edx
  007f5	eb 12		 jmp	 SHORT $LN19@SWEvaluate
$LN17@SWEvaluate:
  007f7	8b 85 b0 e9 ff
	ff		 mov	 eax, DWORD PTR _j$21[ebp]
  007fd	03 85 b8 e9 ff
	ff		 add	 eax, DWORD PTR _ns$23[ebp]
  00803	89 85 b0 e9 ff
	ff		 mov	 DWORD PTR _j$21[ebp], eax
$LN19@SWEvaluate:
  00809	8b 8d 1c fe ff
	ff		 mov	 ecx, DWORD PTR _npm$[ebp]
  0080f	2b 8d b8 e9 ff
	ff		 sub	 ecx, DWORD PTR _ns$23[ebp]
  00815	39 8d b0 e9 ff
	ff		 cmp	 DWORD PTR _j$21[ebp], ecx
  0081b	0f 83 fb 00 00
	00		 jae	 $LN18@SWEvaluate

; 787  :           {
; 788  :             if (pm[sortedMoves[j]] > pm[sortedMoves[j+ns]])

  00821	8b 95 b0 e9 ff
	ff		 mov	 edx, DWORD PTR _j$21[ebp]
  00827	03 95 b8 e9 ff
	ff		 add	 edx, DWORD PTR _ns$23[ebp]
  0082d	0f b6 84 15 24
	fe ff ff	 movzx	 eax, BYTE PTR _sortedMoves$[ebp+edx]
  00835	69 c8 1c 14 00
	00		 imul	 ecx, eax, 5148
  0083b	03 4d 14	 add	 ecx, DWORD PTR _pm$[ebp]
  0083e	51		 push	 ecx
  0083f	8b 95 b0 e9 ff
	ff		 mov	 edx, DWORD PTR _j$21[ebp]
  00845	0f b6 84 15 24
	fe ff ff	 movzx	 eax, BYTE PTR _sortedMoves$[ebp+edx]
  0084d	69 c8 1c 14 00
	00		 imul	 ecx, eax, 5148
  00853	03 4d 14	 add	 ecx, DWORD PTR _pm$[ebp]
  00856	e8 00 00 00 00	 call	 ??OPossibleMove@@QBE_NABU0@@Z ; PossibleMove::operator>
  0085b	0f b6 c8	 movzx	 ecx, al
  0085e	85 c9		 test	 ecx, ecx
  00860	0f 84 b1 00 00
	00		 je	 $LN62@SWEvaluate

; 789  :             {
; 790  :               k=j;

  00866	8b 95 b0 e9 ff
	ff		 mov	 edx, DWORD PTR _j$21[ebp]
  0086c	89 95 ac e9 ff
	ff		 mov	 DWORD PTR _k$20[ebp], edx
$LN22@SWEvaluate:

; 791  :               do
; 792  :               {
; 793  :                 t=sortedMoves[k];

  00872	8b 85 ac e9 ff
	ff		 mov	 eax, DWORD PTR _k$20[ebp]
  00878	8a 8c 05 24 fe
	ff ff		 mov	 cl, BYTE PTR _sortedMoves$[ebp+eax]
  0087f	88 8d ab e9 ff
	ff		 mov	 BYTE PTR _t$19[ebp], cl

; 794  :                 sortedMoves[k] = sortedMoves[k+ns];

  00885	8b 95 ac e9 ff
	ff		 mov	 edx, DWORD PTR _k$20[ebp]
  0088b	03 95 b8 e9 ff
	ff		 add	 edx, DWORD PTR _ns$23[ebp]
  00891	8b 85 ac e9 ff
	ff		 mov	 eax, DWORD PTR _k$20[ebp]
  00897	8a 8c 15 24 fe
	ff ff		 mov	 cl, BYTE PTR _sortedMoves$[ebp+edx]
  0089e	88 8c 05 24 fe
	ff ff		 mov	 BYTE PTR _sortedMoves$[ebp+eax], cl

; 795  :                 sortedMoves[k+ns] = t;

  008a5	8b 95 ac e9 ff
	ff		 mov	 edx, DWORD PTR _k$20[ebp]
  008ab	03 95 b8 e9 ff
	ff		 add	 edx, DWORD PTR _ns$23[ebp]
  008b1	8a 85 ab e9 ff
	ff		 mov	 al, BYTE PTR _t$19[ebp]
  008b7	88 84 15 24 fe
	ff ff		 mov	 BYTE PTR _sortedMoves$[ebp+edx], al

; 796  :                 k-=ns;

  008be	8b 8d ac e9 ff
	ff		 mov	 ecx, DWORD PTR _k$20[ebp]
  008c4	2b 8d b8 e9 ff
	ff		 sub	 ecx, DWORD PTR _ns$23[ebp]
  008ca	89 8d ac e9 ff
	ff		 mov	 DWORD PTR _k$20[ebp], ecx

; 797  :               } while ((k>=0) && (pm[sortedMoves[k]] > pm[sortedMoves[k+ns]]));

  008d0	78 45		 js	 SHORT $LN62@SWEvaluate
  008d2	8b 95 ac e9 ff
	ff		 mov	 edx, DWORD PTR _k$20[ebp]
  008d8	03 95 b8 e9 ff
	ff		 add	 edx, DWORD PTR _ns$23[ebp]
  008de	0f b6 84 15 24
	fe ff ff	 movzx	 eax, BYTE PTR _sortedMoves$[ebp+edx]
  008e6	69 c8 1c 14 00
	00		 imul	 ecx, eax, 5148
  008ec	03 4d 14	 add	 ecx, DWORD PTR _pm$[ebp]
  008ef	51		 push	 ecx
  008f0	8b 95 ac e9 ff
	ff		 mov	 edx, DWORD PTR _k$20[ebp]
  008f6	0f b6 84 15 24
	fe ff ff	 movzx	 eax, BYTE PTR _sortedMoves$[ebp+edx]
  008fe	69 c8 1c 14 00
	00		 imul	 ecx, eax, 5148
  00904	03 4d 14	 add	 ecx, DWORD PTR _pm$[ebp]
  00907	e8 00 00 00 00	 call	 ??OPossibleMove@@QBE_NABU0@@Z ; PossibleMove::operator>
  0090c	0f b6 c8	 movzx	 ecx, al
  0090f	85 c9		 test	 ecx, ecx
  00911	0f 85 5b ff ff
	ff		 jne	 $LN22@SWEvaluate
$LN62@SWEvaluate:

; 798  :             };
; 799  :           };

  00917	e9 db fe ff ff	 jmp	 $LN17@SWEvaluate
$LN18@SWEvaluate:

; 800  :         };

  0091c	e9 a7 fe ff ff	 jmp	 $LN14@SWEvaluate
$LN15@SWEvaluate:

; 801  :       };

  00921	e9 7b fe ff ff	 jmp	 $LN11@SWEvaluate
$LN12@SWEvaluate:

; 802  :     };
; 803  :     // There! The moves are in order from smallest to largest.      
; 804  :   }; //End of sort block.
; 805  :   // 
; 806  :   // Now we will go through the possible moves and see if any
; 807  :   // of them will provide us with a win.
; 808  :   for (int n=0; n<npm; n++)

  00926	c7 85 a4 e9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$18[ebp], 0
  00930	eb 0f		 jmp	 SHORT $LN25@SWEvaluate
$LN23@SWEvaluate:
  00932	8b 95 a4 e9 ff
	ff		 mov	 edx, DWORD PTR _n$18[ebp]
  00938	83 c2 01	 add	 edx, 1
  0093b	89 95 a4 e9 ff
	ff		 mov	 DWORD PTR _n$18[ebp], edx
$LN25@SWEvaluate:
  00941	8b 85 a4 e9 ff
	ff		 mov	 eax, DWORD PTR _n$18[ebp]
  00947	3b 85 1c fe ff
	ff		 cmp	 eax, DWORD PTR _npm$[ebp]
  0094d	0f 8d a9 04 00
	00		 jge	 $LN24@SWEvaluate

; 809  :   {
; 810  :     int cpm;
; 811  :     SWVALUE value;
; 812  :     if (result.player1Min + ourScore >= m_neededToWin)

  00953	0f b7 8d f8 fd
	ff ff		 movzx	 ecx, WORD PTR _result$[ebp]
  0095a	03 4d 0c	 add	 ecx, DWORD PTR _ourScore$[ebp]
  0095d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00960	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  00963	72 2c		 jb	 SHORT $LN64@SWEvaluate

; 813  :     {
; 814  :       result.player2Min = 0; //Because we have not tried every possibility.

  00965	33 c0		 xor	 eax, eax
  00967	66 89 85 fa fd
	ff ff		 mov	 WORD PTR _result$[ebp+2], ax

; 815  :       if (result.bestMove == -1)

  0096e	83 bd fc fd ff
	ff ff		 cmp	 DWORD PTR _result$[ebp+4], -1
  00975	75 15		 jne	 SHORT $LN65@SWEvaluate

; 816  :       {
; 817  :         result.bestMove = MyRandom(npm);

  00977	8b 8d 1c fe ff
	ff		 mov	 ecx, DWORD PTR _npm$[ebp]
  0097d	51		 push	 ecx
  0097e	e8 00 00 00 00	 call	 ?MyRandom@@YAII@Z	; MyRandom
  00983	83 c4 04	 add	 esp, 4
  00986	89 85 fc fd ff
	ff		 mov	 DWORD PTR _result$[ebp+4], eax
$LN65@SWEvaluate:

; 818  : // Moved to after the for loop
; 819  : //        if (pm[result.bestMove].con.m_numNode <= SW_MAX_CANON)
; 820  : //                pm[result.bestMove].con.Canon(0,pm[result.bestMove].con.m_numNode);
; 821  : //#ifdef _CHECK
; 822  : //        pm[result.bestMove].con.CheckEverything(0,pm[result.bestMove].con.m_numNode,false);
; 823  : //#endif
; 824  :       };
; 825  :       break;

  0098c	e9 6b 04 00 00	 jmp	 $LN24@SWEvaluate
$LN64@SWEvaluate:

; 826  :     };
; 827  :     if (result.player1Min + ourScore >= m_neededToTie)

  00991	0f b7 95 f8 fd
	ff ff		 movzx	 edx, WORD PTR _result$[ebp]
  00998	03 55 0c	 add	 edx, DWORD PTR _ourScore$[ebp]
  0099b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0099e	3b 50 0c	 cmp	 edx, DWORD PTR [eax+12]
  009a1	72 15		 jb	 SHORT $LN66@SWEvaluate

; 828  :     {
; 829  :       if (result.bestMove == -1)

  009a3	83 bd fc fd ff
	ff ff		 cmp	 DWORD PTR _result$[ebp+4], -1
  009aa	75 0c		 jne	 SHORT $LN66@SWEvaluate

; 830  :       {
; 831  :         result.bestMove = n;

  009ac	8b 8d a4 e9 ff
	ff		 mov	 ecx, DWORD PTR _n$18[ebp]
  009b2	89 8d fc fd ff
	ff		 mov	 DWORD PTR _result$[ebp+4], ecx
$LN66@SWEvaluate:

; 832  :       };
; 833  :     };
; 834  :     cpm = sortedMoves[n];

  009b8	8b 95 a4 e9 ff
	ff		 mov	 edx, DWORD PTR _n$18[ebp]
  009be	0f b6 84 15 24
	fe ff ff	 movzx	 eax, BYTE PTR _sortedMoves$[ebp+edx]
  009c6	89 85 a0 e9 ff
	ff		 mov	 DWORD PTR _cpm$17[ebp], eax

; 835  :     if (pm[cpm].nimval >= 0)

  009cc	69 8d a0 e9 ff
	ff 1c 14 00 00	 imul	 ecx, DWORD PTR _cpm$17[ebp], 5148
  009d6	8b 55 14	 mov	 edx, DWORD PTR _pm$[ebp]
  009d9	83 7c 0a 04 00	 cmp	 DWORD PTR [edx+ecx+4], 0
  009de	0f 8c 12 01 00
	00		 jl	 $LN68@SWEvaluate

; 836  :     {
; 837  :       //Let him make his move;
; 838  : //      if (myId == 4)
; 839  : //      {
; 840  : //        int kkk=1;
; 841  : //      };
; 842  :       pm[cpm].con.m_coinsRemaining -= pm[cpm].offering;

  009e4	69 85 a0 e9 ff
	ff 1c 14 00 00	 imul	 eax, DWORD PTR _cpm$17[ebp], 5148
  009ee	69 8d a0 e9 ff
	ff 1c 14 00 00	 imul	 ecx, DWORD PTR _cpm$17[ebp], 5148
  009f8	8b 55 14	 mov	 edx, DWORD PTR _pm$[ebp]
  009fb	8b 75 14	 mov	 esi, DWORD PTR _pm$[ebp]
  009fe	8b 44 02 0c	 mov	 eax, DWORD PTR [edx+eax+12]
  00a02	2b 04 0e	 sub	 eax, DWORD PTR [esi+ecx]
  00a05	69 8d a0 e9 ff
	ff 1c 14 00 00	 imul	 ecx, DWORD PTR _cpm$17[ebp], 5148
  00a0f	8b 55 14	 mov	 edx, DWORD PTR _pm$[ebp]
  00a12	89 44 0a 0c	 mov	 DWORD PTR [edx+ecx+12], eax

; 843  :       value = pm[cpm].con.SWEvaluateMove(hisScore+pm[cpm].offering, ourScore, pm+npm);

  00a16	69 85 1c fe ff
	ff 1c 14 00 00	 imul	 eax, DWORD PTR _npm$[ebp], 5148
  00a20	03 45 14	 add	 eax, DWORD PTR _pm$[ebp]
  00a23	50		 push	 eax
  00a24	8b 4d 0c	 mov	 ecx, DWORD PTR _ourScore$[ebp]
  00a27	51		 push	 ecx
  00a28	69 95 a0 e9 ff
	ff 1c 14 00 00	 imul	 edx, DWORD PTR _cpm$17[ebp], 5148
  00a32	8b 45 14	 mov	 eax, DWORD PTR _pm$[ebp]
  00a35	8b 4d 10	 mov	 ecx, DWORD PTR _hisScore$[ebp]
  00a38	03 0c 10	 add	 ecx, DWORD PTR [eax+edx]
  00a3b	51		 push	 ecx
  00a3c	8d 95 70 e9 ff
	ff		 lea	 edx, DWORD PTR $T15[ebp]
  00a42	52		 push	 edx
  00a43	69 85 a0 e9 ff
	ff 1c 14 00 00	 imul	 eax, DWORD PTR _cpm$17[ebp], 5148
  00a4d	8b 4d 14	 mov	 ecx, DWORD PTR _pm$[ebp]
  00a50	8d 4c 01 08	 lea	 ecx, DWORD PTR [ecx+eax+8]
  00a54	e8 00 00 00 00	 call	 ?SWEvaluateMove@CON@@QAE?AUSWVALUE@@IIPAUPossibleMove@@@Z ; CON::SWEvaluateMove
  00a59	8b 10		 mov	 edx, DWORD PTR [eax]
  00a5b	89 95 88 e9 ff
	ff		 mov	 DWORD PTR _value$16[ebp], edx
  00a61	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00a64	89 8d 8c e9 ff
	ff		 mov	 DWORD PTR _value$16[ebp+4], ecx
  00a6a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00a6d	89 95 90 e9 ff
	ff		 mov	 DWORD PTR _value$16[ebp+8], edx
  00a73	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00a76	89 8d 94 e9 ff
	ff		 mov	 DWORD PTR _value$16[ebp+12], ecx
  00a7c	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00a7f	89 95 98 e9 ff
	ff		 mov	 DWORD PTR _value$16[ebp+16], edx

; 844  : //      if (myId == 5)
; 845  : //      {
; 846  : //        int kkk=1;
; 847  : //      };
; 848  :       if (value.player2Min > result.player1Min)

  00a85	0f b7 85 8a e9
	ff ff		 movzx	 eax, WORD PTR _value$16[ebp+2]
  00a8c	0f b7 8d f8 fd
	ff ff		 movzx	 ecx, WORD PTR _result$[ebp]
  00a93	3b c1		 cmp	 eax, ecx
  00a95	7e 1a		 jle	 SHORT $LN70@SWEvaluate

; 849  :       {
; 850  :         result.player1Min = value.player2Min;

  00a97	66 8b 95 8a e9
	ff ff		 mov	 dx, WORD PTR _value$16[ebp+2]
  00a9e	66 89 95 f8 fd
	ff ff		 mov	 WORD PTR _result$[ebp], dx

; 851  :         result.bestMove = cpm;

  00aa5	8b 85 a0 e9 ff
	ff		 mov	 eax, DWORD PTR _cpm$17[ebp]
  00aab	89 85 fc fd ff
	ff		 mov	 DWORD PTR _result$[ebp+4], eax
$LN70@SWEvaluate:

; 852  :       };
; 853  :       if (value.player1Min + pm[cpm].offering < result.player2Min) 

  00ab1	0f b7 8d 88 e9
	ff ff		 movzx	 ecx, WORD PTR _value$16[ebp]
  00ab8	69 95 a0 e9 ff
	ff 1c 14 00 00	 imul	 edx, DWORD PTR _cpm$17[ebp], 5148
  00ac2	8b 45 14	 mov	 eax, DWORD PTR _pm$[ebp]
  00ac5	03 0c 10	 add	 ecx, DWORD PTR [eax+edx]
  00ac8	0f b7 95 fa fd
	ff ff		 movzx	 edx, WORD PTR _result$[ebp+2]
  00acf	3b ca		 cmp	 ecx, edx
  00ad1	7d 1e		 jge	 SHORT $LN71@SWEvaluate

; 854  :       {
; 855  :         result.player2Min = (ui16)(value.player1Min + pm[cpm].offering);

  00ad3	0f b7 85 88 e9
	ff ff		 movzx	 eax, WORD PTR _value$16[ebp]
  00ada	69 8d a0 e9 ff
	ff 1c 14 00 00	 imul	 ecx, DWORD PTR _cpm$17[ebp], 5148
  00ae4	8b 55 14	 mov	 edx, DWORD PTR _pm$[ebp]
  00ae7	03 04 0a	 add	 eax, DWORD PTR [edx+ecx]
  00aea	66 89 85 fa fd
	ff ff		 mov	 WORD PTR _result$[ebp+2], ax
$LN71@SWEvaluate:

; 856  :       };
; 857  :     }

  00af1	e9 01 03 00 00	 jmp	 $LN69@SWEvaluate
$LN68@SWEvaluate:

; 858  :     else
; 859  :     {
; 860  :       //Our opponent has a choice.  Take them all or
; 861  :       //decline some coins to retain control.
; 862  : //      pm[cpm].con.HISCHOICE(ourScore, hisScore, 
; 863  : //                            pm[cpm].offering, -pm[cpm].nimval, 
; 864  : //                            value, pm+npm);
; 865  : 
; 866  : 
; 867  : 
; 868  : 
; 869  : 
; 870  :       //A function that we invoke after making a loony move.
; 871  :       //There are a 'total' number of coins in the string.
; 872  :       //Our opponent can take them all and move again or he
; 873  :       //can leave 'decline' coins for us, forcing us to 
; 874  :       //make the next move.
; 875  : //      bool CON::HISCHOICE(ui ourScore, ui hisScore, 
; 876  : //                          ui total, ui decline, 
; 877  : //                          SWVALUE& result, PossibleMove *pm)
; 878  : //      { //Return true if this move wins the game for us.
; 879  :       SWVALUE v, w;
; 880  :       ui hisNewScoreV, hisNewScoreW;
; 881  :       ui hisNewMinV, hisNewMinW, ourNewMinV, ourNewMinW, ourNewMin;
; 882  :       int total, decline;
; 883  :       total = pm[cpm].offering;

  00af6	69 85 a0 e9 ff
	ff 1c 14 00 00	 imul	 eax, DWORD PTR _cpm$17[ebp], 5148
  00b00	8b 4d 14	 mov	 ecx, DWORD PTR _pm$[ebp]
  00b03	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00b06	89 95 18 e9 ff
	ff		 mov	 DWORD PTR _total$5[ebp], edx

; 884  :       decline = -pm[cpm].nimval;

  00b0c	69 85 a0 e9 ff
	ff 1c 14 00 00	 imul	 eax, DWORD PTR _cpm$17[ebp], 5148
  00b16	8b 4d 14	 mov	 ecx, DWORD PTR _pm$[ebp]
  00b19	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  00b1d	f7 da		 neg	 edx
  00b1f	89 95 14 e9 ff
	ff		 mov	 DWORD PTR _decline$4[ebp], edx

; 885  :       ASSERT(total>2);

  00b25	83 bd 18 e9 ff
	ff 02		 cmp	 DWORD PTR _total$5[ebp], 2
  00b2c	7f 14		 jg	 SHORT $LN88@SWEvaluate
  00b2e	68 75 03 00 00	 push	 885			; 00000375H
  00b33	68 00 00 00 00	 push	 OFFSET $SG225762
  00b38	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00b3d	85 c0		 test	 eax, eax
  00b3f	74 01		 je	 SHORT $LN88@SWEvaluate
  00b41	cc		 int	 3
$LN88@SWEvaluate:

; 886  :       ASSERT(decline <= total);

  00b42	8b 8d 14 e9 ff
	ff		 mov	 ecx, DWORD PTR _decline$4[ebp]
  00b48	3b 8d 18 e9 ff
	ff		 cmp	 ecx, DWORD PTR _total$5[ebp]
  00b4e	7e 14		 jle	 SHORT $LN89@SWEvaluate
  00b50	68 76 03 00 00	 push	 886			; 00000376H
  00b55	68 00 00 00 00	 push	 OFFSET $SG225763
  00b5a	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00b5f	85 c0		 test	 eax, eax
  00b61	74 01		 je	 SHORT $LN89@SWEvaluate
  00b63	cc		 int	 3
$LN89@SWEvaluate:

; 887  :       //result.player1Min = 0;
; 888  :       //result.player2Min = 0x7fff;
; 889  :       pm[cpm].con.m_coinsRemaining -= total; //One of us will take them!

  00b64	69 85 a0 e9 ff
	ff 1c 14 00 00	 imul	 eax, DWORD PTR _cpm$17[ebp], 5148
  00b6e	8b 4d 14	 mov	 ecx, DWORD PTR _pm$[ebp]
  00b71	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  00b75	2b 95 18 e9 ff
	ff		 sub	 edx, DWORD PTR _total$5[ebp]
  00b7b	69 85 a0 e9 ff
	ff 1c 14 00 00	 imul	 eax, DWORD PTR _cpm$17[ebp], 5148
  00b85	8b 4d 14	 mov	 ecx, DWORD PTR _pm$[ebp]
  00b88	89 54 01 0c	 mov	 DWORD PTR [ecx+eax+12], edx

; 890  : //      if (myId == 5)
; 891  : //      {
; 892  : //        int kkk=1;
; 893  : //      };
; 894  :       v = pm[cpm].con.SWEvaluateMove(hisScore+(total), ourScore, pm+npm);//He takes them all

  00b8c	69 95 1c fe ff
	ff 1c 14 00 00	 imul	 edx, DWORD PTR _npm$[ebp], 5148
  00b96	03 55 14	 add	 edx, DWORD PTR _pm$[ebp]
  00b99	52		 push	 edx
  00b9a	8b 45 0c	 mov	 eax, DWORD PTR _ourScore$[ebp]
  00b9d	50		 push	 eax
  00b9e	8b 4d 10	 mov	 ecx, DWORD PTR _hisScore$[ebp]
  00ba1	03 8d 18 e9 ff
	ff		 add	 ecx, DWORD PTR _total$5[ebp]
  00ba7	51		 push	 ecx
  00ba8	8d 95 00 e9 ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  00bae	52		 push	 edx
  00baf	69 85 a0 e9 ff
	ff 1c 14 00 00	 imul	 eax, DWORD PTR _cpm$17[ebp], 5148
  00bb9	8b 4d 14	 mov	 ecx, DWORD PTR _pm$[ebp]
  00bbc	8d 4c 01 08	 lea	 ecx, DWORD PTR [ecx+eax+8]
  00bc0	e8 00 00 00 00	 call	 ?SWEvaluateMove@CON@@QAE?AUSWVALUE@@IIPAUPossibleMove@@@Z ; CON::SWEvaluateMove
  00bc5	8b 10		 mov	 edx, DWORD PTR [eax]
  00bc7	89 95 58 e9 ff
	ff		 mov	 DWORD PTR _v$14[ebp], edx
  00bcd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00bd0	89 8d 5c e9 ff
	ff		 mov	 DWORD PTR _v$14[ebp+4], ecx
  00bd6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00bd9	89 95 60 e9 ff
	ff		 mov	 DWORD PTR _v$14[ebp+8], edx
  00bdf	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00be2	89 8d 64 e9 ff
	ff		 mov	 DWORD PTR _v$14[ebp+12], ecx
  00be8	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00beb	89 95 68 e9 ff
	ff		 mov	 DWORD PTR _v$14[ebp+16], edx

; 895  :       hisNewMinV = (total) + v.player1Min;

  00bf1	0f b7 85 58 e9
	ff ff		 movzx	 eax, WORD PTR _v$14[ebp]
  00bf8	03 85 18 e9 ff
	ff		 add	 eax, DWORD PTR _total$5[ebp]
  00bfe	89 85 2c e9 ff
	ff		 mov	 DWORD PTR _hisNewMinV$10[ebp], eax

; 896  :       hisNewScoreV = hisScore + hisNewMinV;

  00c04	8b 4d 10	 mov	 ecx, DWORD PTR _hisScore$[ebp]
  00c07	03 8d 2c e9 ff
	ff		 add	 ecx, DWORD PTR _hisNewMinV$10[ebp]
  00c0d	89 8d 34 e9 ff
	ff		 mov	 DWORD PTR _hisNewScoreV$12[ebp], ecx

; 897  :       if (hisNewScoreV >= m_neededToWin) 

  00c13	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00c16	8b 85 34 e9 ff
	ff		 mov	 eax, DWORD PTR _hisNewScoreV$12[ebp]
  00c1c	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00c1f	72 22		 jb	 SHORT $LN72@SWEvaluate

; 898  :       { 
; 899  :         //Taking them all won the game for him
; 900  :         //so he won't try anything else.
; 901  :         if (hisNewMinV < result.player2Min) result.player2Min = (ui16)hisNewMinV;

  00c21	0f b7 8d fa fd
	ff ff		 movzx	 ecx, WORD PTR _result$[ebp+2]
  00c28	39 8d 2c e9 ff
	ff		 cmp	 DWORD PTR _hisNewMinV$10[ebp], ecx
  00c2e	73 0e		 jae	 SHORT $LN74@SWEvaluate
  00c30	66 8b 95 2c e9
	ff ff		 mov	 dx, WORD PTR _hisNewMinV$10[ebp]
  00c37	66 89 95 fa fd
	ff ff		 mov	 WORD PTR _result$[ebp+2], dx
$LN74@SWEvaluate:

; 902  :         //ourNewMinV = v.player2Min;
; 903  :         //if (result.player1Min < ourNewMinV) 
; 904  :           //{
; 905  :           //  result.bestMove = move;
; 906  :           //};
; 907  :           //Try another move
; 908  :           //result.player1Min = 0; //We don't really know because he quit
; 909  :           //                       //trying to reduce our score when he
; 910  :           //                       //succeeded in winning.
; 911  :       }

  00c3e	e9 b4 01 00 00	 jmp	 $LN69@SWEvaluate
$LN72@SWEvaluate:

; 912  :       else
; 913  :       {
; 914  :         //Well, he did not win by taking them all.  He will try declining
; 915  :         //a few coins and force us to move.
; 916  :         w = pm[cpm].con.SWEvaluateMove(ourScore+(decline), hisScore+(total)-(decline), pm+npm);

  00c43	69 85 1c fe ff
	ff 1c 14 00 00	 imul	 eax, DWORD PTR _npm$[ebp], 5148
  00c4d	03 45 14	 add	 eax, DWORD PTR _pm$[ebp]
  00c50	50		 push	 eax
  00c51	8b 4d 10	 mov	 ecx, DWORD PTR _hisScore$[ebp]
  00c54	03 8d 18 e9 ff
	ff		 add	 ecx, DWORD PTR _total$5[ebp]
  00c5a	2b 8d 14 e9 ff
	ff		 sub	 ecx, DWORD PTR _decline$4[ebp]
  00c60	51		 push	 ecx
  00c61	8b 55 0c	 mov	 edx, DWORD PTR _ourScore$[ebp]
  00c64	03 95 14 e9 ff
	ff		 add	 edx, DWORD PTR _decline$4[ebp]
  00c6a	52		 push	 edx
  00c6b	8d 85 ec e8 ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00c71	50		 push	 eax
  00c72	69 8d a0 e9 ff
	ff 1c 14 00 00	 imul	 ecx, DWORD PTR _cpm$17[ebp], 5148
  00c7c	8b 55 14	 mov	 edx, DWORD PTR _pm$[ebp]
  00c7f	8d 4c 0a 08	 lea	 ecx, DWORD PTR [edx+ecx+8]
  00c83	e8 00 00 00 00	 call	 ?SWEvaluateMove@CON@@QAE?AUSWVALUE@@IIPAUPossibleMove@@@Z ; CON::SWEvaluateMove
  00c88	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c8a	89 8d 3c e9 ff
	ff		 mov	 DWORD PTR _w$13[ebp], ecx
  00c90	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00c93	89 95 40 e9 ff
	ff		 mov	 DWORD PTR _w$13[ebp+4], edx
  00c99	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00c9c	89 8d 44 e9 ff
	ff		 mov	 DWORD PTR _w$13[ebp+8], ecx
  00ca2	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00ca5	89 95 48 e9 ff
	ff		 mov	 DWORD PTR _w$13[ebp+12], edx
  00cab	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00cae	89 85 4c e9 ff
	ff		 mov	 DWORD PTR _w$13[ebp+16], eax

; 917  : //        if (myId == 5)
; 918  : //        {
; 919  : //          int kkk=1;
; 920  : //        };
; 921  :         hisNewMinW = (total) - (decline) + w.player2Min;

  00cb4	8b 8d 18 e9 ff
	ff		 mov	 ecx, DWORD PTR _total$5[ebp]
  00cba	2b 8d 14 e9 ff
	ff		 sub	 ecx, DWORD PTR _decline$4[ebp]
  00cc0	0f b7 95 3e e9
	ff ff		 movzx	 edx, WORD PTR _w$13[ebp+2]
  00cc7	03 ca		 add	 ecx, edx
  00cc9	89 8d 28 e9 ff
	ff		 mov	 DWORD PTR _hisNewMinW$9[ebp], ecx

; 922  :         hisNewScoreW = hisScore + hisNewMinW;

  00ccf	8b 45 10	 mov	 eax, DWORD PTR _hisScore$[ebp]
  00cd2	03 85 28 e9 ff
	ff		 add	 eax, DWORD PTR _hisNewMinW$9[ebp]
  00cd8	89 85 30 e9 ff
	ff		 mov	 DWORD PTR _hisNewScoreW$11[ebp], eax

; 923  :         if (hisNewScoreW >= m_neededToWin)

  00cde	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00ce1	8b 95 30 e9 ff
	ff		 mov	 edx, DWORD PTR _hisNewScoreW$11[ebp]
  00ce7	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00cea	72 52		 jb	 SHORT $LN75@SWEvaluate

; 924  :         {
; 925  :           //A hard-hearted handout won the game for him
; 926  :           //We must continue looking for a better move.
; 927  :           if (hisNewMinW < result.player2Min) result.player2Min = (ui16)hisNewMinW;

  00cec	0f b7 85 fa fd
	ff ff		 movzx	 eax, WORD PTR _result$[ebp+2]
  00cf3	39 85 28 e9 ff
	ff		 cmp	 DWORD PTR _hisNewMinW$9[ebp], eax
  00cf9	73 0e		 jae	 SHORT $LN77@SWEvaluate
  00cfb	66 8b 8d 28 e9
	ff ff		 mov	 cx, WORD PTR _hisNewMinW$9[ebp]
  00d02	66 89 8d fa fd
	ff ff		 mov	 WORD PTR _result$[ebp+2], cx
$LN77@SWEvaluate:

; 928  :           ourNewMinW = w.player1Min + decline;

  00d09	0f b7 95 3c e9
	ff ff		 movzx	 edx, WORD PTR _w$13[ebp]
  00d10	03 95 14 e9 ff
	ff		 add	 edx, DWORD PTR _decline$4[ebp]
  00d16	89 95 20 e9 ff
	ff		 mov	 DWORD PTR _ourNewMinW$7[ebp], edx

; 929  :           if (ourNewMinW > result.player1Min) result.player1Min = (ui16)ourNewMinW;

  00d1c	0f b7 85 f8 fd
	ff ff		 movzx	 eax, WORD PTR _result$[ebp]
  00d23	39 85 20 e9 ff
	ff		 cmp	 DWORD PTR _ourNewMinW$7[ebp], eax
  00d29	76 0e		 jbe	 SHORT $LN78@SWEvaluate
  00d2b	66 8b 8d 20 e9
	ff ff		 mov	 cx, WORD PTR _ourNewMinW$7[ebp]
  00d32	66 89 8d f8 fd
	ff ff		 mov	 WORD PTR _result$[ebp], cx
$LN78@SWEvaluate:

; 930  :           //Try another move
; 931  :         }

  00d39	e9 b9 00 00 00	 jmp	 $LN69@SWEvaluate
$LN75@SWEvaluate:

; 932  :         else
; 933  :         {
; 934  :           // Neither of his options won the game for him.  So we will assume
; 935  :           // that he will take the option that will maximize his score.
; 936  :           ourNewMinV = v.player2Min;

  00d3e	0f b7 95 5a e9
	ff ff		 movzx	 edx, WORD PTR _v$14[ebp+2]
  00d45	89 95 24 e9 ff
	ff		 mov	 DWORD PTR _ourNewMinV$8[ebp], edx

; 937  :           ourNewMinW = decline + w.player1Min;

  00d4b	0f b7 85 3c e9
	ff ff		 movzx	 eax, WORD PTR _w$13[ebp]
  00d52	03 85 14 e9 ff
	ff		 add	 eax, DWORD PTR _decline$4[ebp]
  00d58	89 85 20 e9 ff
	ff		 mov	 DWORD PTR _ourNewMinW$7[ebp], eax

; 938  :           ourNewMin = ourNewMinV;

  00d5e	8b 8d 24 e9 ff
	ff		 mov	 ecx, DWORD PTR _ourNewMinV$8[ebp]
  00d64	89 8d 1c e9 ff
	ff		 mov	 DWORD PTR _ourNewMin$6[ebp], ecx

; 939  :           if (ourNewMinW < ourNewMin) ourNewMin = ourNewMinW;

  00d6a	8b 95 20 e9 ff
	ff		 mov	 edx, DWORD PTR _ourNewMinW$7[ebp]
  00d70	3b 95 1c e9 ff
	ff		 cmp	 edx, DWORD PTR _ourNewMin$6[ebp]
  00d76	73 0c		 jae	 SHORT $LN79@SWEvaluate
  00d78	8b 85 20 e9 ff
	ff		 mov	 eax, DWORD PTR _ourNewMinW$7[ebp]
  00d7e	89 85 1c e9 ff
	ff		 mov	 DWORD PTR _ourNewMin$6[ebp], eax
$LN79@SWEvaluate:

; 940  :           if (ourNewMin > result.player1Min)

  00d84	0f b7 8d f8 fd
	ff ff		 movzx	 ecx, WORD PTR _result$[ebp]
  00d8b	39 8d 1c e9 ff
	ff		 cmp	 DWORD PTR _ourNewMin$6[ebp], ecx
  00d91	76 1a		 jbe	 SHORT $LN80@SWEvaluate

; 941  :           {
; 942  :             result.player1Min = (ui16)ourNewMin;

  00d93	66 8b 95 1c e9
	ff ff		 mov	 dx, WORD PTR _ourNewMin$6[ebp]
  00d9a	66 89 95 f8 fd
	ff ff		 mov	 WORD PTR _result$[ebp], dx

; 943  :             result.bestMove = cpm;

  00da1	8b 85 a0 e9 ff
	ff		 mov	 eax, DWORD PTR _cpm$17[ebp]
  00da7	89 85 fc fd ff
	ff		 mov	 DWORD PTR _result$[ebp+4], eax
$LN80@SWEvaluate:

; 944  :           };
; 945  :           if (hisNewScoreV > hisNewScoreW)

  00dad	8b 8d 34 e9 ff
	ff		 mov	 ecx, DWORD PTR _hisNewScoreV$12[ebp]
  00db3	3b 8d 30 e9 ff
	ff		 cmp	 ecx, DWORD PTR _hisNewScoreW$11[ebp]
  00db9	76 1f		 jbe	 SHORT $LN81@SWEvaluate

; 946  :           {
; 947  :             //He will choose to take the whole string and move again
; 948  :             if (hisNewMinV < result.player2Min) result.player2Min = (ui16)hisNewMinV;

  00dbb	0f b7 95 fa fd
	ff ff		 movzx	 edx, WORD PTR _result$[ebp+2]
  00dc2	39 95 2c e9 ff
	ff		 cmp	 DWORD PTR _hisNewMinV$10[ebp], edx
  00dc8	73 0e		 jae	 SHORT $LN83@SWEvaluate
  00dca	66 8b 85 2c e9
	ff ff		 mov	 ax, WORD PTR _hisNewMinV$10[ebp]
  00dd1	66 89 85 fa fd
	ff ff		 mov	 WORD PTR _result$[ebp+2], ax
$LN83@SWEvaluate:

; 949  : //            if (ourScore + ourNewMinV >= m_neededToWin)
; 950  : //            {
; 951  : //              //result.player2Min = 0;
; 952  : //              break;
; 953  : //            };
; 954  :           }

  00dd8	eb 1d		 jmp	 SHORT $LN69@SWEvaluate
$LN81@SWEvaluate:

; 955  :           else
; 956  :           {
; 957  :             // He will decline the coins and make us move next.
; 958  :             if (hisNewMinW < result.player2Min) result.player2Min = (ui16)hisNewMinW;

  00dda	0f b7 8d fa fd
	ff ff		 movzx	 ecx, WORD PTR _result$[ebp+2]
  00de1	39 8d 28 e9 ff
	ff		 cmp	 DWORD PTR _hisNewMinW$9[ebp], ecx
  00de7	73 0e		 jae	 SHORT $LN69@SWEvaluate
  00de9	66 8b 95 28 e9
	ff ff		 mov	 dx, WORD PTR _hisNewMinW$9[ebp]
  00df0	66 89 95 fa fd
	ff ff		 mov	 WORD PTR _result$[ebp+2], dx
$LN69@SWEvaluate:

; 959  : //            if (ourScore + ourNewMinW >= m_neededToWin)
; 960  : //            {
; 961  : //              //result.player2Min = 0;
; 962  : //            };
; 963  :           };
; 964  :           //This loony move did not result in a win for either of us.
; 965  :           //Must be a tie!!!!
; 966  :         };
; 967  :       };
; 968  : 
; 969  : 
; 970  : 
; 971  : 
; 972  :     };
; 973  :   }; // For each move in the possible moves list.

  00df7	e9 36 fb ff ff	 jmp	 $LN23@SWEvaluate
$LN24@SWEvaluate:

; 974  :   if (result.bestMove != -1)

  00dfc	83 bd fc fd ff
	ff ff		 cmp	 DWORD PTR _result$[ebp+4], -1
  00e03	74 41		 je	 SHORT $LN85@SWEvaluate

; 975  :   {
; 976  :     if (pm[result.bestMove].con.m_numNode <= SW_MAX_CANON)

  00e05	69 85 fc fd ff
	ff 1c 14 00 00	 imul	 eax, DWORD PTR _result$[ebp+4], 5148
  00e0f	8b 4d 14	 mov	 ecx, DWORD PTR _pm$[ebp]
  00e12	81 7c 01 08 e7
	03 00 00	 cmp	 DWORD PTR [ecx+eax+8], 999 ; 000003e7H
  00e1a	7f 2a		 jg	 SHORT $LN85@SWEvaluate

; 977  :             pm[result.bestMove].con.Canon(0,pm[result.bestMove].con.m_numNode);

  00e1c	69 95 fc fd ff
	ff 1c 14 00 00	 imul	 edx, DWORD PTR _result$[ebp+4], 5148
  00e26	8b 45 14	 mov	 eax, DWORD PTR _pm$[ebp]
  00e29	8b 4c 10 08	 mov	 ecx, DWORD PTR [eax+edx+8]
  00e2d	51		 push	 ecx
  00e2e	6a 00		 push	 0
  00e30	69 95 fc fd ff
	ff 1c 14 00 00	 imul	 edx, DWORD PTR _result$[ebp+4], 5148
  00e3a	8b 45 14	 mov	 eax, DWORD PTR _pm$[ebp]
  00e3d	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  00e41	e8 00 00 00 00	 call	 ?Canon@CON@@QAEXHH@Z	; CON::Canon
$LN85@SWEvaluate:

; 978  : #ifdef _CHECK
; 979  :     pm[result.bestMove].con.CheckEverything(0,pm[result.bestMove].con.m_numNode,false);
; 980  : #endif
; 981  :   };
; 982  :   ASSERT(result.player2Min != MAX_NODES+1);

  00e46	0f b7 8d fa fd
	ff ff		 movzx	 ecx, WORD PTR _result$[ebp+2]
  00e4d	83 f9 6f	 cmp	 ecx, 111		; 0000006fH
  00e50	75 14		 jne	 SHORT $LN90@SWEvaluate
  00e52	68 d6 03 00 00	 push	 982			; 000003d6H
  00e57	68 00 00 00 00	 push	 OFFSET $SG225779
  00e5c	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00e61	85 c0		 test	 eax, eax
  00e63	74 01		 je	 SHORT $LN90@SWEvaluate
  00e65	cc		 int	 3
$LN90@SWEvaluate:

; 983  :   return result;

  00e66	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00e69	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR _result$[ebp]
  00e6f	89 08		 mov	 DWORD PTR [eax], ecx
  00e71	8b 95 fc fd ff
	ff		 mov	 edx, DWORD PTR _result$[ebp+4]
  00e77	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00e7a	8b 8d 00 fe ff
	ff		 mov	 ecx, DWORD PTR _result$[ebp+8]
  00e80	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00e83	8b 95 04 fe ff
	ff		 mov	 edx, DWORD PTR _result$[ebp+12]
  00e89	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00e8c	8b 8d 08 fe ff
	ff		 mov	 ecx, DWORD PTR _result$[ebp+16]
  00e92	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00e95	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00e9c	8d 8d 14 fe ff
	ff		 lea	 ecx, DWORD PTR _mams$[ebp]
  00ea2	e8 00 00 00 00	 call	 ??1MarkAvailableMoveStack@@QAE@XZ ; MarkAvailableMoveStack::~MarkAvailableMoveStack
  00ea7	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@SWEvaluate:

; 984  : }

  00eaa	52		 push	 edx
  00eab	8b cd		 mov	 ecx, ebp
  00ead	50		 push	 eax
  00eae	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN102@SWEvaluate
  00eb4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00eb9	58		 pop	 eax
  00eba	5a		 pop	 edx
  00ebb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00ebe	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00ec5	59		 pop	 ecx
  00ec6	5f		 pop	 edi
  00ec7	5e		 pop	 esi
  00ec8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ecb	33 cd		 xor	 ecx, ebp
  00ecd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ed2	81 c4 14 17 00
	00		 add	 esp, 5908		; 00001714H
  00ed8	3b ec		 cmp	 ebp, esp
  00eda	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00edf	8b e5		 mov	 esp, ebp
  00ee1	5d		 pop	 ebp
  00ee2	c2 10 00	 ret	 16			; 00000010H
  00ee5	0f 1f 00	 npad	 3
$LN102@SWEvaluate:
  00ee8	07 00 00 00	 DD	 7
  00eec	00 00 00 00	 DD	 $LN101@SWEvaluate
$LN101@SWEvaluate:
  00ef0	24 fe ff ff	 DD	 -476			; fffffe24H
  00ef4	b8 01 00 00	 DD	 440			; 000001b8H
  00ef8	00 00 00 00	 DD	 $LN93@SWEvaluate
  00efc	14 fe ff ff	 DD	 -492			; fffffe14H
  00f00	04 00 00 00	 DD	 4
  00f04	00 00 00 00	 DD	 $LN94@SWEvaluate
  00f08	f8 fd ff ff	 DD	 -520			; fffffdf8H
  00f0c	14 00 00 00	 DD	 20			; 00000014H
  00f10	00 00 00 00	 DD	 $LN95@SWEvaluate
  00f14	c0 e9 ff ff	 DD	 -5696			; ffffe9c0H
  00f18	10 14 00 00	 DD	 5136			; 00001410H
  00f1c	00 00 00 00	 DD	 $LN96@SWEvaluate
  00f20	88 e9 ff ff	 DD	 -5752			; ffffe988H
  00f24	14 00 00 00	 DD	 20			; 00000014H
  00f28	00 00 00 00	 DD	 $LN97@SWEvaluate
  00f2c	58 e9 ff ff	 DD	 -5800			; ffffe958H
  00f30	14 00 00 00	 DD	 20			; 00000014H
  00f34	00 00 00 00	 DD	 $LN98@SWEvaluate
  00f38	3c e9 ff ff	 DD	 -5828			; ffffe93cH
  00f3c	14 00 00 00	 DD	 20			; 00000014H
  00f40	00 00 00 00	 DD	 $LN99@SWEvaluate
$LN99@SWEvaluate:
  00f44	77		 DB	 119			; 00000077H
  00f45	00		 DB	 0
$LN98@SWEvaluate:
  00f46	76		 DB	 118			; 00000076H
  00f47	00		 DB	 0
$LN97@SWEvaluate:
  00f48	76		 DB	 118			; 00000076H
  00f49	61		 DB	 97			; 00000061H
  00f4a	6c		 DB	 108			; 0000006cH
  00f4b	75		 DB	 117			; 00000075H
  00f4c	65		 DB	 101			; 00000065H
  00f4d	00		 DB	 0
$LN96@SWEvaluate:
  00f4e	6e		 DB	 110			; 0000006eH
  00f4f	69		 DB	 105			; 00000069H
  00f50	6d		 DB	 109			; 0000006dH
  00f51	63		 DB	 99			; 00000063H
  00f52	6f		 DB	 111			; 0000006fH
  00f53	6e		 DB	 110			; 0000006eH
  00f54	00		 DB	 0
$LN95@SWEvaluate:
  00f55	72		 DB	 114			; 00000072H
  00f56	65		 DB	 101			; 00000065H
  00f57	73		 DB	 115			; 00000073H
  00f58	75		 DB	 117			; 00000075H
  00f59	6c		 DB	 108			; 0000006cH
  00f5a	74		 DB	 116			; 00000074H
  00f5b	00		 DB	 0
$LN94@SWEvaluate:
  00f5c	6d		 DB	 109			; 0000006dH
  00f5d	61		 DB	 97			; 00000061H
  00f5e	6d		 DB	 109			; 0000006dH
  00f5f	73		 DB	 115			; 00000073H
  00f60	00		 DB	 0
$LN93@SWEvaluate:
  00f61	73		 DB	 115			; 00000073H
  00f62	6f		 DB	 111			; 0000006fH
  00f63	72		 DB	 114			; 00000072H
  00f64	74		 DB	 116			; 00000074H
  00f65	65		 DB	 101			; 00000065H
  00f66	64		 DB	 100			; 00000064H
  00f67	4d		 DB	 77			; 0000004dH
  00f68	6f		 DB	 111			; 0000006fH
  00f69	76		 DB	 118			; 00000076H
  00f6a	65		 DB	 101			; 00000065H
  00f6b	73		 DB	 115			; 00000073H
  00f6c	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SWEvaluateAllMoves@CON@@QBE?AUSWVALUE@@IIPAUPossibleMove@@@Z$0:
  00000	8d 8d 14 fe ff
	ff		 lea	 ecx, DWORD PTR _mams$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1MarkAvailableMoveStack@@QAE@XZ ; MarkAvailableMoveStack::~MarkAvailableMoveStack
__unwindfunclet$?SWEvaluateAllMoves@CON@@QBE?AUSWVALUE@@IIPAUPossibleMove@@@Z$1:
  0000b	8d 8d c0 e9 ff
	ff		 lea	 ecx, DWORD PTR _nimcon$24[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1NIMCON@@QAE@XZ
  00016	cc		 int	 3
  00017	cc		 int	 3
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
__ehhandler$?SWEvaluateAllMoves@CON@@QBE?AUSWVALUE@@IIPAUPossibleMove@@@Z:
  0001b	90		 npad	 1
  0001c	90		 npad	 1
  0001d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00021	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00024	8b 8a ec e8 ff
	ff		 mov	 ecx, DWORD PTR [edx-5908]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00034	33 c8		 xor	 ecx, eax
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SWEvaluateAllMoves@CON@@QBE?AUSWVALUE@@IIPAUPossibleMove@@@Z
  00040	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SWEvaluateAllMoves@CON@@QBE?AUSWVALUE@@IIPAUPossibleMove@@@Z ENDP ; CON::SWEvaluateAllMoves
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\SWEvaluate.cpp
_TEXT	SEGMENT
$T1 = -76						; size = 20
_nnA$2 = -56						; size = 4
_moveValue$ = -48					; size = 20
_hashIndex$ = -24					; size = 4
_hash$ = -20						; size = 8
_myCount$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_Player1Score$ = 12					; size = 4
_Player2Score$ = 16					; size = 4
_pm$ = 20						; size = 4
?SWEvaluateMove@CON@@QAE?AUSWVALUE@@IIPAUPossibleMove@@@Z PROC ; CON::SWEvaluateMove
; _this$ = ecx

; 1006 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	57		 push	 edi
  00007	51		 push	 ecx
  00008	8d 7d b4	 lea	 edi, DWORD PTR [ebp-76]
  0000b	b9 13 00 00 00	 mov	 ecx, 19			; 00000013H
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	59		 pop	 ecx
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00022	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1007 :   static int count=0;
; 1008 :   int myCount;
; 1009 :   ui64 hash;
; 1010 :   int hashIndex;
; 1011 :   count++;

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?count@?1??SWEvaluateMove@CON@@QAE?AUSWVALUE@@IIPAUPossibleMove@@@Z@4HA
  0002a	83 c0 01	 add	 eax, 1
  0002d	a3 00 00 00 00	 mov	 DWORD PTR ?count@?1??SWEvaluateMove@CON@@QAE?AUSWVALUE@@IIPAUPossibleMove@@@Z@4HA, eax

; 1012 :   myCount=count;  

  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?count@?1??SWEvaluateMove@CON@@QAE?AUSWVALUE@@IIPAUPossibleMove@@@Z@4HA
  00038	89 4d f4	 mov	 DWORD PTR _myCount$[ebp], ecx

; 1013 : 
; 1014 : //  if ((myCount >= 2590)&&(myCount<=5000))
; 1015 : //  {
; 1016 : //    enableDump = 1;
; 1017 : //  }
; 1018 : //  else enableDump = 0;
; 1019 :   if (m_numNode <= SW_MAX_CANON)

  0003b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	81 3a e7 03 00
	00		 cmp	 DWORD PTR [edx], 999	; 000003e7H
  00044	7f 10		 jg	 SHORT $LN2@SWEvaluate

; 1020 :             Canon(0, m_numNode);

  00046	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	51		 push	 ecx
  0004c	6a 00		 push	 0
  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?Canon@CON@@QAEXHH@Z	; CON::Canon
$LN2@SWEvaluate:

; 1021 : #ifdef _CHECK
; 1022 :   CheckEverything(0,m_numNode,false);
; 1023 : #endif
; 1024 :   TRACEENTRY
; 1025 :   SWVALUE moveValue;
; 1026 :   CHECK_EVERYTHING
; 1027 : //  CHECK_REMAINING
; 1028 :   //Note("a");
; 1029 :   if ((currentTime > timeLimit) || stopThinking) 

  00056	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?currentTime@@3_JA+4
  0005c	3b 15 04 00 00
	00		 cmp	 edx, DWORD PTR ?timeLimit@@3_JA+4
  00062	7f 1a		 jg	 SHORT $LN4@SWEvaluate
  00064	7c 0d		 jl	 SHORT $LN22@SWEvaluate
  00066	a1 00 00 00 00	 mov	 eax, DWORD PTR ?currentTime@@3_JA
  0006b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?timeLimit@@3_JA
  00071	77 0b		 ja	 SHORT $LN4@SWEvaluate
$LN22@SWEvaluate:
  00073	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stopThinking@@3_NA ; stopThinking
  0007a	85 c9		 test	 ecx, ecx
  0007c	74 3b		 je	 SHORT $LN3@SWEvaluate
$LN4@SWEvaluate:

; 1030 :   {
; 1031 :     moveValue.player1Min = 0;

  0007e	33 d2		 xor	 edx, edx
  00080	66 89 55 d0	 mov	 WORD PTR _moveValue$[ebp], dx

; 1032 :     moveValue.player2Min = 0;

  00084	33 c0		 xor	 eax, eax
  00086	66 89 45 d2	 mov	 WORD PTR _moveValue$[ebp+2], ax

; 1033 :     TRACERETURN(myCount, &moveValue)
; 1034 :     searchAborted = true;

  0008a	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?searchAborted@@3_NA, 1 ; searchAborted

; 1035 :     return moveValue;

  00091	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00094	8b 55 d0	 mov	 edx, DWORD PTR _moveValue$[ebp]
  00097	89 11		 mov	 DWORD PTR [ecx], edx
  00099	8b 45 d4	 mov	 eax, DWORD PTR _moveValue$[ebp+4]
  0009c	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0009f	8b 55 d8	 mov	 edx, DWORD PTR _moveValue$[ebp+8]
  000a2	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000a5	8b 45 dc	 mov	 eax, DWORD PTR _moveValue$[ebp+12]
  000a8	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  000ab	8b 55 e0	 mov	 edx, DWORD PTR _moveValue$[ebp+16]
  000ae	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  000b1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b4	e9 87 02 00 00	 jmp	 $LN1@SWEvaluate
$LN3@SWEvaluate:

; 1036 :   };
; 1037 :   if (m_numNode == 0)

  000b9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000bc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000bf	75 34		 jne	 SHORT $LN5@SWEvaluate

; 1038 :   {
; 1039 :     moveValue.player1Min = 0;

  000c1	33 c9		 xor	 ecx, ecx
  000c3	66 89 4d d0	 mov	 WORD PTR _moveValue$[ebp], cx

; 1040 :     moveValue.player2Min = 0;

  000c7	33 d2		 xor	 edx, edx
  000c9	66 89 55 d2	 mov	 WORD PTR _moveValue$[ebp+2], dx

; 1041 :     TRACERETURN(myCount, &moveValue)
; 1042 :     return moveValue;

  000cd	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000d0	8b 4d d0	 mov	 ecx, DWORD PTR _moveValue$[ebp]
  000d3	89 08		 mov	 DWORD PTR [eax], ecx
  000d5	8b 55 d4	 mov	 edx, DWORD PTR _moveValue$[ebp+4]
  000d8	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000db	8b 4d d8	 mov	 ecx, DWORD PTR _moveValue$[ebp+8]
  000de	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000e1	8b 55 dc	 mov	 edx, DWORD PTR _moveValue$[ebp+12]
  000e4	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  000e7	8b 4d e0	 mov	 ecx, DWORD PTR _moveValue$[ebp+16]
  000ea	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  000ed	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000f0	e9 4b 02 00 00	 jmp	 $LN1@SWEvaluate
$LN5@SWEvaluate:

; 1043 :   };
; 1044 :   if (m_numNode == 1)

  000f5	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000f8	83 3a 01	 cmp	 DWORD PTR [edx], 1
  000fb	0f 85 80 00 00
	00		 jne	 $LN6@SWEvaluate

; 1045 :   {
; 1046 :     int nnA;
; 1047 :     nnA = nd[0].ix;

  00101	b8 04 00 00 00	 mov	 eax, 4
  00106	6b c8 00	 imul	 ecx, eax, 0
  00109	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0010c	0f b6 84 0a 13
	10 00 00	 movzx	 eax, BYTE PTR [edx+ecx+4115]
  00114	89 45 c8	 mov	 DWORD PTR _nnA$2[ebp], eax

; 1048 :     if (IS_ISOLATED(sd[nnA][0].ns))

  00117	8b 4d c8	 mov	 ecx, DWORD PTR _nnA$2[ebp]
  0011a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0011d	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  00124	b9 02 00 00 00	 mov	 ecx, 2
  00129	6b d1 00	 imul	 edx, ecx, 0
  0012c	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  00130	3d fa 00 00 00	 cmp	 eax, 250		; 000000faH
  00135	7e 4a		 jle	 SHORT $LN6@SWEvaluate

; 1049 :     {
; 1050 :       moveValue.player1Min = 0;

  00137	33 c9		 xor	 ecx, ecx
  00139	66 89 4d d0	 mov	 WORD PTR _moveValue$[ebp], cx

; 1051 :       moveValue.player2Min = ed[nnA].e[0].el;

  0013d	8b 55 c8	 mov	 edx, DWORD PTR _nnA$2[ebp]
  00140	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00143	8d 4c d0 10	 lea	 ecx, DWORD PTR [eax+edx*8+16]
  00147	ba 02 00 00 00	 mov	 edx, 2
  0014c	6b c2 00	 imul	 eax, edx, 0
  0014f	66 0f b6 4c 01
	01		 movzx	 cx, BYTE PTR [ecx+eax+1]
  00155	66 89 4d d2	 mov	 WORD PTR _moveValue$[ebp+2], cx

; 1052 :       TRACERETURN(myCount, &moveValue);
; 1053 :       return moveValue;

  00159	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0015c	8b 45 d0	 mov	 eax, DWORD PTR _moveValue$[ebp]
  0015f	89 02		 mov	 DWORD PTR [edx], eax
  00161	8b 4d d4	 mov	 ecx, DWORD PTR _moveValue$[ebp+4]
  00164	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00167	8b 45 d8	 mov	 eax, DWORD PTR _moveValue$[ebp+8]
  0016a	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0016d	8b 4d dc	 mov	 ecx, DWORD PTR _moveValue$[ebp+12]
  00170	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00173	8b 45 e0	 mov	 eax, DWORD PTR _moveValue$[ebp+16]
  00176	89 42 10	 mov	 DWORD PTR [edx+16], eax
  00179	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0017c	e9 bf 01 00 00	 jmp	 $LN1@SWEvaluate
$LN6@SWEvaluate:

; 1054 :     };
; 1055 :   };
; 1056 :   hash = SWHash();

  00181	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00184	e8 00 00 00 00	 call	 ?SWHash@CON@@QAE_KXZ	; CON::SWHash
  00189	89 45 ec	 mov	 DWORD PTR _hash$[ebp], eax
  0018c	89 55 f0	 mov	 DWORD PTR _hash$[ebp+4], edx

; 1057 :   if (hash == 0xcce2814646c4308fI64)

  0018f	81 7d ec 8f 30
	c4 46		 cmp	 DWORD PTR _hash$[ebp], 1187262607 ; 46c4308fH
  00196	75 12		 jne	 SHORT $LN8@SWEvaluate
  00198	81 7d f0 46 81
	e2 cc		 cmp	 DWORD PTR _hash$[ebp+4], -857571002 ; cce28146H
  0019f	75 09		 jne	 SHORT $LN8@SWEvaluate

; 1058 :   {
; 1059 :     enableDump = myCount;

  001a1	8b 4d f4	 mov	 ecx, DWORD PTR _myCount$[ebp]
  001a4	89 0d 00 00 00
	00		 mov	 DWORD PTR ?enableDump@@3HA, ecx ; enableDump
$LN8@SWEvaluate:

; 1060 : //    this->DUMP("Enter SWEvaluateMove ======================", count,Player1Score, Player2Score,0,m_numNode);
; 1061 :   };
; 1062 :   LOGUIUI("Hash = 0x%08x%08x",(ui32)(hash>>32),(ui32)hash)
; 1063 :   hashIndex = swHashTable->Exists(hash);

  001aa	8b 55 f0	 mov	 edx, DWORD PTR _hash$[ebp+4]
  001ad	52		 push	 edx
  001ae	8b 45 ec	 mov	 eax, DWORD PTR _hash$[ebp]
  001b1	50		 push	 eax
  001b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?swHashTable@@3PAVSWHASHTABLE@@A ; swHashTable
  001b8	e8 00 00 00 00	 call	 ?Exists@SWHASHTABLE@@QAEH_K@Z ; SWHASHTABLE::Exists
  001bd	89 45 e8	 mov	 DWORD PTR _hashIndex$[ebp], eax

; 1064 :   if (hashIndex >= 0)

  001c0	83 7d e8 00	 cmp	 DWORD PTR _hashIndex$[ebp], 0
  001c4	7c 6b		 jl	 SHORT $LN9@SWEvaluate

; 1065 :   {
; 1066 : //    hashFinds++;
; 1067 :     swHashTable->Value(hashIndex, &moveValue);

  001c6	8d 4d d0	 lea	 ecx, DWORD PTR _moveValue$[ebp]
  001c9	51		 push	 ecx
  001ca	8b 55 e8	 mov	 edx, DWORD PTR _hashIndex$[ebp]
  001cd	52		 push	 edx
  001ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?swHashTable@@3PAVSWHASHTABLE@@A ; swHashTable
  001d4	e8 00 00 00 00	 call	 ?Value@SWHASHTABLE@@QAEXHPAUSWVALUE@@@Z ; SWHASHTABLE::Value

; 1068 :     if (  (moveValue.player1Min + Player1Score >= m_neededToWin)
; 1069 :         ||(moveValue.player2Min + Player2Score >= m_neededToWin) 
; 1070 :         ||(moveValue.player1Min + moveValue.player2Min == (signed)m_coinsRemaining) )

  001d9	0f b7 45 d0	 movzx	 eax, WORD PTR _moveValue$[ebp]
  001dd	03 45 0c	 add	 eax, DWORD PTR _Player1Score$[ebp]
  001e0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001e3	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  001e6	73 21		 jae	 SHORT $LN12@SWEvaluate
  001e8	0f b7 55 d2	 movzx	 edx, WORD PTR _moveValue$[ebp+2]
  001ec	03 55 10	 add	 edx, DWORD PTR _Player2Score$[ebp]
  001ef	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001f2	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  001f5	73 12		 jae	 SHORT $LN12@SWEvaluate
  001f7	0f b7 4d d0	 movzx	 ecx, WORD PTR _moveValue$[ebp]
  001fb	0f b7 55 d2	 movzx	 edx, WORD PTR _moveValue$[ebp+2]
  001ff	03 ca		 add	 ecx, edx
  00201	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00204	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00207	75 28		 jne	 SHORT $LN9@SWEvaluate
$LN12@SWEvaluate:

; 1071 :     {
; 1072 :       TRACERETURN(myCount, &moveValue)
; 1073 : //      hashUses++;
; 1074 :       if (enableDump == myCount) 
; 1075 :       {
; 1076 : //        enableDump = 0;
; 1077 :       };
; 1078 :       return moveValue;

  00209	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0020c	8b 45 d0	 mov	 eax, DWORD PTR _moveValue$[ebp]
  0020f	89 02		 mov	 DWORD PTR [edx], eax
  00211	8b 4d d4	 mov	 ecx, DWORD PTR _moveValue$[ebp+4]
  00214	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00217	8b 45 d8	 mov	 eax, DWORD PTR _moveValue$[ebp+8]
  0021a	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0021d	8b 4d dc	 mov	 ecx, DWORD PTR _moveValue$[ebp+12]
  00220	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00223	8b 45 e0	 mov	 eax, DWORD PTR _moveValue$[ebp+16]
  00226	89 42 10	 mov	 DWORD PTR [edx+16], eax
  00229	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0022c	e9 0f 01 00 00	 jmp	 $LN1@SWEvaluate
$LN9@SWEvaluate:

; 1079 :     };
; 1080 :   };
; 1081 : //  if (myCount == 0x41)
; 1082 : //  {
; 1083 : //    int kkk=1;
; 1084 : //  };
; 1085 :   moveValue = SWEvaluateAllMoves(Player1Score, Player2Score, pm);

  00231	8b 4d 14	 mov	 ecx, DWORD PTR _pm$[ebp]
  00234	51		 push	 ecx
  00235	8b 55 10	 mov	 edx, DWORD PTR _Player2Score$[ebp]
  00238	52		 push	 edx
  00239	8b 45 0c	 mov	 eax, DWORD PTR _Player1Score$[ebp]
  0023c	50		 push	 eax
  0023d	8d 4d b4	 lea	 ecx, DWORD PTR $T1[ebp]
  00240	51		 push	 ecx
  00241	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00244	e8 00 00 00 00	 call	 ?SWEvaluateAllMoves@CON@@QBE?AUSWVALUE@@IIPAUPossibleMove@@@Z ; CON::SWEvaluateAllMoves
  00249	8b 10		 mov	 edx, DWORD PTR [eax]
  0024b	89 55 d0	 mov	 DWORD PTR _moveValue$[ebp], edx
  0024e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00251	89 4d d4	 mov	 DWORD PTR _moveValue$[ebp+4], ecx
  00254	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00257	89 55 d8	 mov	 DWORD PTR _moveValue$[ebp+8], edx
  0025a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0025d	89 4d dc	 mov	 DWORD PTR _moveValue$[ebp+12], ecx
  00260	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00263	89 55 e0	 mov	 DWORD PTR _moveValue$[ebp+16], edx

; 1086 :   if (moveValue.player1Min+moveValue.player2Min > (signed)m_coinsRemaining)

  00266	0f b7 45 d0	 movzx	 eax, WORD PTR _moveValue$[ebp]
  0026a	0f b7 4d d2	 movzx	 ecx, WORD PTR _moveValue$[ebp+2]
  0026e	03 c1		 add	 eax, ecx
  00270	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00273	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00276	7e 0d		 jle	 SHORT $LN13@SWEvaluate

; 1087 :   {
; 1088 :     ImplementationError("Capture more than all the coins");

  00278	68 00 00 00 00	 push	 OFFSET $SG225809
  0027d	e8 00 00 00 00	 call	 ?ImplementationError@@YAXPBD@Z ; ImplementationError
  00282	83 c4 04	 add	 esp, 4
$LN13@SWEvaluate:

; 1089 :   };
; 1090 :   if (    (Player1Score + moveValue.player1Min < m_neededToWin)
; 1091 :        && (Player2Score + moveValue.player2Min < m_neededToWin))

  00285	0f b7 45 d0	 movzx	 eax, WORD PTR _moveValue$[ebp]
  00289	03 45 0c	 add	 eax, DWORD PTR _Player1Score$[ebp]
  0028c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0028f	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00292	73 4f		 jae	 SHORT $LN14@SWEvaluate
  00294	0f b7 55 d2	 movzx	 edx, WORD PTR _moveValue$[ebp+2]
  00298	03 55 10	 add	 edx, DWORD PTR _Player2Score$[ebp]
  0029b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0029e	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  002a1	73 40		 jae	 SHORT $LN14@SWEvaluate

; 1092 :   {
; 1093 :     if (   (Player1Score + moveValue.player1Min != m_neededToWin-1)
; 1094 :         || (Player2Score + moveValue.player2Min != m_neededToWin-1))

  002a3	0f b7 4d d0	 movzx	 ecx, WORD PTR _moveValue$[ebp]
  002a7	03 4d 0c	 add	 ecx, DWORD PTR _Player1Score$[ebp]
  002aa	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  002ad	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  002b0	83 e8 01	 sub	 eax, 1
  002b3	3b c8		 cmp	 ecx, eax
  002b5	75 14		 jne	 SHORT $LN16@SWEvaluate
  002b7	0f b7 4d d2	 movzx	 ecx, WORD PTR _moveValue$[ebp+2]
  002bb	03 4d 10	 add	 ecx, DWORD PTR _Player2Score$[ebp]
  002be	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  002c1	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  002c4	83 e8 01	 sub	 eax, 1
  002c7	3b c8		 cmp	 ecx, eax
  002c9	74 18		 je	 SHORT $LN14@SWEvaluate
$LN16@SWEvaluate:

; 1095 :     {
; 1096 :       if (!searchAborted) 

  002cb	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?searchAborted@@3_NA ; searchAborted
  002d2	85 c9		 test	 ecx, ecx
  002d4	75 0d		 jne	 SHORT $LN14@SWEvaluate

; 1097 :       {
; 1098 :         ImplementationError("Nobody won!");

  002d6	68 00 00 00 00	 push	 OFFSET $SG225814
  002db	e8 00 00 00 00	 call	 ?ImplementationError@@YAXPBD@Z ; ImplementationError
  002e0	83 c4 04	 add	 esp, 4
$LN14@SWEvaluate:

; 1099 :       };
; 1100 :     };
; 1101 :   };
; 1102 : //  if (myCount == 7)
; 1103 : //  {
; 1104 : //    int kkk=1;
; 1105 : //  };
; 1106 :   if (hashIndex < 0) swHashTable->EnterValue(hash, &moveValue);

  002e3	83 7d e8 00	 cmp	 DWORD PTR _hashIndex$[ebp], 0
  002e7	7d 19		 jge	 SHORT $LN18@SWEvaluate
  002e9	8d 55 d0	 lea	 edx, DWORD PTR _moveValue$[ebp]
  002ec	52		 push	 edx
  002ed	8b 45 f0	 mov	 eax, DWORD PTR _hash$[ebp+4]
  002f0	50		 push	 eax
  002f1	8b 4d ec	 mov	 ecx, DWORD PTR _hash$[ebp]
  002f4	51		 push	 ecx
  002f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?swHashTable@@3PAVSWHASHTABLE@@A ; swHashTable
  002fb	e8 00 00 00 00	 call	 ?EnterValue@SWHASHTABLE@@QAEX_KPAUSWVALUE@@@Z ; SWHASHTABLE::EnterValue
  00300	eb 1b		 jmp	 SHORT $LN20@SWEvaluate
$LN18@SWEvaluate:

; 1107 :   else 
; 1108 :   {
; 1109 :     swHashTable->UpdateValue(hashIndex, hash, &moveValue);

  00302	8d 55 d0	 lea	 edx, DWORD PTR _moveValue$[ebp]
  00305	52		 push	 edx
  00306	8b 45 f0	 mov	 eax, DWORD PTR _hash$[ebp+4]
  00309	50		 push	 eax
  0030a	8b 4d ec	 mov	 ecx, DWORD PTR _hash$[ebp]
  0030d	51		 push	 ecx
  0030e	8b 55 e8	 mov	 edx, DWORD PTR _hashIndex$[ebp]
  00311	52		 push	 edx
  00312	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?swHashTable@@3PAVSWHASHTABLE@@A ; swHashTable
  00318	e8 00 00 00 00	 call	 ?UpdateValue@SWHASHTABLE@@QAEXI_KPAUSWVALUE@@@Z ; SWHASHTABLE::UpdateValue
$LN20@SWEvaluate:

; 1110 :   };
; 1111 :   TRACERETURN(myCount, &moveValue)
; 1112 :   if (enableDump == myCount) 
; 1113 :   {
; 1114 : //    enableDump = 0;
; 1115 :   };
; 1116 :   return moveValue;

  0031d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00320	8b 55 d0	 mov	 edx, DWORD PTR _moveValue$[ebp]
  00323	89 11		 mov	 DWORD PTR [ecx], edx
  00325	8b 45 d4	 mov	 eax, DWORD PTR _moveValue$[ebp+4]
  00328	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0032b	8b 55 d8	 mov	 edx, DWORD PTR _moveValue$[ebp+8]
  0032e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00331	8b 45 dc	 mov	 eax, DWORD PTR _moveValue$[ebp+12]
  00334	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00337	8b 55 e0	 mov	 edx, DWORD PTR _moveValue$[ebp+16]
  0033a	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0033d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@SWEvaluate:

; 1117 : };

  00340	52		 push	 edx
  00341	8b cd		 mov	 ecx, ebp
  00343	50		 push	 eax
  00344	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN25@SWEvaluate
  0034a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0034f	58		 pop	 eax
  00350	5a		 pop	 edx
  00351	5f		 pop	 edi
  00352	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00355	33 cd		 xor	 ecx, ebp
  00357	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0035c	83 c4 4c	 add	 esp, 76			; 0000004cH
  0035f	3b ec		 cmp	 ebp, esp
  00361	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00366	8b e5		 mov	 esp, ebp
  00368	5d		 pop	 ebp
  00369	c2 10 00	 ret	 16			; 00000010H
$LN25@SWEvaluate:
  0036c	01 00 00 00	 DD	 1
  00370	00 00 00 00	 DD	 $LN24@SWEvaluate
$LN24@SWEvaluate:
  00374	d0 ff ff ff	 DD	 -48			; ffffffd0H
  00378	14 00 00 00	 DD	 20			; 00000014H
  0037c	00 00 00 00	 DD	 $LN23@SWEvaluate
$LN23@SWEvaluate:
  00380	6d		 DB	 109			; 0000006dH
  00381	6f		 DB	 111			; 0000006fH
  00382	76		 DB	 118			; 00000076H
  00383	65		 DB	 101			; 00000065H
  00384	56		 DB	 86			; 00000056H
  00385	61		 DB	 97			; 00000061H
  00386	6c		 DB	 108			; 0000006cH
  00387	75		 DB	 117			; 00000075H
  00388	65		 DB	 101			; 00000065H
  00389	00		 DB	 0
?SWEvaluateMove@CON@@QAE?AUSWVALUE@@IIPAUPossibleMove@@@Z ENDP ; CON::SWEvaluateMove
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\SWEvaluate.cpp
_TEXT	SEGMENT
_ourNewMinW$2 = -5320					; size = 4
$T3 = -5316						; size = 20
$T4 = -5296						; size = 20
_nimcon$ = -5272					; size = 5136
_result$ = -128						; size = 20
_w$ = -100						; size = 20
_v$ = -72						; size = 20
_nimvalTake$ = -48					; size = 4
_hisNewMinW$ = -44					; size = 4
_hisNewMinV$ = -40					; size = 4
_ourNewMinW$ = -36					; size = 4
_ourNewMinV$ = -32					; size = 4
_ourNewScoreW$ = -28					; size = 4
_ourNewScoreV$ = -24					; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_ourScore$ = 12						; size = 4
_hisScore$ = 16						; size = 4
_total$ = 20						; size = 4
_decline$ = 24						; size = 4
_pm$ = 28						; size = 4
?MYCHOICE@CON@@QAE?AUSWVALUE@@IIIIPAUPossibleMove@@@Z PROC ; CON::MYCHOICE
; _this$ = ecx

; 350  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MYCHOICE@CON@@QAE?AUSWVALUE@@IIIIPAUPossibleMove@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 bc 14 00 00	 mov	 eax, 5308		; 000014bcH
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	57		 push	 edi
  0001c	51		 push	 ecx
  0001d	8d bd 38 eb ff
	ff		 lea	 edi, DWORD PTR [ebp-5320]
  00023	b9 2f 05 00 00	 mov	 ecx, 1327		; 0000052fH
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	59		 pop	 ecx
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	50		 push	 eax
  0003b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00044	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 351  :   ui ourNewScoreV, ourNewScoreW;
; 352  :   ui ourNewMinV, ourNewMinW, hisNewMinV, hisNewMinW;
; 353  :   int nimvalTake;
; 354  :   SWVALUE v, w;
; 355  :   SWVALUE result;
; 356  :   ASSERT(total>=2);

  00047	83 7d 14 02	 cmp	 DWORD PTR _total$[ebp], 2
  0004b	73 14		 jae	 SHORT $LN19@MYCHOICE
  0004d	68 64 01 00 00	 push	 356			; 00000164H
  00052	68 00 00 00 00	 push	 OFFSET $SG225539
  00057	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0005c	85 c0		 test	 eax, eax
  0005e	74 01		 je	 SHORT $LN19@MYCHOICE
  00060	cc		 int	 3
$LN19@MYCHOICE:

; 357  :   ASSERT(total>=decline);

  00061	8b 4d 14	 mov	 ecx, DWORD PTR _total$[ebp]
  00064	3b 4d 18	 cmp	 ecx, DWORD PTR _decline$[ebp]
  00067	73 14		 jae	 SHORT $LN20@MYCHOICE
  00069	68 65 01 00 00	 push	 357			; 00000165H
  0006e	68 00 00 00 00	 push	 OFFSET $SG225540
  00073	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00078	85 c0		 test	 eax, eax
  0007a	74 01		 je	 SHORT $LN20@MYCHOICE
  0007c	cc		 int	 3
$LN20@MYCHOICE:

; 358  :   NIMCON nimcon;

  0007d	8d 8d 68 eb ff
	ff		 lea	 ecx, DWORD PTR _nimcon$[ebp]
  00083	e8 00 00 00 00	 call	 ??0NIMCON@@QAE@XZ
  00088	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 359  :   nimvalTake = nimcon.NimVal(this);

  0008f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00092	50		 push	 eax
  00093	8d 8d 68 eb ff
	ff		 lea	 ecx, DWORD PTR _nimcon$[ebp]
  00099	e8 00 00 00 00	 call	 ?NimVal@NIMCON@@QAEHPBVCON@@@Z ; NIMCON::NimVal
  0009e	89 45 d0	 mov	 DWORD PTR _nimvalTake$[ebp], eax

; 360  :   if (nimvalTake == 99)

  000a1	83 7d d0 63	 cmp	 DWORD PTR _nimvalTake$[ebp], 99 ; 00000063H
  000a5	75 6e		 jne	 SHORT $LN2@MYCHOICE

; 361  :   {
; 362  :     //We did not have time to compute the nimstring value.
; 363  :     //Therefore it is unlikely that we can compute a winning move.
; 364  :     //Since we are completely in the dark, it seems best to
; 365  :     //simply take all that we can.
; 366  :     result.moveType = MT_SIMPLEWINCAPTURE;

  000a7	c7 45 88 0b 00
	00 00		 mov	 DWORD PTR _result$[ebp+8], 11 ; 0000000bH

; 367  :     computerMove.con = *this;

  000ae	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	51		 push	 ecx
  000b2	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  000b7	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=

; 368  :     if (computerMove.con.m_numNode <= SW_MAX_CANON)

  000bc	81 3d 08 00 00
	00 e7 03 00 00	 cmp	 DWORD PTR ?computerMove@@3UPossibleMove@@A+8, 999 ; 000003e7H
  000c6	7f 13		 jg	 SHORT $LN3@MYCHOICE

; 369  :            computerMove.con.Canon(0,computerMove.con.m_numNode);

  000c8	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ?computerMove@@3UPossibleMove@@A+8
  000ce	52		 push	 edx
  000cf	6a 00		 push	 0
  000d1	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  000d6	e8 00 00 00 00	 call	 ?Canon@CON@@QAEXHH@Z	; CON::Canon
$LN3@MYCHOICE:

; 370  : #ifdef _CHECK
; 371  :     computerMove.con.CheckEverything(0,computerMove.con.m_numNode,false);
; 372  : #endif
; 373  :     return result;

  000db	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000de	8b 4d 80	 mov	 ecx, DWORD PTR _result$[ebp]
  000e1	89 08		 mov	 DWORD PTR [eax], ecx
  000e3	8b 55 84	 mov	 edx, DWORD PTR _result$[ebp+4]
  000e6	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000e9	8b 4d 88	 mov	 ecx, DWORD PTR _result$[ebp+8]
  000ec	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000ef	8b 55 8c	 mov	 edx, DWORD PTR _result$[ebp+12]
  000f2	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  000f5	8b 4d 90	 mov	 ecx, DWORD PTR _result$[ebp+16]
  000f8	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  000fb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00102	8d 8d 68 eb ff
	ff		 lea	 ecx, DWORD PTR _nimcon$[ebp]
  00108	e8 00 00 00 00	 call	 ??1NIMCON@@QAE@XZ
  0010d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00110	e9 f8 02 00 00	 jmp	 $LN1@MYCHOICE
$LN2@MYCHOICE:

; 374  :   };
; 375  :   m_coinsRemaining -= total; //One of us will take them!

  00115	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00118	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0011b	2b 45 14	 sub	 eax, DWORD PTR _total$[ebp]
  0011e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00121	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 376  : //  Note("MYCHOICE A");
; 377  :   v = SWEvaluateMove(ourScore+(total), hisScore, pm+1);//We take them all and move again.

  00124	8b 55 1c	 mov	 edx, DWORD PTR _pm$[ebp]
  00127	81 c2 1c 14 00
	00		 add	 edx, 5148		; 0000141cH
  0012d	52		 push	 edx
  0012e	8b 45 10	 mov	 eax, DWORD PTR _hisScore$[ebp]
  00131	50		 push	 eax
  00132	8b 4d 0c	 mov	 ecx, DWORD PTR _ourScore$[ebp]
  00135	03 4d 14	 add	 ecx, DWORD PTR _total$[ebp]
  00138	51		 push	 ecx
  00139	8d 95 50 eb ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  0013f	52		 push	 edx
  00140	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00143	e8 00 00 00 00	 call	 ?SWEvaluateMove@CON@@QAE?AUSWVALUE@@IIPAUPossibleMove@@@Z ; CON::SWEvaluateMove
  00148	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014a	89 4d b8	 mov	 DWORD PTR _v$[ebp], ecx
  0014d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00150	89 55 bc	 mov	 DWORD PTR _v$[ebp+4], edx
  00153	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00156	89 4d c0	 mov	 DWORD PTR _v$[ebp+8], ecx
  00159	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0015c	89 55 c4	 mov	 DWORD PTR _v$[ebp+12], edx
  0015f	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00162	89 45 c8	 mov	 DWORD PTR _v$[ebp+16], eax

; 378  :   if (searchAborted)

  00165	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?searchAborted@@3_NA ; searchAborted
  0016c	85 c9		 test	 ecx, ecx
  0016e	0f 84 8b 00 00
	00		 je	 $LN4@MYCHOICE

; 379  :   {
; 380  :     //Time expired before we could find a winning move.
; 381  :     //We will make our decision based on the nimstring
; 382  :     //value.
; 383  :     computerMove.con = *this;

  00174	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00177	52		 push	 edx
  00178	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  0017d	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=

; 384  :     if (computerMove.con.m_numNode <= SW_MAX_CANON)

  00182	81 3d 08 00 00
	00 e7 03 00 00	 cmp	 DWORD PTR ?computerMove@@3UPossibleMove@@A+8, 999 ; 000003e7H
  0018c	7f 12		 jg	 SHORT $LN5@MYCHOICE

; 385  :             computerMove.con.Canon(0,computerMove.con.m_numNode);

  0018e	a1 08 00 00 00	 mov	 eax, DWORD PTR ?computerMove@@3UPossibleMove@@A+8
  00193	50		 push	 eax
  00194	6a 00		 push	 0
  00196	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  0019b	e8 00 00 00 00	 call	 ?Canon@CON@@QAEXHH@Z	; CON::Canon
$LN5@MYCHOICE:

; 386  : #ifdef _CHECK
; 387  :     computerMove.con.CheckEverything(0,computerMove.con.m_numNode,false);
; 388  : #endif
; 389  :     if (nimvalTake == 0)

  001a0	83 7d d0 00	 cmp	 DWORD PTR _nimvalTake$[ebp], 0
  001a4	75 09		 jne	 SHORT $LN6@MYCHOICE

; 390  :     {
; 391  :       result.moveType = MT_NIMVALDECLINE;

  001a6	c7 45 88 16 00
	00 00		 mov	 DWORD PTR _result$[ebp+8], 22 ; 00000016H

; 392  :     }

  001ad	eb 07		 jmp	 SHORT $LN7@MYCHOICE
$LN6@MYCHOICE:

; 393  :     else
; 394  :     {
; 395  :       result.moveType = MT_NIMVALCAPTURE;

  001af	c7 45 88 15 00
	00 00		 mov	 DWORD PTR _result$[ebp+8], 21 ; 00000015H
$LN7@MYCHOICE:

; 396  :     };
; 397  :     m_coinsRemaining += total;

  001b6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001b9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001bc	03 55 14	 add	 edx, DWORD PTR _total$[ebp]
  001bf	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001c2	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 398  :     return result;

  001c5	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  001c8	8b 55 80	 mov	 edx, DWORD PTR _result$[ebp]
  001cb	89 11		 mov	 DWORD PTR [ecx], edx
  001cd	8b 45 84	 mov	 eax, DWORD PTR _result$[ebp+4]
  001d0	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  001d3	8b 55 88	 mov	 edx, DWORD PTR _result$[ebp+8]
  001d6	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  001d9	8b 45 8c	 mov	 eax, DWORD PTR _result$[ebp+12]
  001dc	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  001df	8b 55 90	 mov	 edx, DWORD PTR _result$[ebp+16]
  001e2	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  001e5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001ec	8d 8d 68 eb ff
	ff		 lea	 ecx, DWORD PTR _nimcon$[ebp]
  001f2	e8 00 00 00 00	 call	 ??1NIMCON@@QAE@XZ
  001f7	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001fa	e9 0e 02 00 00	 jmp	 $LN1@MYCHOICE
$LN4@MYCHOICE:

; 399  :   };
; 400  :   ourNewMinV = (total) + v.player1Min;

  001ff	0f b7 45 b8	 movzx	 eax, WORD PTR _v$[ebp]
  00203	03 45 14	 add	 eax, DWORD PTR _total$[ebp]
  00206	89 45 e0	 mov	 DWORD PTR _ourNewMinV$[ebp], eax

; 401  :   ourNewScoreV = ourScore + ourNewMinV;

  00209	8b 4d 0c	 mov	 ecx, DWORD PTR _ourScore$[ebp]
  0020c	03 4d e0	 add	 ecx, DWORD PTR _ourNewMinV$[ebp]
  0020f	89 4d e8	 mov	 DWORD PTR _ourNewScoreV$[ebp], ecx

; 402  :   if (ourNewScoreV >= m_neededToWin) 

  00212	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00215	8b 45 e8	 mov	 eax, DWORD PTR _ourNewScoreV$[ebp]
  00218	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  0021b	72 29		 jb	 SHORT $LN8@MYCHOICE

; 403  :   { 
; 404  :     //Taking them all won the game for us
; 405  :     //so we won't try anything else.
; 406  :     computerMove.con = *this;

  0021d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00220	51		 push	 ecx
  00221	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  00226	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=

; 407  :     m_coinsRemaining += total;

  0022b	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0022e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00231	03 45 14	 add	 eax, DWORD PTR _total$[ebp]
  00234	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00237	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 408  :     //computerMove.offering = total;
; 409  :     result.moveType =  MT_SIMPLEWINCAPTURE; //Capture all coin

  0023a	c7 45 88 0b 00
	00 00		 mov	 DWORD PTR _result$[ebp+8], 11 ; 0000000bH

; 410  :   }

  00241	e9 92 01 00 00	 jmp	 $LN9@MYCHOICE
$LN8@MYCHOICE:

; 411  :   else
; 412  :   {
; 413  :     hisNewMinV = v.player2Min;

  00246	0f b7 55 ba	 movzx	 edx, WORD PTR _v$[ebp+2]
  0024a	89 55 d8	 mov	 DWORD PTR _hisNewMinV$[ebp], edx

; 414  :     //Well, we did not win by taking them all.  We will try declining
; 415  :     //a few coins and force him to move.
; 416  :   //  Note("MYCHOICE B");
; 417  :     w = SWEvaluateMove(hisScore+(decline), ourScore+(total)-(decline), pm+1);

  0024d	8b 45 1c	 mov	 eax, DWORD PTR _pm$[ebp]
  00250	05 1c 14 00 00	 add	 eax, 5148		; 0000141cH
  00255	50		 push	 eax
  00256	8b 4d 0c	 mov	 ecx, DWORD PTR _ourScore$[ebp]
  00259	03 4d 14	 add	 ecx, DWORD PTR _total$[ebp]
  0025c	2b 4d 18	 sub	 ecx, DWORD PTR _decline$[ebp]
  0025f	51		 push	 ecx
  00260	8b 55 10	 mov	 edx, DWORD PTR _hisScore$[ebp]
  00263	03 55 18	 add	 edx, DWORD PTR _decline$[ebp]
  00266	52		 push	 edx
  00267	8d 85 3c eb ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0026d	50		 push	 eax
  0026e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00271	e8 00 00 00 00	 call	 ?SWEvaluateMove@CON@@QAE?AUSWVALUE@@IIPAUPossibleMove@@@Z ; CON::SWEvaluateMove
  00276	8b 08		 mov	 ecx, DWORD PTR [eax]
  00278	89 4d 9c	 mov	 DWORD PTR _w$[ebp], ecx
  0027b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0027e	89 55 a0	 mov	 DWORD PTR _w$[ebp+4], edx
  00281	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00284	89 4d a4	 mov	 DWORD PTR _w$[ebp+8], ecx
  00287	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0028a	89 55 a8	 mov	 DWORD PTR _w$[ebp+12], edx
  0028d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00290	89 45 ac	 mov	 DWORD PTR _w$[ebp+16], eax

; 418  :     if (searchAborted)

  00293	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?searchAborted@@3_NA ; searchAborted
  0029a	85 c9		 test	 ecx, ecx
  0029c	0f 84 8b 00 00
	00		 je	 $LN10@MYCHOICE

; 419  :     {
; 420  :       //Time expired before we could find a winning move.
; 421  :       //We will make our decision based on the nimstring
; 422  :       //value.
; 423  :       computerMove.con = *this;

  002a2	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  002a5	52		 push	 edx
  002a6	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  002ab	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=

; 424  :       if (computerMove.con.m_numNode <= SW_MAX_CANON)

  002b0	81 3d 08 00 00
	00 e7 03 00 00	 cmp	 DWORD PTR ?computerMove@@3UPossibleMove@@A+8, 999 ; 000003e7H
  002ba	7f 12		 jg	 SHORT $LN11@MYCHOICE

; 425  :               computerMove.con.Canon(0,computerMove.con.m_numNode);

  002bc	a1 08 00 00 00	 mov	 eax, DWORD PTR ?computerMove@@3UPossibleMove@@A+8
  002c1	50		 push	 eax
  002c2	6a 00		 push	 0
  002c4	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  002c9	e8 00 00 00 00	 call	 ?Canon@CON@@QAEXHH@Z	; CON::Canon
$LN11@MYCHOICE:

; 426  : #ifdef _CHECK
; 427  :       computerMove.con.CheckEverything(0,computerMove.con.m_numNode,false);
; 428  : #endif
; 429  :       if (nimvalTake == 0)

  002ce	83 7d d0 00	 cmp	 DWORD PTR _nimvalTake$[ebp], 0
  002d2	75 09		 jne	 SHORT $LN12@MYCHOICE

; 430  :       {
; 431  :         result.moveType = MT_NIMVALDECLINE;

  002d4	c7 45 88 16 00
	00 00		 mov	 DWORD PTR _result$[ebp+8], 22 ; 00000016H

; 432  :       }

  002db	eb 07		 jmp	 SHORT $LN13@MYCHOICE
$LN12@MYCHOICE:

; 433  :       else
; 434  :       {
; 435  :         result.moveType = MT_NIMVALCAPTURE;

  002dd	c7 45 88 15 00
	00 00		 mov	 DWORD PTR _result$[ebp+8], 21 ; 00000015H
$LN13@MYCHOICE:

; 436  :       };
; 437  :       m_coinsRemaining += total;

  002e4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002e7	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002ea	03 55 14	 add	 edx, DWORD PTR _total$[ebp]
  002ed	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  002f0	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 438  :       return result;

  002f3	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  002f6	8b 55 80	 mov	 edx, DWORD PTR _result$[ebp]
  002f9	89 11		 mov	 DWORD PTR [ecx], edx
  002fb	8b 45 84	 mov	 eax, DWORD PTR _result$[ebp+4]
  002fe	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00301	8b 55 88	 mov	 edx, DWORD PTR _result$[ebp+8]
  00304	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00307	8b 45 8c	 mov	 eax, DWORD PTR _result$[ebp+12]
  0030a	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0030d	8b 55 90	 mov	 edx, DWORD PTR _result$[ebp+16]
  00310	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  00313	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0031a	8d 8d 68 eb ff
	ff		 lea	 ecx, DWORD PTR _nimcon$[ebp]
  00320	e8 00 00 00 00	 call	 ??1NIMCON@@QAE@XZ
  00325	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00328	e9 e0 00 00 00	 jmp	 $LN1@MYCHOICE
$LN10@MYCHOICE:

; 439  :     };
; 440  :     ourNewMinW = (ui16)((total) - (decline) + v.player2Min);

  0032d	8b 45 14	 mov	 eax, DWORD PTR _total$[ebp]
  00330	2b 45 18	 sub	 eax, DWORD PTR _decline$[ebp]
  00333	0f b7 4d ba	 movzx	 ecx, WORD PTR _v$[ebp+2]
  00337	03 c1		 add	 eax, ecx
  00339	0f b7 d0	 movzx	 edx, ax
  0033c	89 55 dc	 mov	 DWORD PTR _ourNewMinW$[ebp], edx

; 441  :     ourNewScoreW = ourScore + ourNewMinW;

  0033f	8b 45 0c	 mov	 eax, DWORD PTR _ourScore$[ebp]
  00342	03 45 dc	 add	 eax, DWORD PTR _ourNewMinW$[ebp]
  00345	89 45 e4	 mov	 DWORD PTR _ourNewScoreW$[ebp], eax

; 442  :     if (ourNewScoreW >= m_neededToWin)

  00348	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0034b	8b 55 e4	 mov	 edx, DWORD PTR _ourNewScoreW$[ebp]
  0034e	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00351	72 42		 jb	 SHORT $LN14@MYCHOICE

; 443  :     {
; 444  :       //A hard-hearted handout won the game for us.
; 445  :       //We can use this move.
; 446  :       ui ourNewMinW;
; 447  :       hisNewMinW = (decline) + w.player1Min;

  00353	0f b7 45 9c	 movzx	 eax, WORD PTR _w$[ebp]
  00357	03 45 18	 add	 eax, DWORD PTR _decline$[ebp]
  0035a	89 45 d4	 mov	 DWORD PTR _hisNewMinW$[ebp], eax

; 448  :       ourNewMinW = (total) - (decline) + w.player2Min;

  0035d	8b 4d 14	 mov	 ecx, DWORD PTR _total$[ebp]
  00360	2b 4d 18	 sub	 ecx, DWORD PTR _decline$[ebp]
  00363	0f b7 55 9e	 movzx	 edx, WORD PTR _w$[ebp+2]
  00367	03 ca		 add	 ecx, edx
  00369	89 8d 38 eb ff
	ff		 mov	 DWORD PTR _ourNewMinW$2[ebp], ecx

; 449  :       computerMove.con = *this;

  0036f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00372	50		 push	 eax
  00373	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  00378	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=

; 450  :       m_coinsRemaining += total;

  0037d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00380	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00383	03 55 14	 add	 edx, DWORD PTR _total$[ebp]
  00386	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00389	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 451  :       result.moveType = MT_SIMPLEWINDECLINE; //No Capture.

  0038c	c7 45 88 0c 00
	00 00		 mov	 DWORD PTR _result$[ebp+8], 12 ; 0000000cH

; 452  :     }

  00393	eb 43		 jmp	 SHORT $LN9@MYCHOICE
$LN14@MYCHOICE:

; 453  :     else
; 454  :     {
; 455  :       // Neither of our options won the game for us.  So
; 456  :       // we will take the option that will maximize our score.
; 457  :       if (ourNewScoreV >= ourNewScoreW)

  00395	8b 4d e8	 mov	 ecx, DWORD PTR _ourNewScoreV$[ebp]
  00398	3b 4d e4	 cmp	 ecx, DWORD PTR _ourNewScoreW$[ebp]
  0039b	72 17		 jb	 SHORT $LN16@MYCHOICE

; 458  :       {
; 459  :         //We will choose to take the whole string and move again
; 460  :         computerMove.con = *this;

  0039d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  003a0	52		 push	 edx
  003a1	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  003a6	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=

; 461  :         result.moveType = MT_MAXCAPTURE;

  003ab	c7 45 88 14 00
	00 00		 mov	 DWORD PTR _result$[ebp+8], 20 ; 00000014H

; 462  :       }

  003b2	eb 15		 jmp	 SHORT $LN17@MYCHOICE
$LN16@MYCHOICE:

; 463  :       else
; 464  :       {
; 465  :         // We will decline the coins and make him move next.
; 466  :         computerMove.con = *this;

  003b4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  003b7	50		 push	 eax
  003b8	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  003bd	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=

; 467  :         result.moveType = MT_MAXDECLINE;

  003c2	c7 45 88 13 00
	00 00		 mov	 DWORD PTR _result$[ebp+8], 19 ; 00000013H
$LN17@MYCHOICE:

; 468  :       };
; 469  :       m_coinsRemaining += total;

  003c9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  003cc	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  003cf	03 55 14	 add	 edx, DWORD PTR _total$[ebp]
  003d2	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  003d5	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN9@MYCHOICE:

; 470  :     };
; 471  :   };
; 472  :   return result;

  003d8	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  003db	8b 55 80	 mov	 edx, DWORD PTR _result$[ebp]
  003de	89 11		 mov	 DWORD PTR [ecx], edx
  003e0	8b 45 84	 mov	 eax, DWORD PTR _result$[ebp+4]
  003e3	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  003e6	8b 55 88	 mov	 edx, DWORD PTR _result$[ebp+8]
  003e9	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  003ec	8b 45 8c	 mov	 eax, DWORD PTR _result$[ebp+12]
  003ef	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  003f2	8b 55 90	 mov	 edx, DWORD PTR _result$[ebp+16]
  003f5	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  003f8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003ff	8d 8d 68 eb ff
	ff		 lea	 ecx, DWORD PTR _nimcon$[ebp]
  00405	e8 00 00 00 00	 call	 ??1NIMCON@@QAE@XZ
  0040a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@MYCHOICE:

; 473  : }

  0040d	52		 push	 edx
  0040e	8b cd		 mov	 ecx, ebp
  00410	50		 push	 eax
  00411	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN28@MYCHOICE
  00417	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0041c	58		 pop	 eax
  0041d	5a		 pop	 edx
  0041e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00421	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00428	59		 pop	 ecx
  00429	5f		 pop	 edi
  0042a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0042d	33 cd		 xor	 ecx, ebp
  0042f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00434	81 c4 c8 14 00
	00		 add	 esp, 5320		; 000014c8H
  0043a	3b ec		 cmp	 ebp, esp
  0043c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00441	8b e5		 mov	 esp, ebp
  00443	5d		 pop	 ebp
  00444	c2 18 00	 ret	 24			; 00000018H
  00447	90		 npad	 1
$LN28@MYCHOICE:
  00448	04 00 00 00	 DD	 4
  0044c	00 00 00 00	 DD	 $LN27@MYCHOICE
$LN27@MYCHOICE:
  00450	b8 ff ff ff	 DD	 -72			; ffffffb8H
  00454	14 00 00 00	 DD	 20			; 00000014H
  00458	00 00 00 00	 DD	 $LN22@MYCHOICE
  0045c	9c ff ff ff	 DD	 -100			; ffffff9cH
  00460	14 00 00 00	 DD	 20			; 00000014H
  00464	00 00 00 00	 DD	 $LN23@MYCHOICE
  00468	80 ff ff ff	 DD	 -128			; ffffff80H
  0046c	14 00 00 00	 DD	 20			; 00000014H
  00470	00 00 00 00	 DD	 $LN24@MYCHOICE
  00474	68 eb ff ff	 DD	 -5272			; ffffeb68H
  00478	10 14 00 00	 DD	 5136			; 00001410H
  0047c	00 00 00 00	 DD	 $LN25@MYCHOICE
$LN25@MYCHOICE:
  00480	6e		 DB	 110			; 0000006eH
  00481	69		 DB	 105			; 00000069H
  00482	6d		 DB	 109			; 0000006dH
  00483	63		 DB	 99			; 00000063H
  00484	6f		 DB	 111			; 0000006fH
  00485	6e		 DB	 110			; 0000006eH
  00486	00		 DB	 0
$LN24@MYCHOICE:
  00487	72		 DB	 114			; 00000072H
  00488	65		 DB	 101			; 00000065H
  00489	73		 DB	 115			; 00000073H
  0048a	75		 DB	 117			; 00000075H
  0048b	6c		 DB	 108			; 0000006cH
  0048c	74		 DB	 116			; 00000074H
  0048d	00		 DB	 0
$LN23@MYCHOICE:
  0048e	77		 DB	 119			; 00000077H
  0048f	00		 DB	 0
$LN22@MYCHOICE:
  00490	76		 DB	 118			; 00000076H
  00491	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?MYCHOICE@CON@@QAE?AUSWVALUE@@IIIIPAUPossibleMove@@@Z$0:
  00000	8d 8d 68 eb ff
	ff		 lea	 ecx, DWORD PTR _nimcon$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1NIMCON@@QAE@XZ
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$?MYCHOICE@CON@@QAE?AUSWVALUE@@IIIIPAUPossibleMove@@@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 3c eb ff
	ff		 mov	 ecx, DWORD PTR [edx-5316]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MYCHOICE@CON@@QAE?AUSWVALUE@@IIIIPAUPossibleMove@@@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MYCHOICE@CON@@QAE?AUSWVALUE@@IIIIPAUPossibleMove@@@Z ENDP ; CON::MYCHOICE
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\SWEvaluate.cpp
_TEXT	SEGMENT
_temp$1 = -60						; size = 4
_deCount$ = -56						; size = 4
_capture2edge$ = -52					; size = 4
_capture1edge$ = -48					; size = 4
_capture2len$ = -44					; size = 4
_capture1len$ = -40					; size = 4
_capture2nnA$ = -36					; size = 4
_capture1nnA$ = -32					; size = 4
_en2$ = -28						; size = 4
_nn4$ = -24						; size = 4
_nn2$ = -20						; size = 4
_en$ = -16						; size = 4
_nnA$ = -12						; size = 4
_nn$ = -8						; size = 4
_this$ = -4						; size = 4
?ObviousCapture@CON@@QAEXXZ PROC			; CON::ObviousCapture
; _this$ = ecx

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	57		 push	 edi
  00007	51		 push	 ecx
  00008	8d 7d c4	 lea	 edi, DWORD PTR [ebp-60]
  0000b	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	59		 pop	 ecx
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 180  :   // Grab a terminal coin at the end of a
; 181  :   // chain unless the chain is length one.
; 182  :   int nn, nnA, en;
; 183  :   int nn2=-1, nn4=-1, en2=-1;

  0001b	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _nn2$[ebp], -1
  00022	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR _nn4$[ebp], -1
  00029	c7 45 e4 ff ff
	ff ff		 mov	 DWORD PTR _en2$[ebp], -1

; 184  :   int capture1nnA, capture2nnA;
; 185  :   int capture1len, capture2len;
; 186  :   int capture1edge, capture2edge;
; 187  :   int deCount = 0;

  00030	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _deCount$[ebp], 0

; 188  :   //If there are two chains with capturable coins then
; 189  :   //we will certainly capture something.
; 190  :   capture1nnA = capture1len = capture1edge = -1;

  00037	c7 45 d0 ff ff
	ff ff		 mov	 DWORD PTR _capture1edge$[ebp], -1
  0003e	8b 45 d0	 mov	 eax, DWORD PTR _capture1edge$[ebp]
  00041	89 45 d8	 mov	 DWORD PTR _capture1len$[ebp], eax
  00044	8b 4d d8	 mov	 ecx, DWORD PTR _capture1len$[ebp]
  00047	89 4d e0	 mov	 DWORD PTR _capture1nnA$[ebp], ecx

; 191  :   capture2nnA = capture2len = capture2edge = -1;

  0004a	c7 45 cc ff ff
	ff ff		 mov	 DWORD PTR _capture2edge$[ebp], -1
  00051	8b 55 cc	 mov	 edx, DWORD PTR _capture2edge$[ebp]
  00054	89 55 d4	 mov	 DWORD PTR _capture2len$[ebp], edx
  00057	8b 45 d4	 mov	 eax, DWORD PTR _capture2len$[ebp]
  0005a	89 45 dc	 mov	 DWORD PTR _capture2nnA$[ebp], eax

; 192  :   for (nn=0; nn<m_numNode; nn++)

  0005d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nn$[ebp], 0
  00064	eb 09		 jmp	 SHORT $LN4@ObviousCap
$LN2@ObviousCap:
  00066	8b 4d f8	 mov	 ecx, DWORD PTR _nn$[ebp]
  00069	83 c1 01	 add	 ecx, 1
  0006c	89 4d f8	 mov	 DWORD PTR _nn$[ebp], ecx
$LN4@ObviousCap:
  0006f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00072	8b 45 f8	 mov	 eax, DWORD PTR _nn$[ebp]
  00075	3b 02		 cmp	 eax, DWORD PTR [edx]
  00077	0f 8d 74 01 00
	00		 jge	 $LN3@ObviousCap

; 193  :   {
; 194  :     nnA = nd[nn].ix;

  0007d	8b 4d f8	 mov	 ecx, DWORD PTR _nn$[ebp]
  00080	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00083	0f b6 84 8a 13
	10 00 00	 movzx	 eax, BYTE PTR [edx+ecx*4+4115]
  0008b	89 45 f4	 mov	 DWORD PTR _nnA$[ebp], eax

; 195  :     if (sd[nnA][0].ns == DE_DE)

  0008e	8b 4d f4	 mov	 ecx, DWORD PTR _nnA$[ebp]
  00091	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00094	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  0009b	b9 02 00 00 00	 mov	 ecx, 2
  000a0	6b d1 00	 imul	 edx, ecx, 0
  000a3	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  000a7	3d fb 00 00 00	 cmp	 eax, 251		; 000000fbH
  000ac	75 31		 jne	 SHORT $LN14@ObviousCap

; 196  :     {
; 197  :       capture2nnA = capture1nnA;

  000ae	8b 4d e0	 mov	 ecx, DWORD PTR _capture1nnA$[ebp]
  000b1	89 4d dc	 mov	 DWORD PTR _capture2nnA$[ebp], ecx

; 198  :       capture1nnA = nnA;

  000b4	8b 55 f4	 mov	 edx, DWORD PTR _nnA$[ebp]
  000b7	89 55 e0	 mov	 DWORD PTR _capture1nnA$[ebp], edx

; 199  :       capture2len = capture1len;

  000ba	8b 45 d8	 mov	 eax, DWORD PTR _capture1len$[ebp]
  000bd	89 45 d4	 mov	 DWORD PTR _capture2len$[ebp], eax

; 200  :       capture1len = ed[nnA].e[0].el;

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR _nnA$[ebp]
  000c3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c6	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  000ca	b9 02 00 00 00	 mov	 ecx, 2
  000cf	6b d1 00	 imul	 edx, ecx, 0
  000d2	0f b6 44 10 01	 movzx	 eax, BYTE PTR [eax+edx+1]
  000d7	89 45 d8	 mov	 DWORD PTR _capture1len$[ebp], eax

; 201  :     }

  000da	e9 0d 01 00 00	 jmp	 $LN15@ObviousCap
$LN14@ObviousCap:

; 202  :     else if (sd[nnA][0].ns == GND_DE)

  000df	8b 4d f4	 mov	 ecx, DWORD PTR _nnA$[ebp]
  000e2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000e5	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  000ec	b9 02 00 00 00	 mov	 ecx, 2
  000f1	6b d1 00	 imul	 edx, ecx, 0
  000f4	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  000f8	3d fc 00 00 00	 cmp	 eax, 252		; 000000fcH
  000fd	75 31		 jne	 SHORT $LN16@ObviousCap

; 203  :     {
; 204  :       capture2nnA = capture1nnA;

  000ff	8b 4d e0	 mov	 ecx, DWORD PTR _capture1nnA$[ebp]
  00102	89 4d dc	 mov	 DWORD PTR _capture2nnA$[ebp], ecx

; 205  :       capture1nnA = nnA;

  00105	8b 55 f4	 mov	 edx, DWORD PTR _nnA$[ebp]
  00108	89 55 e0	 mov	 DWORD PTR _capture1nnA$[ebp], edx

; 206  :       capture2len = capture1len;

  0010b	8b 45 d8	 mov	 eax, DWORD PTR _capture1len$[ebp]
  0010e	89 45 d4	 mov	 DWORD PTR _capture2len$[ebp], eax

; 207  :       capture1len = ed[nnA].e[0].el;

  00111	8b 4d f4	 mov	 ecx, DWORD PTR _nnA$[ebp]
  00114	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00117	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  0011b	b9 02 00 00 00	 mov	 ecx, 2
  00120	6b d1 00	 imul	 edx, ecx, 0
  00123	0f b6 44 10 01	 movzx	 eax, BYTE PTR [eax+edx+1]
  00128	89 45 d8	 mov	 DWORD PTR _capture1len$[ebp], eax

; 208  :     }

  0012b	e9 bc 00 00 00	 jmp	 $LN15@ObviousCap
$LN16@ObviousCap:

; 209  :     else if (   (sd[nnA][0].ns == GND_GND)
; 210  :              || (sd[nnA][0].ns == LOOP)

  00130	8b 4d f4	 mov	 ecx, DWORD PTR _nnA$[ebp]
  00133	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00136	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  0013d	b9 02 00 00 00	 mov	 ecx, 2
  00142	6b d1 00	 imul	 edx, ecx, 0
  00145	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  00149	3d fd 00 00 00	 cmp	 eax, 253		; 000000fdH
  0014e	74 20		 je	 SHORT $LN20@ObviousCap
  00150	8b 4d f4	 mov	 ecx, DWORD PTR _nnA$[ebp]
  00153	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00156	8d 84 ca 10 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx*8+2064]
  0015d	b9 02 00 00 00	 mov	 ecx, 2
  00162	6b d1 00	 imul	 edx, ecx, 0
  00165	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  00169	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  0016e	75 07		 jne	 SHORT $LN18@ObviousCap
$LN20@ObviousCap:

; 211  :             )
; 212  :     {
; 213  :       continue;

  00170	e9 f1 fe ff ff	 jmp	 $LN2@ObviousCap

; 214  :     }

  00175	eb 75		 jmp	 SHORT $LN15@ObviousCap
$LN18@ObviousCap:

; 215  :     else
; 216  :     {
; 217  :       for (en=0; en<nd[nnA].ec; en++)

  00177	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _en$[ebp], 0
  0017e	eb 09		 jmp	 SHORT $LN7@ObviousCap
$LN5@ObviousCap:
  00180	8b 4d f0	 mov	 ecx, DWORD PTR _en$[ebp]
  00183	83 c1 01	 add	 ecx, 1
  00186	89 4d f0	 mov	 DWORD PTR _en$[ebp], ecx
$LN7@ObviousCap:
  00189	8b 55 f4	 mov	 edx, DWORD PTR _nnA$[ebp]
  0018c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0018f	0f b6 8c 90 10
	10 00 00	 movzx	 ecx, BYTE PTR [eax+edx*4+4112]
  00197	39 4d f0	 cmp	 DWORD PTR _en$[ebp], ecx
  0019a	7d 50		 jge	 SHORT $LN15@ObviousCap

; 218  :       {
; 219  :         if (sd[nnA][en].ns == DEADEND)

  0019c	8b 55 f4	 mov	 edx, DWORD PTR _nnA$[ebp]
  0019f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001a2	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  001a9	8b 55 f0	 mov	 edx, DWORD PTR _en$[ebp]
  001ac	0f b6 04 51	 movzx	 eax, BYTE PTR [ecx+edx*2]
  001b0	3d f9 00 00 00	 cmp	 eax, 249		; 000000f9H
  001b5	75 33		 jne	 SHORT $LN21@ObviousCap

; 220  :         {
; 221  :           capture2nnA  = capture1nnA;

  001b7	8b 4d e0	 mov	 ecx, DWORD PTR _capture1nnA$[ebp]
  001ba	89 4d dc	 mov	 DWORD PTR _capture2nnA$[ebp], ecx

; 222  :           capture2edge = capture1edge;

  001bd	8b 55 d0	 mov	 edx, DWORD PTR _capture1edge$[ebp]
  001c0	89 55 cc	 mov	 DWORD PTR _capture2edge$[ebp], edx

; 223  :           capture2len  = capture1len;

  001c3	8b 45 d8	 mov	 eax, DWORD PTR _capture1len$[ebp]
  001c6	89 45 d4	 mov	 DWORD PTR _capture2len$[ebp], eax

; 224  :           capture1nnA  = nnA;

  001c9	8b 4d f4	 mov	 ecx, DWORD PTR _nnA$[ebp]
  001cc	89 4d e0	 mov	 DWORD PTR _capture1nnA$[ebp], ecx

; 225  :           capture1edge = en;

  001cf	8b 55 f0	 mov	 edx, DWORD PTR _en$[ebp]
  001d2	89 55 d0	 mov	 DWORD PTR _capture1edge$[ebp], edx

; 226  :           capture1len  = ed[nnA].e[en].el;

  001d5	8b 45 f4	 mov	 eax, DWORD PTR _nnA$[ebp]
  001d8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001db	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  001df	8b 45 f0	 mov	 eax, DWORD PTR _en$[ebp]
  001e2	0f b6 4c 42 01	 movzx	 ecx, BYTE PTR [edx+eax*2+1]
  001e7	89 4d d8	 mov	 DWORD PTR _capture1len$[ebp], ecx
$LN21@ObviousCap:

; 227  :         };
; 228  :       };

  001ea	eb 94		 jmp	 SHORT $LN5@ObviousCap
$LN15@ObviousCap:

; 229  :     };
; 230  :   };

  001ec	e9 75 fe ff ff	 jmp	 $LN2@ObviousCap
$LN3@ObviousCap:

; 231  :   if (capture2nnA != -1)

  001f1	83 7d dc ff	 cmp	 DWORD PTR _capture2nnA$[ebp], -1
  001f5	0f 84 9c 00 00
	00		 je	 $LN22@ObviousCap

; 232  :   {
; 233  :     //There are two capturable chains.  We need to capture
; 234  :     //something!!!
; 235  :     if (capture2len < capture1len)

  001fb	8b 55 d4	 mov	 edx, DWORD PTR _capture2len$[ebp]
  001fe	3b 55 d8	 cmp	 edx, DWORD PTR _capture1len$[ebp]
  00201	7d 36		 jge	 SHORT $LN23@ObviousCap

; 236  :     {
; 237  :       int temp;
; 238  :       temp = capture1len;

  00203	8b 45 d8	 mov	 eax, DWORD PTR _capture1len$[ebp]
  00206	89 45 c4	 mov	 DWORD PTR _temp$1[ebp], eax

; 239  :       capture1len = capture2len;

  00209	8b 4d d4	 mov	 ecx, DWORD PTR _capture2len$[ebp]
  0020c	89 4d d8	 mov	 DWORD PTR _capture1len$[ebp], ecx

; 240  :       capture2len = temp;

  0020f	8b 55 c4	 mov	 edx, DWORD PTR _temp$1[ebp]
  00212	89 55 d4	 mov	 DWORD PTR _capture2len$[ebp], edx

; 241  :   
; 242  :       temp = capture1nnA;

  00215	8b 45 e0	 mov	 eax, DWORD PTR _capture1nnA$[ebp]
  00218	89 45 c4	 mov	 DWORD PTR _temp$1[ebp], eax

; 243  :       capture1nnA = capture2nnA;

  0021b	8b 4d dc	 mov	 ecx, DWORD PTR _capture2nnA$[ebp]
  0021e	89 4d e0	 mov	 DWORD PTR _capture1nnA$[ebp], ecx

; 244  :       capture2nnA = temp;

  00221	8b 55 c4	 mov	 edx, DWORD PTR _temp$1[ebp]
  00224	89 55 dc	 mov	 DWORD PTR _capture2nnA$[ebp], edx

; 245  :   
; 246  :       temp = capture1edge;

  00227	8b 45 d0	 mov	 eax, DWORD PTR _capture1edge$[ebp]
  0022a	89 45 c4	 mov	 DWORD PTR _temp$1[ebp], eax

; 247  :       capture1edge = capture2edge;

  0022d	8b 4d cc	 mov	 ecx, DWORD PTR _capture2edge$[ebp]
  00230	89 4d d0	 mov	 DWORD PTR _capture1edge$[ebp], ecx

; 248  :       capture2edge = temp;

  00233	8b 55 c4	 mov	 edx, DWORD PTR _temp$1[ebp]
  00236	89 55 cc	 mov	 DWORD PTR _capture2edge$[ebp], edx
$LN23@ObviousCap:

; 249  :     };
; 250  :     //The shorter one comes first.
; 251  :     if (sd[capture1nnA][0].ns != DE_DE)

  00239	8b 45 e0	 mov	 eax, DWORD PTR _capture1nnA$[ebp]
  0023c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0023f	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  00246	b8 02 00 00 00	 mov	 eax, 2
  0024b	6b c8 00	 imul	 ecx, eax, 0
  0024e	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  00252	81 fa fb 00 00
	00		 cmp	 edx, 251		; 000000fbH
  00258	74 2a		 je	 SHORT $LN24@ObviousCap

; 252  :     {
; 253  :       if (capture1len == 1)

  0025a	83 7d d8 01	 cmp	 DWORD PTR _capture1len$[ebp], 1
  0025e	75 12		 jne	 SHORT $LN26@ObviousCap

; 254  :       {
; 255  :         Capture(capture1nnA, capture1edge);

  00260	8b 45 d0	 mov	 eax, DWORD PTR _capture1edge$[ebp]
  00263	50		 push	 eax
  00264	8b 4d e0	 mov	 ecx, DWORD PTR _capture1nnA$[ebp]
  00267	51		 push	 ecx
  00268	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0026b	e8 00 00 00 00	 call	 ?Capture@CON@@QAEXHH@Z	; CON::Capture

; 256  :       }

  00270	eb 10		 jmp	 SHORT $LN27@ObviousCap
$LN26@ObviousCap:

; 257  :       else
; 258  :       {
; 259  :         Capture(capture2nnA, capture2edge);

  00272	8b 55 cc	 mov	 edx, DWORD PTR _capture2edge$[ebp]
  00275	52		 push	 edx
  00276	8b 45 dc	 mov	 eax, DWORD PTR _capture2nnA$[ebp]
  00279	50		 push	 eax
  0027a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0027d	e8 00 00 00 00	 call	 ?Capture@CON@@QAEXHH@Z	; CON::Capture
$LN27@ObviousCap:

; 260  :       };
; 261  :     }

  00282	eb 0e		 jmp	 SHORT $LN25@ObviousCap
$LN24@ObviousCap:

; 262  :     else
; 263  :     {
; 264  :       Capture(capture1nnA, 0);

  00284	6a 00		 push	 0
  00286	8b 4d e0	 mov	 ecx, DWORD PTR _capture1nnA$[ebp]
  00289	51		 push	 ecx
  0028a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0028d	e8 00 00 00 00	 call	 ?Capture@CON@@QAEXHH@Z	; CON::Capture
$LN25@ObviousCap:

; 265  :     };
; 266  :     return;

  00292	e9 1e 02 00 00	 jmp	 $LN1@ObviousCap
$LN22@ObviousCap:

; 267  :   };        
; 268  :   //There are not two capturable chains.
; 269  :   for (nn=0; nn<m_numNode; nn++)

  00297	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nn$[ebp], 0
  0029e	eb 09		 jmp	 SHORT $LN10@ObviousCap
$LN8@ObviousCap:
  002a0	8b 55 f8	 mov	 edx, DWORD PTR _nn$[ebp]
  002a3	83 c2 01	 add	 edx, 1
  002a6	89 55 f8	 mov	 DWORD PTR _nn$[ebp], edx
$LN10@ObviousCap:
  002a9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002ac	8b 4d f8	 mov	 ecx, DWORD PTR _nn$[ebp]
  002af	3b 08		 cmp	 ecx, DWORD PTR [eax]
  002b1	0f 8d 6e 01 00
	00		 jge	 $LN9@ObviousCap

; 270  :   {
; 271  :     nnA = nd[nn].ix;

  002b7	8b 55 f8	 mov	 edx, DWORD PTR _nn$[ebp]
  002ba	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002bd	0f b6 8c 90 13
	10 00 00	 movzx	 ecx, BYTE PTR [eax+edx*4+4115]
  002c5	89 4d f4	 mov	 DWORD PTR _nnA$[ebp], ecx

; 272  :     if (sd[nnA][0].ns == DE_DE)

  002c8	8b 55 f4	 mov	 edx, DWORD PTR _nnA$[ebp]
  002cb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002ce	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  002d5	ba 02 00 00 00	 mov	 edx, 2
  002da	6b c2 00	 imul	 eax, edx, 0
  002dd	0f b6 0c 01	 movzx	 ecx, BYTE PTR [ecx+eax]
  002e1	81 f9 fb 00 00
	00		 cmp	 ecx, 251		; 000000fbH
  002e7	75 4d		 jne	 SHORT $LN28@ObviousCap

; 273  :     {
; 274  :       //The chain has capturable coins on both
; 275  :       //ends. If the chain is four long then further
; 276  :       //analysis is necessary.   Otherwise take!
; 277  :       if ((ed[nnA].e[0].el != 4) || (m_numNode == 1))

  002e9	8b 55 f4	 mov	 edx, DWORD PTR _nnA$[ebp]
  002ec	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002ef	8d 4c d0 10	 lea	 ecx, DWORD PTR [eax+edx*8+16]
  002f3	ba 02 00 00 00	 mov	 edx, 2
  002f8	6b c2 00	 imul	 eax, edx, 0
  002fb	0f b6 4c 01 01	 movzx	 ecx, BYTE PTR [ecx+eax+1]
  00300	83 f9 04	 cmp	 ecx, 4
  00303	75 08		 jne	 SHORT $LN32@ObviousCap
  00305	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00308	83 3a 01	 cmp	 DWORD PTR [edx], 1
  0030b	75 15		 jne	 SHORT $LN30@ObviousCap
$LN32@ObviousCap:

; 278  :       {
; 279  :         Capture(nnA, 0);

  0030d	6a 00		 push	 0
  0030f	8b 45 f4	 mov	 eax, DWORD PTR _nnA$[ebp]
  00312	50		 push	 eax
  00313	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00316	e8 00 00 00 00	 call	 ?Capture@CON@@QAEXHH@Z	; CON::Capture

; 280  :         return;

  0031b	e9 95 01 00 00	 jmp	 $LN1@ObviousCap

; 281  :       }

  00320	eb 0f		 jmp	 SHORT $LN31@ObviousCap
$LN30@ObviousCap:

; 282  :       else
; 283  :       {
; 284  :         nn4 = nnA;

  00322	8b 4d f4	 mov	 ecx, DWORD PTR _nnA$[ebp]
  00325	89 4d e8	 mov	 DWORD PTR _nn4$[ebp], ecx

; 285  :         deCount++;

  00328	8b 55 c8	 mov	 edx, DWORD PTR _deCount$[ebp]
  0032b	83 c2 01	 add	 edx, 1
  0032e	89 55 c8	 mov	 DWORD PTR _deCount$[ebp], edx
$LN31@ObviousCap:

; 286  :       };
; 287  :     } 

  00331	e9 ea 00 00 00	 jmp	 $LN29@ObviousCap
$LN28@ObviousCap:

; 288  :     else if (sd[nnA][0].ns == GND_DE)

  00336	8b 45 f4	 mov	 eax, DWORD PTR _nnA$[ebp]
  00339	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0033c	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  00343	b8 02 00 00 00	 mov	 eax, 2
  00348	6b c8 00	 imul	 ecx, eax, 0
  0034b	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  0034f	81 fa fc 00 00
	00		 cmp	 edx, 252		; 000000fcH
  00355	75 51		 jne	 SHORT $LN33@ObviousCap

; 289  :     {
; 290  :       //The chain has a DEADEND at one end and a ground at 
; 291  :       //the other end.  Unless it is two coins long, take it.
; 292  :       if ((ed[nnA].e[0].el != 2) || (m_numNode == 1))

  00357	8b 45 f4	 mov	 eax, DWORD PTR _nnA$[ebp]
  0035a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0035d	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  00361	b8 02 00 00 00	 mov	 eax, 2
  00366	6b c8 00	 imul	 ecx, eax, 0
  00369	0f b6 54 0a 01	 movzx	 edx, BYTE PTR [edx+ecx+1]
  0036e	83 fa 02	 cmp	 edx, 2
  00371	75 08		 jne	 SHORT $LN37@ObviousCap
  00373	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00376	83 38 01	 cmp	 DWORD PTR [eax], 1
  00379	75 15		 jne	 SHORT $LN35@ObviousCap
$LN37@ObviousCap:

; 293  :       {
; 294  :         Capture(nnA, 0);

  0037b	6a 00		 push	 0
  0037d	8b 4d f4	 mov	 ecx, DWORD PTR _nnA$[ebp]
  00380	51		 push	 ecx
  00381	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00384	e8 00 00 00 00	 call	 ?Capture@CON@@QAEXHH@Z	; CON::Capture

; 295  :         return;

  00389	e9 27 01 00 00	 jmp	 $LN1@ObviousCap

; 296  :       }

  0038e	eb 16		 jmp	 SHORT $LN36@ObviousCap
$LN35@ObviousCap:

; 297  :       else
; 298  :       {
; 299  :         nn2 = nnA;

  00390	8b 55 f4	 mov	 edx, DWORD PTR _nnA$[ebp]
  00393	89 55 ec	 mov	 DWORD PTR _nn2$[ebp], edx

; 300  :         en2 = 0;

  00396	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _en2$[ebp], 0

; 301  :         deCount++;

  0039d	8b 45 c8	 mov	 eax, DWORD PTR _deCount$[ebp]
  003a0	83 c0 01	 add	 eax, 1
  003a3	89 45 c8	 mov	 DWORD PTR _deCount$[ebp], eax
$LN36@ObviousCap:

; 302  :       };
; 303  :     }

  003a6	eb 78		 jmp	 SHORT $LN29@ObviousCap
$LN33@ObviousCap:

; 304  :     else
; 305  :     {
; 306  :       //Look for a DEADEND attached to a node.
; 307  :       for (en=0; en<4; en++)

  003a8	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _en$[ebp], 0
  003af	eb 09		 jmp	 SHORT $LN13@ObviousCap
$LN11@ObviousCap:
  003b1	8b 4d f0	 mov	 ecx, DWORD PTR _en$[ebp]
  003b4	83 c1 01	 add	 ecx, 1
  003b7	89 4d f0	 mov	 DWORD PTR _en$[ebp], ecx
$LN13@ObviousCap:
  003ba	83 7d f0 04	 cmp	 DWORD PTR _en$[ebp], 4
  003be	7d 60		 jge	 SHORT $LN29@ObviousCap

; 308  :       {
; 309  :         if (sd[nnA][en].ns == DEADEND)

  003c0	8b 55 f4	 mov	 edx, DWORD PTR _nnA$[ebp]
  003c3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003c6	8d 8c d0 10 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx*8+2064]
  003cd	8b 55 f0	 mov	 edx, DWORD PTR _en$[ebp]
  003d0	0f b6 04 51	 movzx	 eax, BYTE PTR [ecx+edx*2]
  003d4	3d f9 00 00 00	 cmp	 eax, 249		; 000000f9H
  003d9	75 43		 jne	 SHORT $LN38@ObviousCap

; 310  :         {
; 311  :           if (ed[nnA].e[en].el != 2)

  003db	8b 4d f4	 mov	 ecx, DWORD PTR _nnA$[ebp]
  003de	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003e1	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  003e5	8b 4d f0	 mov	 ecx, DWORD PTR _en$[ebp]
  003e8	0f b6 54 48 01	 movzx	 edx, BYTE PTR [eax+ecx*2+1]
  003ed	83 fa 02	 cmp	 edx, 2
  003f0	74 17		 je	 SHORT $LN39@ObviousCap

; 312  :           {
; 313  :             Capture(nnA, en);

  003f2	8b 45 f0	 mov	 eax, DWORD PTR _en$[ebp]
  003f5	50		 push	 eax
  003f6	8b 4d f4	 mov	 ecx, DWORD PTR _nnA$[ebp]
  003f9	51		 push	 ecx
  003fa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003fd	e8 00 00 00 00	 call	 ?Capture@CON@@QAEXHH@Z	; CON::Capture

; 314  :             return;

  00402	e9 ae 00 00 00	 jmp	 $LN1@ObviousCap

; 315  :           }

  00407	eb 15		 jmp	 SHORT $LN38@ObviousCap
$LN39@ObviousCap:

; 316  :           else
; 317  :           {
; 318  :             nn2 = nnA;

  00409	8b 55 f4	 mov	 edx, DWORD PTR _nnA$[ebp]
  0040c	89 55 ec	 mov	 DWORD PTR _nn2$[ebp], edx

; 319  :             en2 = en;

  0040f	8b 45 f0	 mov	 eax, DWORD PTR _en$[ebp]
  00412	89 45 e4	 mov	 DWORD PTR _en2$[ebp], eax

; 320  :             deCount++;

  00415	8b 4d c8	 mov	 ecx, DWORD PTR _deCount$[ebp]
  00418	83 c1 01	 add	 ecx, 1
  0041b	89 4d c8	 mov	 DWORD PTR _deCount$[ebp], ecx
$LN38@ObviousCap:

; 321  :           };
; 322  :         };
; 323  :       };

  0041e	eb 91		 jmp	 SHORT $LN11@ObviousCap
$LN29@ObviousCap:

; 324  :     };
; 325  :   };

  00420	e9 7b fe ff ff	 jmp	 $LN8@ObviousCap
$LN9@ObviousCap:

; 326  :   if (deCount < 2) return;

  00425	83 7d c8 02	 cmp	 DWORD PTR _deCount$[ebp], 2
  00429	7d 05		 jge	 SHORT $LN41@ObviousCap
  0042b	e9 85 00 00 00	 jmp	 $LN1@ObviousCap
$LN41@ObviousCap:

; 327  :   computerMove.con = *this;

  00430	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00433	52		 push	 edx
  00434	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  00439	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=

; 328  :   moveType = MT_OBVIOUSCAPTURE;

  0043e	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?moveType@@3W4MOVE_TYPE@@A, 2 ; moveType

; 329  :   if (nn4 >= 0)

  00448	83 7d e8 00	 cmp	 DWORD PTR _nn4$[ebp], 0
  0044c	7c 37		 jl	 SHORT $LN42@ObviousCap

; 330  :   {
; 331  :     computerMove.con.ed[nn4].e[0].el--;

  0044e	b8 02 00 00 00	 mov	 eax, 2
  00453	6b c8 00	 imul	 ecx, eax, 0
  00456	8b 55 e8	 mov	 edx, DWORD PTR _nn4$[ebp]
  00459	8a 84 d1 19 00
	00 00		 mov	 al, BYTE PTR ?computerMove@@3UPossibleMove@@A[ecx+edx*8+25]
  00460	2c 01		 sub	 al, 1
  00462	b9 02 00 00 00	 mov	 ecx, 2
  00467	6b d1 00	 imul	 edx, ecx, 0
  0046a	8b 4d e8	 mov	 ecx, DWORD PTR _nn4$[ebp]
  0046d	88 84 ca 19 00
	00 00		 mov	 BYTE PTR ?computerMove@@3UPossibleMove@@A[edx+ecx*8+25], al

; 332  :     computerMove.con.m_coinsRemaining -= 1;

  00474	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?computerMove@@3UPossibleMove@@A+12
  0047a	83 ea 01	 sub	 edx, 1
  0047d	89 15 0c 00 00
	00		 mov	 DWORD PTR ?computerMove@@3UPossibleMove@@A+12, edx

; 333  :   }

  00483	eb 30		 jmp	 SHORT $LN1@ObviousCap
$LN42@ObviousCap:

; 334  :   else
; 335  :   {
; 336  :     computerMove.con.ed[nn2].e[en2].el--;

  00485	8b 45 e4	 mov	 eax, DWORD PTR _en2$[ebp]
  00488	d1 e0		 shl	 eax, 1
  0048a	8b 4d ec	 mov	 ecx, DWORD PTR _nn2$[ebp]
  0048d	8a 94 c8 19 00
	00 00		 mov	 dl, BYTE PTR ?computerMove@@3UPossibleMove@@A[eax+ecx*8+25]
  00494	80 ea 01	 sub	 dl, 1
  00497	8b 45 e4	 mov	 eax, DWORD PTR _en2$[ebp]
  0049a	d1 e0		 shl	 eax, 1
  0049c	8b 4d ec	 mov	 ecx, DWORD PTR _nn2$[ebp]
  0049f	88 94 c8 19 00
	00 00		 mov	 BYTE PTR ?computerMove@@3UPossibleMove@@A[eax+ecx*8+25], dl

; 337  :     computerMove.con.m_coinsRemaining -= 1;

  004a6	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?computerMove@@3UPossibleMove@@A+12
  004ac	83 ea 01	 sub	 edx, 1
  004af	89 15 0c 00 00
	00		 mov	 DWORD PTR ?computerMove@@3UPossibleMove@@A+12, edx
$LN1@ObviousCap:

; 338  :   };
; 339  : }

  004b5	5f		 pop	 edi
  004b6	83 c4 3c	 add	 esp, 60			; 0000003cH
  004b9	3b ec		 cmp	 ebp, esp
  004bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004c0	8b e5		 mov	 esp, ebp
  004c2	5d		 pop	 ebp
  004c3	c3		 ret	 0
?ObviousCapture@CON@@QAEXXZ ENDP			; CON::ObviousCapture
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\SWEvaluate.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nnA$ = 8						; size = 4
_edge$ = 12						; size = 4
?Capture@CON@@QAEXHH@Z PROC				; CON::Capture
; _this$ = ecx

; 111  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  :   if (sd[nnA][0].ns == DE_DE)

  0000e	8b 45 08	 mov	 eax, DWORD PTR _nnA$[ebp]
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  0001b	b8 02 00 00 00	 mov	 eax, 2
  00020	6b c8 00	 imul	 ecx, eax, 0
  00023	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  00027	81 fa fb 00 00
	00		 cmp	 edx, 251		; 000000fbH
  0002d	0f 85 ac 00 00
	00		 jne	 $LN2@Capture

; 113  :   {
; 114  :     computerMove.con = *this;

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	50		 push	 eax
  00037	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  0003c	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=

; 115  :     if (ed[nnA].e[0].el == 2)

  00041	8b 4d 08	 mov	 ecx, DWORD PTR _nnA$[ebp]
  00044	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00047	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  0004b	b9 02 00 00 00	 mov	 ecx, 2
  00050	6b d1 00	 imul	 edx, ecx, 0
  00053	0f b6 44 10 01	 movzx	 eax, BYTE PTR [eax+edx+1]
  00058	83 f8 02	 cmp	 eax, 2
  0005b	75 2a		 jne	 SHORT $LN4@Capture

; 116  :     {
; 117  :       computerMove.con.DeleteNode(nd[nnA].os);

  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _nnA$[ebp]
  00060	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00063	0f b6 84 8a 12
	10 00 00	 movzx	 eax, BYTE PTR [edx+ecx*4+4114]
  0006b	50		 push	 eax
  0006c	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  00071	e8 00 00 00 00	 call	 ?DeleteNode@CON@@QAEXH@Z ; CON::DeleteNode

; 118  :       computerMove.con.m_coinsRemaining -= 2;

  00076	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?computerMove@@3UPossibleMove@@A+12
  0007c	83 e9 02	 sub	 ecx, 2
  0007f	89 0d 0c 00 00
	00		 mov	 DWORD PTR ?computerMove@@3UPossibleMove@@A+12, ecx

; 119  :     }

  00085	eb 36		 jmp	 SHORT $LN5@Capture
$LN4@Capture:

; 120  :     else
; 121  :     {
; 122  :       computerMove.con.ed[nnA].e[0].el--;

  00087	ba 02 00 00 00	 mov	 edx, 2
  0008c	6b c2 00	 imul	 eax, edx, 0
  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _nnA$[ebp]
  00092	8a 94 c8 19 00
	00 00		 mov	 dl, BYTE PTR ?computerMove@@3UPossibleMove@@A[eax+ecx*8+25]
  00099	80 ea 01	 sub	 dl, 1
  0009c	b8 02 00 00 00	 mov	 eax, 2
  000a1	6b c8 00	 imul	 ecx, eax, 0
  000a4	8b 45 08	 mov	 eax, DWORD PTR _nnA$[ebp]
  000a7	88 94 c1 19 00
	00 00		 mov	 BYTE PTR ?computerMove@@3UPossibleMove@@A[ecx+eax*8+25], dl

; 123  :       computerMove.con.m_coinsRemaining -= 1;

  000ae	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?computerMove@@3UPossibleMove@@A+12
  000b4	83 e9 01	 sub	 ecx, 1
  000b7	89 0d 0c 00 00
	00		 mov	 DWORD PTR ?computerMove@@3UPossibleMove@@A+12, ecx
$LN5@Capture:

; 124  :     };
; 125  :     computerMove.con.Canon(0,computerMove.con.m_numNode);

  000bd	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ?computerMove@@3UPossibleMove@@A+8
  000c3	52		 push	 edx
  000c4	6a 00		 push	 0
  000c6	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  000cb	e8 00 00 00 00	 call	 ?Canon@CON@@QAEXHH@Z	; CON::Canon

; 126  : #ifdef _CHECK
; 127  :     computerMove.con.CheckEverything(0,computerMove.con.m_numNode,false);
; 128  : #endif
; 129  :     moveType = MT_OBVIOUSCAPTURE;

  000d0	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?moveType@@3W4MOVE_TYPE@@A, 2 ; moveType

; 130  :   }

  000da	e9 a0 01 00 00	 jmp	 $LN1@Capture
$LN2@Capture:

; 131  :   else if (sd[nnA][0].ns == GND_DE)

  000df	8b 45 08	 mov	 eax, DWORD PTR _nnA$[ebp]
  000e2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e5	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  000ec	b8 02 00 00 00	 mov	 eax, 2
  000f1	6b c8 00	 imul	 ecx, eax, 0
  000f4	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  000f8	81 fa fc 00 00
	00		 cmp	 edx, 252		; 000000fcH
  000fe	0f 85 b1 00 00
	00		 jne	 $LN6@Capture

; 132  :   {
; 133  :     computerMove.con = *this;

  00104	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00107	50		 push	 eax
  00108	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  0010d	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=

; 134  :     if (ed[nnA].e[0].el == 1)

  00112	8b 4d 08	 mov	 ecx, DWORD PTR _nnA$[ebp]
  00115	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00118	8d 44 ca 10	 lea	 eax, DWORD PTR [edx+ecx*8+16]
  0011c	b9 02 00 00 00	 mov	 ecx, 2
  00121	6b d1 00	 imul	 edx, ecx, 0
  00124	0f b6 44 10 01	 movzx	 eax, BYTE PTR [eax+edx+1]
  00129	83 f8 01	 cmp	 eax, 1
  0012c	75 2a		 jne	 SHORT $LN8@Capture

; 135  :     {
; 136  :       computerMove.con.DeleteNode(nd[nnA].os);

  0012e	8b 4d 08	 mov	 ecx, DWORD PTR _nnA$[ebp]
  00131	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00134	0f b6 84 8a 12
	10 00 00	 movzx	 eax, BYTE PTR [edx+ecx*4+4114]
  0013c	50		 push	 eax
  0013d	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  00142	e8 00 00 00 00	 call	 ?DeleteNode@CON@@QAEXH@Z ; CON::DeleteNode

; 137  :       computerMove.con.m_coinsRemaining -= 1;

  00147	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?computerMove@@3UPossibleMove@@A+12
  0014d	83 e9 01	 sub	 ecx, 1
  00150	89 0d 0c 00 00
	00		 mov	 DWORD PTR ?computerMove@@3UPossibleMove@@A+12, ecx

; 138  :     }

  00156	eb 36		 jmp	 SHORT $LN9@Capture
$LN8@Capture:

; 139  :     else
; 140  :     {
; 141  :       computerMove.con.ed[nnA].e[0].el--;

  00158	ba 02 00 00 00	 mov	 edx, 2
  0015d	6b c2 00	 imul	 eax, edx, 0
  00160	8b 4d 08	 mov	 ecx, DWORD PTR _nnA$[ebp]
  00163	8a 94 c8 19 00
	00 00		 mov	 dl, BYTE PTR ?computerMove@@3UPossibleMove@@A[eax+ecx*8+25]
  0016a	80 ea 01	 sub	 dl, 1
  0016d	b8 02 00 00 00	 mov	 eax, 2
  00172	6b c8 00	 imul	 ecx, eax, 0
  00175	8b 45 08	 mov	 eax, DWORD PTR _nnA$[ebp]
  00178	88 94 c1 19 00
	00 00		 mov	 BYTE PTR ?computerMove@@3UPossibleMove@@A[ecx+eax*8+25], dl

; 142  :       computerMove.con.m_coinsRemaining -= 1;

  0017f	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?computerMove@@3UPossibleMove@@A+12
  00185	83 e9 01	 sub	 ecx, 1
  00188	89 0d 0c 00 00
	00		 mov	 DWORD PTR ?computerMove@@3UPossibleMove@@A+12, ecx
$LN9@Capture:

; 143  :     };
; 144  :     computerMove.con.Canon(0,computerMove.con.m_numNode);

  0018e	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ?computerMove@@3UPossibleMove@@A+8
  00194	52		 push	 edx
  00195	6a 00		 push	 0
  00197	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  0019c	e8 00 00 00 00	 call	 ?Canon@CON@@QAEXHH@Z	; CON::Canon

; 145  : #ifdef _CHECK
; 146  :     computerMove.con.CheckEverything(0,computerMove.con.m_numNode,false);
; 147  : #endif
; 148  :     moveType = MT_OBVIOUSCAPTURE;

  001a1	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?moveType@@3W4MOVE_TYPE@@A, 2 ; moveType

; 149  :     return;

  001ab	e9 cf 00 00 00	 jmp	 $LN1@Capture

; 150  :   }

  001b0	e9 ca 00 00 00	 jmp	 $LN1@Capture
$LN6@Capture:

; 151  :   else if (sd[nnA][edge].ns == DEADEND)

  001b5	8b 45 08	 mov	 eax, DWORD PTR _nnA$[ebp]
  001b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001bb	8d 94 c1 10 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax*8+2064]
  001c2	8b 45 0c	 mov	 eax, DWORD PTR _edge$[ebp]
  001c5	0f b6 0c 42	 movzx	 ecx, BYTE PTR [edx+eax*2]
  001c9	81 f9 f9 00 00
	00		 cmp	 ecx, 249		; 000000f9H
  001cf	0f 85 9d 00 00
	00		 jne	 $LN10@Capture

; 152  :   {
; 153  :     computerMove.con = *this;

  001d5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001d8	52		 push	 edx
  001d9	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  001de	e8 00 00 00 00	 call	 ??4CON@@QAEAAV0@ABV0@@Z	; CON::operator=

; 154  :     moveType = MT_OBVIOUSCAPTURE;

  001e3	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?moveType@@3W4MOVE_TYPE@@A, 2 ; moveType

; 155  :     if (ed[nnA].e[edge].el == 1)

  001ed	8b 45 08	 mov	 eax, DWORD PTR _nnA$[ebp]
  001f0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001f3	8d 54 c1 10	 lea	 edx, DWORD PTR [ecx+eax*8+16]
  001f7	8b 45 0c	 mov	 eax, DWORD PTR _edge$[ebp]
  001fa	0f b6 4c 42 01	 movzx	 ecx, BYTE PTR [edx+eax*2+1]
  001ff	83 f9 01	 cmp	 ecx, 1
  00202	75 2c		 jne	 SHORT $LN12@Capture

; 156  :     {
; 157  :       computerMove.con.DeleteEdge(nd[nnA].os, edge);

  00204	8b 55 0c	 mov	 edx, DWORD PTR _edge$[ebp]
  00207	52		 push	 edx
  00208	8b 45 08	 mov	 eax, DWORD PTR _nnA$[ebp]
  0020b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0020e	0f b6 94 81 12
	10 00 00	 movzx	 edx, BYTE PTR [ecx+eax*4+4114]
  00216	52		 push	 edx
  00217	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  0021c	e8 00 00 00 00	 call	 ?DeleteEdge@CON@@QAEXHH@Z ; CON::DeleteEdge

; 158  :       computerMove.con.m_coinsRemaining -= 1;

  00221	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?computerMove@@3UPossibleMove@@A+12
  00226	83 e8 01	 sub	 eax, 1
  00229	a3 0c 00 00 00	 mov	 DWORD PTR ?computerMove@@3UPossibleMove@@A+12, eax

; 159  :     }

  0022e	eb 2d		 jmp	 SHORT $LN13@Capture
$LN12@Capture:

; 160  :     else
; 161  :     {
; 162  :       computerMove.con.ed[nnA].e[edge].el--;

  00230	8b 4d 0c	 mov	 ecx, DWORD PTR _edge$[ebp]
  00233	d1 e1		 shl	 ecx, 1
  00235	8b 55 08	 mov	 edx, DWORD PTR _nnA$[ebp]
  00238	8a 84 d1 19 00
	00 00		 mov	 al, BYTE PTR ?computerMove@@3UPossibleMove@@A[ecx+edx*8+25]
  0023f	2c 01		 sub	 al, 1
  00241	8b 4d 0c	 mov	 ecx, DWORD PTR _edge$[ebp]
  00244	d1 e1		 shl	 ecx, 1
  00246	8b 55 08	 mov	 edx, DWORD PTR _nnA$[ebp]
  00249	88 84 d1 19 00
	00 00		 mov	 BYTE PTR ?computerMove@@3UPossibleMove@@A[ecx+edx*8+25], al

; 163  :       computerMove.con.m_coinsRemaining -= 1;

  00250	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?computerMove@@3UPossibleMove@@A+12
  00255	83 e8 01	 sub	 eax, 1
  00258	a3 0c 00 00 00	 mov	 DWORD PTR ?computerMove@@3UPossibleMove@@A+12, eax
$LN13@Capture:

; 164  :     };
; 165  :     computerMove.con.Canon(0,computerMove.con.m_numNode);

  0025d	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?computerMove@@3UPossibleMove@@A+8
  00263	51		 push	 ecx
  00264	6a 00		 push	 0
  00266	b9 08 00 00 00	 mov	 ecx, OFFSET ?computerMove@@3UPossibleMove@@A+8
  0026b	e8 00 00 00 00	 call	 ?Canon@CON@@QAEXHH@Z	; CON::Canon

; 166  : #ifdef _CHECK
; 167  :     computerMove.con.CheckEverything(0,computerMove.con.m_numNode,false);
; 168  :     return;
; 169  : #endif
; 170  :   }

  00270	eb 0d		 jmp	 SHORT $LN1@Capture
$LN10@Capture:

; 171  :   else
; 172  :   {
; 173  :     ImplementationError("Unknown capture type");

  00272	68 00 00 00 00	 push	 OFFSET $SG225452
  00277	e8 00 00 00 00	 call	 ?ImplementationError@@YAXPBD@Z ; ImplementationError
  0027c	83 c4 04	 add	 esp, 4
$LN1@Capture:

; 174  :   };
; 175  : }

  0027f	83 c4 04	 add	 esp, 4
  00282	3b ec		 cmp	 ebp, esp
  00284	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00289	8b e5		 mov	 esp, ebp
  0028b	5d		 pop	 ebp
  0028c	c2 08 00	 ret	 8
?Capture@CON@@QAEXHH@Z ENDP				; CON::Capture
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\NIMCON.h
;	COMDAT ??8EDGEDATA@@QBE_NABU0@@Z
_TEXT	SEGMENT
tv65 = -16						; size = 4
tv70 = -12						; size = 4
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_ed$ = 8						; size = 4
??8EDGEDATA@@QBE_NABU0@@Z PROC				; EDGEDATA::operator==, COMDAT
; _this$ = ecx

; 168  :   {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 169  :     return *((ui64 *)(this)) == *((ui64 *)(&ed));

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _ed$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  00012	89 4d f4	 mov	 DWORD PTR tv70[ebp], ecx
  00015	8b 55 f8	 mov	 edx, DWORD PTR tv69[ebp]
  00018	8b 45 f4	 mov	 eax, DWORD PTR tv70[ebp]
  0001b	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0001d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0001f	75 17		 jne	 SHORT $LN3@operator
  00021	8b 55 f8	 mov	 edx, DWORD PTR tv69[ebp]
  00024	8b 45 f4	 mov	 eax, DWORD PTR tv70[ebp]
  00027	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0002a	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0002d	75 09		 jne	 SHORT $LN3@operator
  0002f	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
  00036	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00038	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv65[ebp], 0
$LN4@operator:
  0003f	0f b6 45 f0	 movzx	 eax, BYTE PTR tv65[ebp]

; 170  :   };

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
??8EDGEDATA@@QBE_NABU0@@Z ENDP				; EDGEDATA::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\NIMCON.h
;	COMDAT ??8EDGE@@QBE_NABU0@@Z
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
_e$ = 8							; size = 4
??8EDGE@@QBE_NABU0@@Z PROC				; EDGE::operator==, COMDAT
; _this$ = ecx

; 149  :   {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 150  :     return *((ui16 *)(this)) == *((ui16 *)(&e));

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0000f	8b 55 08	 mov	 edx, DWORD PTR _e$[ebp]
  00012	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00015	3b c8		 cmp	 ecx, eax
  00017	75 09		 jne	 SHORT $LN3@operator
  00019	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  00020	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00022	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN4@operator:
  00029	0f b6 45 f8	 movzx	 eax, BYTE PTR tv67[ebp]

; 151  :   };

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??8EDGE@@QBE_NABU0@@Z ENDP				; EDGE::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File G:\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\atlmfc\include\afx.h
;	COMDAT ?AfxAssertFailedLine@@YGHPBDH@Z
_TEXT	SEGMENT
_bResult$ = -44						; size = 4
_bQuit$ = -40						; size = 4
_msg$ = -32						; size = 28
_lpszFileName$ = 8					; size = 4
_nLine$ = 12						; size = 4
?AfxAssertFailedLine@@YGHPBDH@Z PROC			; AfxAssertFailedLine, COMDAT

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d d4	 lea	 edi, DWORD PTR [ebp-44]
  0000b	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd

; 313  : 	// we remove WM_QUIT because if it is in the queue then the message box
; 314  : 	// won't display
; 315  : 	MSG msg;
; 316  : 	BOOL bQuit = PeekMessage(&msg, NULL, WM_QUIT, WM_QUIT, PM_REMOVE);

  00017	8b f4		 mov	 esi, esp
  00019	6a 01		 push	 1
  0001b	6a 12		 push	 18			; 00000012H
  0001d	6a 12		 push	 18			; 00000012H
  0001f	6a 00		 push	 0
  00021	8d 45 e0	 lea	 eax, DWORD PTR _msg$[ebp]
  00024	50		 push	 eax
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PeekMessageA@20
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00032	89 45 d8	 mov	 DWORD PTR _bQuit$[ebp], eax

; 317  : 	BOOL bResult = _CrtDbgReport(_CRT_ASSERT, lpszFileName, nLine, NULL, NULL);

  00035	8b f4		 mov	 esi, esp
  00037	6a 00		 push	 0
  00039	6a 00		 push	 0
  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _nLine$[ebp]
  0003e	51		 push	 ecx
  0003f	8b 55 08	 mov	 edx, DWORD PTR _lpszFileName$[ebp]
  00042	52		 push	 edx
  00043	6a 02		 push	 2
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0004b	83 c4 14	 add	 esp, 20			; 00000014H
  0004e	3b f4		 cmp	 esi, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	89 45 d4	 mov	 DWORD PTR _bResult$[ebp], eax

; 318  : 	if (bQuit)

  00058	83 7d d8 00	 cmp	 DWORD PTR _bQuit$[ebp], 0
  0005c	74 13		 je	 SHORT $LN2@AfxAssertF

; 319  : 		PostQuitMessage((int)msg.wParam);

  0005e	8b f4		 mov	 esi, esp
  00060	8b 45 e8	 mov	 eax, DWORD PTR _msg$[ebp+8]
  00063	50		 push	 eax
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4
  0006a	3b f4		 cmp	 esi, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@AfxAssertF:

; 320  : 	return bResult;

  00071	8b 45 d4	 mov	 eax, DWORD PTR _bResult$[ebp]

; 321  : }

  00074	52		 push	 edx
  00075	8b cd		 mov	 ecx, ebp
  00077	50		 push	 eax
  00078	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@AfxAssertF
  0007e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00083	58		 pop	 eax
  00084	5a		 pop	 edx
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	83 c4 2c	 add	 esp, 44			; 0000002cH
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 08 00	 ret	 8
  00097	90		 npad	 1
$LN6@AfxAssertF:
  00098	01 00 00 00	 DD	 1
  0009c	00 00 00 00	 DD	 $LN5@AfxAssertF
$LN5@AfxAssertF:
  000a0	e0 ff ff ff	 DD	 -32			; ffffffe0H
  000a4	1c 00 00 00	 DD	 28			; 0000001cH
  000a8	00 00 00 00	 DD	 $LN4@AfxAssertF
$LN4@AfxAssertF:
  000ac	6d		 DB	 109			; 0000006dH
  000ad	73		 DB	 115			; 00000073H
  000ae	67		 DB	 103			; 00000067H
  000af	00		 DB	 0
?AfxAssertFailedLine@@YGHPBDH@Z ENDP			; AfxAssertFailedLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\SWEvaluate.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\SWEvaluate.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
