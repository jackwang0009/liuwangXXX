; Listing generated by Microsoft (R) Optimizing Compiler Version 19.35.32217.1 

	TITLE	C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\Debug\Hash.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?nimExistsCalls@@3HA				; nimExistsCalls
PUBLIC	?nimExistsTrue@@3HA				; nimExistsTrue
PUBLIC	?totalNimHashEntries@@3HA			; totalNimHashEntries
PUBLIC	?nimHashCacheCrash@@3HA				; nimHashCacheCrash
PUBLIC	?pointsExistsCalls@@3HA				; pointsExistsCalls
PUBLIC	?pointsExistsTrue@@3HA				; pointsExistsTrue
PUBLIC	?totalPointsCacheEntries@@3HA			; totalPointsCacheEntries
PUBLIC	?pointsHashCacheCrash@@3HA			; pointsHashCacheCrash
PUBLIC	?pointsCacheUpdate@@3HA				; pointsCacheUpdate
PUBLIC	?cdExistsCalls@@3HA				; cdExistsCalls
PUBLIC	?cdExistsTrue@@3HA				; cdExistsTrue
PUBLIC	?totalcdCacheEntries@@3HA			; totalcdCacheEntries
PUBLIC	?cdHashCacheCrash@@3HA				; cdHashCacheCrash
PUBLIC	?cdCacheUpdate@@3HA				; cdCacheUpdate
_BSS	SEGMENT
?nimExistsCalls@@3HA DD 01H DUP (?)			; nimExistsCalls
?nimExistsTrue@@3HA DD 01H DUP (?)			; nimExistsTrue
?totalNimHashEntries@@3HA DD 01H DUP (?)		; totalNimHashEntries
?nimHashCacheCrash@@3HA DD 01H DUP (?)			; nimHashCacheCrash
?pointsExistsCalls@@3HA DD 01H DUP (?)			; pointsExistsCalls
?pointsExistsTrue@@3HA DD 01H DUP (?)			; pointsExistsTrue
?totalPointsCacheEntries@@3HA DD 01H DUP (?)		; totalPointsCacheEntries
?pointsHashCacheCrash@@3HA DD 01H DUP (?)		; pointsHashCacheCrash
?pointsCacheUpdate@@3HA DD 01H DUP (?)			; pointsCacheUpdate
?cdExistsCalls@@3HA DD 01H DUP (?)			; cdExistsCalls
?cdExistsTrue@@3HA DD 01H DUP (?)			; cdExistsTrue
?totalcdCacheEntries@@3HA DD 01H DUP (?)		; totalcdCacheEntries
?cdHashCacheCrash@@3HA DD 01H DUP (?)			; cdHashCacheCrash
?cdCacheUpdate@@3HA DD 01H DUP (?)			; cdCacheUpdate
_BSS	ENDS
CONST	SEGMENT
$SG225430 DB	'Cannot allocate hash table', 00H
	ORG $+1
$SG225489 DB	'Cannot allocate nim hash table', 00H
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0SWHASHTABLE@@QAE@XZ				; SWHASHTABLE::SWHASHTABLE
PUBLIC	??1SWHASHTABLE@@QAE@XZ				; SWHASHTABLE::~SWHASHTABLE
PUBLIC	?Exists@SWHASHTABLE@@QAEH_K@Z			; SWHASHTABLE::Exists
PUBLIC	?Value@SWHASHTABLE@@QAEXHPAUSWVALUE@@@Z		; SWHASHTABLE::Value
PUBLIC	?EnterValue@SWHASHTABLE@@QAEX_KPAUSWVALUE@@@Z	; SWHASHTABLE::EnterValue
PUBLIC	?UpdateValue@SWHASHTABLE@@QAEXI_KPAUSWVALUE@@@Z	; SWHASHTABLE::UpdateValue
PUBLIC	??0NIMHASHTABLE@@QAE@XZ				; NIMHASHTABLE::NIMHASHTABLE
PUBLIC	??1NIMHASHTABLE@@QAE@XZ				; NIMHASHTABLE::~NIMHASHTABLE
PUBLIC	?Exists@NIMHASHTABLE@@QAEH_K@Z			; NIMHASHTABLE::Exists
PUBLIC	?EnterValue@NIMHASHTABLE@@QAEX_KE@Z		; NIMHASHTABLE::EnterValue
EXTRN	_memset:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	?die@@YAXPBD@Z:PROC				; die
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__aullrem:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Hash.cpp
_TEXT	SEGMENT
tv156 = -32						; size = 4
tv155 = -28						; size = 4
tv145 = -24						; size = 4
tv144 = -20						; size = 4
_index$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_hash$ = 8						; size = 8
_value$ = 16						; size = 1
?EnterValue@NIMHASHTABLE@@QAEX_KE@Z PROC		; NIMHASHTABLE::EnterValue
; _this$ = ecx

; 206  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0000f	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00012	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00015	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00018	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001b	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001e	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00021	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00024	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 207  :   int i, j, index;
; 208  :   i = index = (int)(hash%NIMHASHSIZE);

  00027	6a 00		 push	 0
  00029	68 13 5e 2d 00	 push	 2973203			; 002d5e13H
  0002e	8b 45 0c	 mov	 eax, DWORD PTR _hash$[ebp+4]
  00031	50		 push	 eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _hash$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 __aullrem
  0003b	89 45 f0	 mov	 DWORD PTR _index$[ebp], eax
  0003e	8b 55 f0	 mov	 edx, DWORD PTR _index$[ebp]
  00041	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx

; 209  :   j = 0;

  00044	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
$LN2@EnterValue:

; 210  :   while (hashId[i]!=0)

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00050	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00053	89 4d ec	 mov	 DWORD PTR tv144[ebp], ecx
  00056	89 55 e8	 mov	 DWORD PTR tv145[ebp], edx
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv145[ebp]
  0005c	8b 4d ec	 mov	 ecx, DWORD PTR tv144[ebp]
  0005f	8b 55 e8	 mov	 edx, DWORD PTR tv145[ebp]
  00062	8b 75 ec	 mov	 esi, DWORD PTR tv144[ebp]
  00065	8b 04 c1	 mov	 eax, DWORD PTR [ecx+eax*8]
  00068	0b 44 d6 04	 or	 eax, DWORD PTR [esi+edx*8+4]
  0006c	0f 84 9d 00 00
	00		 je	 $LN3@EnterValue

; 211  :   {
; 212  :     if (hashId[i] == hash) 

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	8b 11		 mov	 edx, DWORD PTR [ecx]
  00077	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0007a	89 55 e4	 mov	 DWORD PTR tv155[ebp], edx
  0007d	89 45 e0	 mov	 DWORD PTR tv156[ebp], eax
  00080	8b 4d e0	 mov	 ecx, DWORD PTR tv156[ebp]
  00083	8b 55 e4	 mov	 edx, DWORD PTR tv155[ebp]
  00086	8b 04 ca	 mov	 eax, DWORD PTR [edx+ecx*8]
  00089	3b 45 08	 cmp	 eax, DWORD PTR _hash$[ebp]
  0008c	75 20		 jne	 SHORT $LN4@EnterValue
  0008e	8b 4d e0	 mov	 ecx, DWORD PTR tv156[ebp]
  00091	8b 55 e4	 mov	 edx, DWORD PTR tv155[ebp]
  00094	8b 44 ca 04	 mov	 eax, DWORD PTR [edx+ecx*8+4]
  00098	3b 45 0c	 cmp	 eax, DWORD PTR _hash$[ebp+4]
  0009b	75 11		 jne	 SHORT $LN4@EnterValue

; 213  :     {
; 214  : #ifdef HASHSTATS
; 215  :       totalNimHashEntries--;

  0009d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?totalNimHashEntries@@3HA ; totalNimHashEntries
  000a3	83 e9 01	 sub	 ecx, 1
  000a6	89 0d 00 00 00
	00		 mov	 DWORD PTR ?totalNimHashEntries@@3HA, ecx ; totalNimHashEntries

; 216  : #endif
; 217  :       break;

  000ac	eb 61		 jmp	 SHORT $LN3@EnterValue
$LN4@EnterValue:

; 218  :     };
; 219  :     i += ((int)hash & 0xff) + 1; 

  000ae	8b 55 08	 mov	 edx, DWORD PTR _hash$[ebp]
  000b1	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000b7	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ba	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  000be	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx

; 220  :     j++;

  000c1	8b 55 f4	 mov	 edx, DWORD PTR _j$[ebp]
  000c4	83 c2 01	 add	 edx, 1
  000c7	89 55 f4	 mov	 DWORD PTR _j$[ebp], edx

; 221  :     if (j == NIM_MAX_HASH_OFFSET) 

  000ca	83 7d f4 0a	 cmp	 DWORD PTR _j$[ebp], 10	; 0000000aH
  000ce	75 26		 jne	 SHORT $LN5@EnterValue

; 222  :     {
; 223  :       i=index;

  000d0	8b 45 f0	 mov	 eax, DWORD PTR _index$[ebp]
  000d3	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 224  : #ifdef HASHSTATS
; 225  :       totalNimHashEntries--;

  000d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?totalNimHashEntries@@3HA ; totalNimHashEntries
  000dc	83 e9 01	 sub	 ecx, 1
  000df	89 0d 00 00 00
	00		 mov	 DWORD PTR ?totalNimHashEntries@@3HA, ecx ; totalNimHashEntries

; 226  :       nimHashCacheCrash++;

  000e5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?nimHashCacheCrash@@3HA ; nimHashCacheCrash
  000eb	83 c2 01	 add	 edx, 1
  000ee	89 15 00 00 00
	00		 mov	 DWORD PTR ?nimHashCacheCrash@@3HA, edx ; nimHashCacheCrash

; 227  : #endif
; 228  :       break;

  000f4	eb 19		 jmp	 SHORT $LN3@EnterValue
$LN5@EnterValue:

; 229  :     };
; 230  :     if (i >= NIMHASHSIZE) i -= NIMHASHSIZE;

  000f6	81 7d f8 13 5e
	2d 00		 cmp	 DWORD PTR _i$[ebp], 2973203 ; 002d5e13H
  000fd	7c 0b		 jl	 SHORT $LN6@EnterValue
  000ff	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00102	2d 13 5e 2d 00	 sub	 eax, 2973203		; 002d5e13H
  00107	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN6@EnterValue:

; 231  :   };

  0010a	e9 3c ff ff ff	 jmp	 $LN2@EnterValue
$LN3@EnterValue:

; 232  : #ifdef HASHSTATS
; 233  :       totalNimHashEntries++;

  0010f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?totalNimHashEntries@@3HA ; totalNimHashEntries
  00115	83 c1 01	 add	 ecx, 1
  00118	89 0d 00 00 00
	00		 mov	 DWORD PTR ?totalNimHashEntries@@3HA, ecx ; totalNimHashEntries

; 234  : #endif
; 235  :   hashId[i] = hash;

  0011e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00121	8b 02		 mov	 eax, DWORD PTR [edx]
  00123	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00126	8b 55 08	 mov	 edx, DWORD PTR _hash$[ebp]
  00129	8b 75 0c	 mov	 esi, DWORD PTR _hash$[ebp+4]
  0012c	89 14 c8	 mov	 DWORD PTR [eax+ecx*8], edx
  0012f	89 74 c8 04	 mov	 DWORD PTR [eax+ecx*8+4], esi

; 236  :   values[i] = value;

  00133	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00136	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00139	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0013c	0f b6 45 10	 movzx	 eax, BYTE PTR _value$[ebp]
  00140	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 237  : }

  00143	5e		 pop	 esi
  00144	83 c4 20	 add	 esp, 32			; 00000020H
  00147	3b ec		 cmp	 ebp, esp
  00149	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c2 0c 00	 ret	 12			; 0000000cH
?EnterValue@NIMHASHTABLE@@QAEX_KE@Z ENDP		; NIMHASHTABLE::EnterValue
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Hash.cpp
_TEXT	SEGMENT
tv147 = -28						; size = 4
tv146 = -24						; size = 4
tv136 = -20						; size = 4
tv135 = -16						; size = 4
_index$ = -12						; size = 4
_j$ = -8						; size = 4
_this$ = -4						; size = 4
_hash$ = 8						; size = 8
?Exists@NIMHASHTABLE@@QAEH_K@Z PROC			; NIMHASHTABLE::Exists
; _this$ = ecx

; 174  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000f	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00012	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00015	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00018	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001b	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001e	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00021	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 175  :   int j, index;
; 176  :   index = (int)(hash%NIMHASHSIZE); 

  00024	6a 00		 push	 0
  00026	68 13 5e 2d 00	 push	 2973203			; 002d5e13H
  0002b	8b 45 0c	 mov	 eax, DWORD PTR _hash$[ebp+4]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _hash$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 __aullrem
  00038	89 45 f4	 mov	 DWORD PTR _index$[ebp], eax

; 177  :   j = 0;

  0003b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
$LN2@Exists:

; 178  :   while (hashId[index]!=0)

  00042	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00045	8b 02		 mov	 eax, DWORD PTR [edx]
  00047	8b 4d f4	 mov	 ecx, DWORD PTR _index$[ebp]
  0004a	89 45 f0	 mov	 DWORD PTR tv135[ebp], eax
  0004d	89 4d ec	 mov	 DWORD PTR tv136[ebp], ecx
  00050	8b 55 ec	 mov	 edx, DWORD PTR tv136[ebp]
  00053	8b 45 f0	 mov	 eax, DWORD PTR tv135[ebp]
  00056	8b 4d ec	 mov	 ecx, DWORD PTR tv136[ebp]
  00059	8b 75 f0	 mov	 esi, DWORD PTR tv135[ebp]
  0005c	8b 14 d0	 mov	 edx, DWORD PTR [eax+edx*8]
  0005f	0b 54 ce 04	 or	 edx, DWORD PTR [esi+ecx*8+4]
  00063	0f 84 9a 00 00
	00		 je	 $LN3@Exists

; 179  :   {
; 180  :     if (hashId[index] == hash)

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006e	8b 55 f4	 mov	 edx, DWORD PTR _index$[ebp]
  00071	89 4d e8	 mov	 DWORD PTR tv146[ebp], ecx
  00074	89 55 e4	 mov	 DWORD PTR tv147[ebp], edx
  00077	8b 45 e4	 mov	 eax, DWORD PTR tv147[ebp]
  0007a	8b 4d e8	 mov	 ecx, DWORD PTR tv146[ebp]
  0007d	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  00080	3b 55 08	 cmp	 edx, DWORD PTR _hash$[ebp]
  00083	75 30		 jne	 SHORT $LN4@Exists
  00085	8b 45 e4	 mov	 eax, DWORD PTR tv147[ebp]
  00088	8b 4d e8	 mov	 ecx, DWORD PTR tv146[ebp]
  0008b	8b 54 c1 04	 mov	 edx, DWORD PTR [ecx+eax*8+4]
  0008f	3b 55 0c	 cmp	 edx, DWORD PTR _hash$[ebp+4]
  00092	75 21		 jne	 SHORT $LN4@Exists

; 181  :     {
; 182  : #ifdef HASHSTATS
; 183  :       nimExistsCalls++;

  00094	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nimExistsCalls@@3HA ; nimExistsCalls
  00099	83 c0 01	 add	 eax, 1
  0009c	a3 00 00 00 00	 mov	 DWORD PTR ?nimExistsCalls@@3HA, eax ; nimExistsCalls

; 184  :       nimExistsTrue++;

  000a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?nimExistsTrue@@3HA ; nimExistsTrue
  000a7	83 c1 01	 add	 ecx, 1
  000aa	89 0d 00 00 00
	00		 mov	 DWORD PTR ?nimExistsTrue@@3HA, ecx ; nimExistsTrue

; 185  : #endif
; 186  :       return index;

  000b0	8b 45 f4	 mov	 eax, DWORD PTR _index$[ebp]
  000b3	eb 60		 jmp	 SHORT $LN1@Exists
$LN4@Exists:

; 187  :     };
; 188  :     index += ((int)hash & 0xff) + 1;

  000b5	8b 55 08	 mov	 edx, DWORD PTR _hash$[ebp]
  000b8	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000be	8b 45 f4	 mov	 eax, DWORD PTR _index$[ebp]
  000c1	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  000c5	89 4d f4	 mov	 DWORD PTR _index$[ebp], ecx

; 189  :     j++;

  000c8	8b 55 f8	 mov	 edx, DWORD PTR _j$[ebp]
  000cb	83 c2 01	 add	 edx, 1
  000ce	89 55 f8	 mov	 DWORD PTR _j$[ebp], edx

; 190  :     if (j == NIM_MAX_HASH_OFFSET)

  000d1	83 7d f8 0a	 cmp	 DWORD PTR _j$[ebp], 10	; 0000000aH
  000d5	75 12		 jne	 SHORT $LN5@Exists

; 191  :     {
; 192  : #ifdef HASHSTATS
; 193  :       nimExistsCalls++;

  000d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nimExistsCalls@@3HA ; nimExistsCalls
  000dc	83 c0 01	 add	 eax, 1
  000df	a3 00 00 00 00	 mov	 DWORD PTR ?nimExistsCalls@@3HA, eax ; nimExistsCalls

; 194  : #endif
; 195  :       return -1;

  000e4	83 c8 ff	 or	 eax, -1
  000e7	eb 2c		 jmp	 SHORT $LN1@Exists
$LN5@Exists:

; 196  :     };
; 197  :     if (index >= NIMHASHSIZE) index -= NIMHASHSIZE;

  000e9	81 7d f4 13 5e
	2d 00		 cmp	 DWORD PTR _index$[ebp], 2973203 ; 002d5e13H
  000f0	7c 0c		 jl	 SHORT $LN6@Exists
  000f2	8b 4d f4	 mov	 ecx, DWORD PTR _index$[ebp]
  000f5	81 e9 13 5e 2d
	00		 sub	 ecx, 2973203		; 002d5e13H
  000fb	89 4d f4	 mov	 DWORD PTR _index$[ebp], ecx
$LN6@Exists:

; 198  :   };

  000fe	e9 3f ff ff ff	 jmp	 $LN2@Exists
$LN3@Exists:

; 199  : #ifdef HASHSTATS
; 200  :       nimExistsCalls++;

  00103	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?nimExistsCalls@@3HA ; nimExistsCalls
  00109	83 c2 01	 add	 edx, 1
  0010c	89 15 00 00 00
	00		 mov	 DWORD PTR ?nimExistsCalls@@3HA, edx ; nimExistsCalls

; 201  : #endif
; 202  :   return -1;

  00112	83 c8 ff	 or	 eax, -1
$LN1@Exists:

; 203  : }

  00115	5e		 pop	 esi
  00116	83 c4 1c	 add	 esp, 28			; 0000001cH
  00119	3b ec		 cmp	 ebp, esp
  0011b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c2 08 00	 ret	 8
?Exists@NIMHASHTABLE@@QAEH_K@Z ENDP			; NIMHASHTABLE::Exists
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Hash.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1NIMHASHTABLE@@QAE@XZ PROC				; NIMHASHTABLE::~NIMHASHTABLE
; _this$ = ecx

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  :   if (hashId != NULL) free(hashId);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 38 00	 cmp	 DWORD PTR [eax], 0
  00015	74 18		 je	 SHORT $LN2@NIMHASHTAB
  00017	8b f4		 mov	 esi, esp
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001e	52		 push	 edx
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00025	83 c4 04	 add	 esp, 4
  00028	3b f4		 cmp	 esi, esp
  0002a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@NIMHASHTAB:

; 167  :   hashId = NULL;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 168  :   if (values != NULL) free(values);

  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0003f	74 19		 je	 SHORT $LN3@NIMHASHTAB
  00041	8b f4		 mov	 esi, esp
  00043	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00046	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00049	50		 push	 eax
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00050	83 c4 04	 add	 esp, 4
  00053	3b f4		 cmp	 esi, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@NIMHASHTAB:

; 169  :   values = NULL;

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 170  : }

  00064	5e		 pop	 esi
  00065	83 c4 04	 add	 esp, 4
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
??1NIMHASHTABLE@@QAE@XZ ENDP				; NIMHASHTABLE::~NIMHASHTABLE
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Hash.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0NIMHASHTABLE@@QAE@XZ PROC				; NIMHASHTABLE::NIMHASHTABLE
; _this$ = ecx

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : #ifdef HASHSTATS
; 148  :   totalNimHashEntries = 0;

  0000f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?totalNimHashEntries@@3HA, 0 ; totalNimHashEntries

; 149  :   nimExistsCalls = 0;

  00019	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?nimExistsCalls@@3HA, 0 ; nimExistsCalls

; 150  :   nimExistsTrue = 0;

  00023	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?nimExistsTrue@@3HA, 0 ; nimExistsTrue

; 151  :   nimHashCacheCrash = 0;

  0002d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?nimHashCacheCrash@@3HA, 0 ; nimHashCacheCrash

; 152  : #endif
; 153  :   hashId = (ui64 *)malloc(NIMHASHSIZE * sizeof (hashId[0]));

  00037	8b f4		 mov	 esi, esp
  00039	68 98 f0 6a 01	 push	 23785624		; 016af098H
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00044	83 c4 04	 add	 esp, 4
  00047	3b f4		 cmp	 esi, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	89 01		 mov	 DWORD PTR [ecx], eax

; 154  :   values = (NIMHASHVALUE *)malloc(NIMHASHSIZE * sizeof (values[0]));

  00053	8b f4		 mov	 esi, esp
  00055	68 13 5e 2d 00	 push	 2973203			; 002d5e13H
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00060	83 c4 04	 add	 esp, 4
  00063	3b f4		 cmp	 esi, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 155  :   if ( (hashId == NULL) || (values == NULL) )

  00070	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00073	83 38 00	 cmp	 DWORD PTR [eax], 0
  00076	74 09		 je	 SHORT $LN3@NIMHASHTAB
  00078	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0007f	75 0f		 jne	 SHORT $LN2@NIMHASHTAB
$LN3@NIMHASHTAB:

; 156  :   {
; 157  :     die("Cannot allocate nim hash table");

  00081	68 00 00 00 00	 push	 OFFSET $SG225489
  00086	e8 00 00 00 00	 call	 ?die@@YAXPBD@Z		; die
  0008b	83 c4 04	 add	 esp, 4

; 158  :     return;

  0008e	eb 1f		 jmp	 SHORT $LN1@NIMHASHTAB
$LN2@NIMHASHTAB:

; 159  :   };
; 160  :   memset(hashId, 0, NIMHASHSIZE*sizeof(hashId[0]));

  00090	68 98 f0 6a 01	 push	 23785624		; 016af098H
  00095	6a 00		 push	 0
  00097	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009a	8b 02		 mov	 eax, DWORD PTR [edx]
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 _memset
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  :   numEnt = 0;

  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
$LN1@NIMHASHTAB:

; 162  : }

  000af	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b2	5e		 pop	 esi
  000b3	83 c4 04	 add	 esp, 4
  000b6	3b ec		 cmp	 ebp, esp
  000b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
??0NIMHASHTABLE@@QAE@XZ ENDP				; NIMHASHTABLE::NIMHASHTABLE
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Hash.cpp
_TEXT	SEGMENT
tv166 = -12						; size = 4
tv165 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
_hash$ = 12						; size = 8
_value$ = 20						; size = 4
?UpdateValue@SWHASHTABLE@@QAEXI_KPAUSWVALUE@@@Z PROC	; SWHASHTABLE::UpdateValue
; _this$ = ecx

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  :   if (hashId[index] != hash)

  0000a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	8b 55 08	 mov	 edx, DWORD PTR _index$[ebp]
  00012	89 4d f8	 mov	 DWORD PTR tv165[ebp], ecx
  00015	89 55 f4	 mov	 DWORD PTR tv166[ebp], edx
  00018	8b 45 f4	 mov	 eax, DWORD PTR tv166[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR tv165[ebp]
  0001e	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  00021	3b 55 0c	 cmp	 edx, DWORD PTR _hash$[ebp]
  00024	75 0f		 jne	 SHORT $LN8@UpdateValu
  00026	8b 45 f4	 mov	 eax, DWORD PTR tv166[ebp]
  00029	8b 4d f8	 mov	 ecx, DWORD PTR tv165[ebp]
  0002c	8b 54 c1 04	 mov	 edx, DWORD PTR [ecx+eax*8+4]
  00030	3b 55 10	 cmp	 edx, DWORD PTR _hash$[ebp+4]
  00033	74 42		 je	 SHORT $LN2@UpdateValu
$LN8@UpdateValu:

; 117  :   {
; 118  :     hashId[index] = hash;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	8b 55 08	 mov	 edx, DWORD PTR _index$[ebp]
  0003d	8b 45 0c	 mov	 eax, DWORD PTR _hash$[ebp]
  00040	8b 75 10	 mov	 esi, DWORD PTR _hash$[ebp+4]
  00043	89 04 d1	 mov	 DWORD PTR [ecx+edx*8], eax
  00046	89 74 d1 04	 mov	 DWORD PTR [ecx+edx*8+4], esi

; 119  :     valuePairs[index].player1min = value->player1Min;

  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00050	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00053	8b 4d 14	 mov	 ecx, DWORD PTR _value$[ebp]
  00056	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00059	66 89 0c 82	 mov	 WORD PTR [edx+eax*4], cx

; 120  :     valuePairs[index].player2min = value->player2Min;

  0005d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00060	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00063	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  00066	8b 55 14	 mov	 edx, DWORD PTR _value$[ebp]
  00069	66 8b 52 02	 mov	 dx, WORD PTR [edx+2]
  0006d	66 89 54 88 02	 mov	 WORD PTR [eax+ecx*4+2], dx

; 121  :     return;

  00072	e9 95 00 00 00	 jmp	 $LN1@UpdateValu
$LN2@UpdateValu:

; 122  :   };
; 123  :   if (value->player1Min > valuePairs[index].player1min)

  00077	8b 45 14	 mov	 eax, DWORD PTR _value$[ebp]
  0007a	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0007d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00080	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00083	8b 55 08	 mov	 edx, DWORD PTR _index$[ebp]
  00086	0f b7 04 90	 movzx	 eax, WORD PTR [eax+edx*4]
  0008a	3b c8		 cmp	 ecx, eax
  0008c	7e 43		 jle	 SHORT $LN3@UpdateValu

; 124  :   {
; 125  :     valuePairs[index].player1min = value->player1Min;

  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00094	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00097	8b 4d 14	 mov	 ecx, DWORD PTR _value$[ebp]
  0009a	66 8b 09	 mov	 cx, WORD PTR [ecx]
  0009d	66 89 0c 82	 mov	 WORD PTR [edx+eax*4], cx

; 126  :     if (value->player2Min > valuePairs[index].player2min)

  000a1	8b 55 14	 mov	 edx, DWORD PTR _value$[ebp]
  000a4	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ae	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  000b1	0f b7 54 8a 02	 movzx	 edx, WORD PTR [edx+ecx*4+2]
  000b6	3b c2		 cmp	 eax, edx
  000b8	7e 15		 jle	 SHORT $LN5@UpdateValu

; 127  :     {
; 128  :       valuePairs[index].player2min = value->player2Min;

  000ba	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c0	8b 55 08	 mov	 edx, DWORD PTR _index$[ebp]
  000c3	8b 45 14	 mov	 eax, DWORD PTR _value$[ebp]
  000c6	66 8b 40 02	 mov	 ax, WORD PTR [eax+2]
  000ca	66 89 44 91 02	 mov	 WORD PTR [ecx+edx*4+2], ax
$LN5@UpdateValu:

; 129  :     };
; 130  :   }

  000cf	eb 3b		 jmp	 SHORT $LN1@UpdateValu
$LN3@UpdateValu:

; 131  :   else
; 132  :   {
; 133  :     if (value->player2Min > valuePairs[index].player2min)

  000d1	8b 4d 14	 mov	 ecx, DWORD PTR _value$[ebp]
  000d4	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  000d8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000db	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000de	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  000e1	0f b7 4c 81 02	 movzx	 ecx, WORD PTR [ecx+eax*4+2]
  000e6	3b d1		 cmp	 edx, ecx
  000e8	7e 15		 jle	 SHORT $LN6@UpdateValu

; 134  :     {
; 135  :       valuePairs[index].player2min = value->player2Min;

  000ea	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ed	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000f0	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  000f3	8b 55 14	 mov	 edx, DWORD PTR _value$[ebp]
  000f6	66 8b 52 02	 mov	 dx, WORD PTR [edx+2]
  000fa	66 89 54 88 02	 mov	 WORD PTR [eax+ecx*4+2], dx
$LN6@UpdateValu:

; 136  :     };
; 137  : #ifdef HASHSTATS
; 138  :     pointsCacheUpdate++;

  000ff	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pointsCacheUpdate@@3HA ; pointsCacheUpdate
  00104	83 c0 01	 add	 eax, 1
  00107	a3 00 00 00 00	 mov	 DWORD PTR ?pointsCacheUpdate@@3HA, eax ; pointsCacheUpdate
$LN1@UpdateValu:

; 139  : #endif
; 140  :   };
; 141  : }

  0010c	5e		 pop	 esi
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c2 10 00	 ret	 16			; 00000010H
?UpdateValue@SWHASHTABLE@@QAEXI_KPAUSWVALUE@@@Z ENDP	; SWHASHTABLE::UpdateValue
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Hash.cpp
_TEXT	SEGMENT
tv163 = -32						; size = 4
tv162 = -28						; size = 4
tv152 = -24						; size = 4
tv151 = -20						; size = 4
_index$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_hash$ = 8						; size = 8
_value$ = 16						; size = 4
?EnterValue@SWHASHTABLE@@QAEX_KPAUSWVALUE@@@Z PROC	; SWHASHTABLE::EnterValue
; _this$ = ecx

; 86   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0000f	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00012	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00015	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00018	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001b	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001e	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00021	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00024	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 87   :   int i, j, index;
; 88   :   i = index = (int)(hash%SWHASHSIZE);

  00027	6a 00		 push	 0
  00029	68 17 5e 2d 00	 push	 2973207			; 002d5e17H
  0002e	8b 45 0c	 mov	 eax, DWORD PTR _hash$[ebp+4]
  00031	50		 push	 eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _hash$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 __aullrem
  0003b	89 45 f0	 mov	 DWORD PTR _index$[ebp], eax
  0003e	8b 55 f0	 mov	 edx, DWORD PTR _index$[ebp]
  00041	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx

; 89   :   j = 0;

  00044	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
$LN2@EnterValue:

; 90   :   while (hashId[i]!=0)

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00050	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00053	89 4d ec	 mov	 DWORD PTR tv151[ebp], ecx
  00056	89 55 e8	 mov	 DWORD PTR tv152[ebp], edx
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv152[ebp]
  0005c	8b 4d ec	 mov	 ecx, DWORD PTR tv151[ebp]
  0005f	8b 55 e8	 mov	 edx, DWORD PTR tv152[ebp]
  00062	8b 75 ec	 mov	 esi, DWORD PTR tv151[ebp]
  00065	8b 04 c1	 mov	 eax, DWORD PTR [ecx+eax*8]
  00068	0b 44 d6 04	 or	 eax, DWORD PTR [esi+edx*8+4]
  0006c	0f 84 8d 00 00
	00		 je	 $LN3@EnterValue

; 91   :   {
; 92   :     if (hashId[i] == hash) break;

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	8b 11		 mov	 edx, DWORD PTR [ecx]
  00077	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0007a	89 55 e4	 mov	 DWORD PTR tv162[ebp], edx
  0007d	89 45 e0	 mov	 DWORD PTR tv163[ebp], eax
  00080	8b 4d e0	 mov	 ecx, DWORD PTR tv163[ebp]
  00083	8b 55 e4	 mov	 edx, DWORD PTR tv162[ebp]
  00086	8b 04 ca	 mov	 eax, DWORD PTR [edx+ecx*8]
  00089	3b 45 08	 cmp	 eax, DWORD PTR _hash$[ebp]
  0008c	75 11		 jne	 SHORT $LN4@EnterValue
  0008e	8b 4d e0	 mov	 ecx, DWORD PTR tv163[ebp]
  00091	8b 55 e4	 mov	 edx, DWORD PTR tv162[ebp]
  00094	8b 44 ca 04	 mov	 eax, DWORD PTR [edx+ecx*8+4]
  00098	3b 45 0c	 cmp	 eax, DWORD PTR _hash$[ebp+4]
  0009b	75 02		 jne	 SHORT $LN4@EnterValue
  0009d	eb 60		 jmp	 SHORT $LN3@EnterValue
$LN4@EnterValue:

; 93   :     i += ((ui32)hash & 0xff) + 1; 

  0009f	8b 4d 08	 mov	 ecx, DWORD PTR _hash$[ebp]
  000a2	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000a8	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000ab	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  000af	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 94   :     j++;

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  000b5	83 c1 01	 add	 ecx, 1
  000b8	89 4d f4	 mov	 DWORD PTR _j$[ebp], ecx

; 95   :     if (j == SW_MAX_HASH_OFFSET) 

  000bb	83 7d f4 0a	 cmp	 DWORD PTR _j$[ebp], 10	; 0000000aH
  000bf	75 24		 jne	 SHORT $LN5@EnterValue

; 96   :     {
; 97   :       i=index;

  000c1	8b 55 f0	 mov	 edx, DWORD PTR _index$[ebp]
  000c4	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx

; 98   : #ifdef HASHSTATS
; 99   :       totalPointsCacheEntries--;

  000c7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?totalPointsCacheEntries@@3HA ; totalPointsCacheEntries
  000cc	83 e8 01	 sub	 eax, 1
  000cf	a3 00 00 00 00	 mov	 DWORD PTR ?totalPointsCacheEntries@@3HA, eax ; totalPointsCacheEntries

; 100  :       pointsHashCacheCrash++;

  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pointsHashCacheCrash@@3HA ; pointsHashCacheCrash
  000da	83 c1 01	 add	 ecx, 1
  000dd	89 0d 00 00 00
	00		 mov	 DWORD PTR ?pointsHashCacheCrash@@3HA, ecx ; pointsHashCacheCrash

; 101  : #endif
; 102  :       break;

  000e3	eb 1a		 jmp	 SHORT $LN3@EnterValue
$LN5@EnterValue:

; 103  :     };
; 104  :     if (i >= SWHASHSIZE) i -= SWHASHSIZE;

  000e5	81 7d f8 17 5e
	2d 00		 cmp	 DWORD PTR _i$[ebp], 2973207 ; 002d5e17H
  000ec	7c 0c		 jl	 SHORT $LN6@EnterValue
  000ee	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000f1	81 ea 17 5e 2d
	00		 sub	 edx, 2973207		; 002d5e17H
  000f7	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN6@EnterValue:

; 105  :   };

  000fa	e9 4c ff ff ff	 jmp	 $LN2@EnterValue
$LN3@EnterValue:

; 106  : #ifdef HASHSTATS
; 107  :   totalPointsCacheEntries++;

  000ff	a1 00 00 00 00	 mov	 eax, DWORD PTR ?totalPointsCacheEntries@@3HA ; totalPointsCacheEntries
  00104	83 c0 01	 add	 eax, 1
  00107	a3 00 00 00 00	 mov	 DWORD PTR ?totalPointsCacheEntries@@3HA, eax ; totalPointsCacheEntries

; 108  : #endif
; 109  :   hashId[i] = hash;

  0010c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00111	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00114	8b 4d 08	 mov	 ecx, DWORD PTR _hash$[ebp]
  00117	8b 75 0c	 mov	 esi, DWORD PTR _hash$[ebp+4]
  0011a	89 0c c2	 mov	 DWORD PTR [edx+eax*8], ecx
  0011d	89 74 c2 04	 mov	 DWORD PTR [edx+eax*8+4], esi

; 110  :   valuePairs[i].player1min = value->player1Min;

  00121	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00124	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00127	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0012a	8b 55 10	 mov	 edx, DWORD PTR _value$[ebp]
  0012d	66 8b 12	 mov	 dx, WORD PTR [edx]
  00130	66 89 14 88	 mov	 WORD PTR [eax+ecx*4], dx

; 111  :   valuePairs[i].player2min = value->player2Min;

  00134	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00137	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0013a	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0013d	8b 45 10	 mov	 eax, DWORD PTR _value$[ebp]
  00140	66 8b 40 02	 mov	 ax, WORD PTR [eax+2]
  00144	66 89 44 91 02	 mov	 WORD PTR [ecx+edx*4+2], ax

; 112  : }

  00149	5e		 pop	 esi
  0014a	83 c4 20	 add	 esp, 32			; 00000020H
  0014d	3b ec		 cmp	 ebp, esp
  0014f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00154	8b e5		 mov	 esp, ebp
  00156	5d		 pop	 ebp
  00157	c2 0c 00	 ret	 12			; 0000000cH
?EnterValue@SWHASHTABLE@@QAEX_KPAUSWVALUE@@@Z ENDP	; SWHASHTABLE::EnterValue
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Hash.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
_value$ = 12						; size = 4
?Value@SWHASHTABLE@@QAEXHPAUSWVALUE@@@Z PROC		; SWHASHTABLE::Value
; _this$ = ecx

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 56   :   value->player1Min = valuePairs[index].player1min;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000d	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp]
  00010	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00013	66 8b 0c 81	 mov	 cx, WORD PTR [ecx+eax*4]
  00017	66 89 0a	 mov	 WORD PTR [edx], cx

; 57   :   value->player2Min = valuePairs[index].player2min;

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  00023	8b 55 08	 mov	 edx, DWORD PTR _index$[ebp]
  00026	66 8b 44 90 02	 mov	 ax, WORD PTR [eax+edx*4+2]
  0002b	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 58   : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
?Value@SWHASHTABLE@@QAEXHPAUSWVALUE@@@Z ENDP		; SWHASHTABLE::Value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Hash.cpp
_TEXT	SEGMENT
tv146 = -28						; size = 4
tv145 = -24						; size = 4
tv135 = -20						; size = 4
tv134 = -16						; size = 4
_index$ = -12						; size = 4
_j$ = -8						; size = 4
_this$ = -4						; size = 4
_hash$ = 8						; size = 8
?Exists@SWHASHTABLE@@QAEH_K@Z PROC			; SWHASHTABLE::Exists
; _this$ = ecx

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000f	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00012	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00015	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00018	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001b	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001e	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00021	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 62   :   int j, index;
; 63   :   index = (int)(hash%SWHASHSIZE); 

  00024	6a 00		 push	 0
  00026	68 17 5e 2d 00	 push	 2973207			; 002d5e17H
  0002b	8b 45 0c	 mov	 eax, DWORD PTR _hash$[ebp+4]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _hash$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 __aullrem
  00038	89 45 f4	 mov	 DWORD PTR _index$[ebp], eax

; 64   :   j = 0;

  0003b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0

; 65   : #ifdef HASHSTATS
; 66   :   pointsExistsCalls++;

  00042	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?pointsExistsCalls@@3HA ; pointsExistsCalls
  00048	83 c2 01	 add	 edx, 1
  0004b	89 15 00 00 00
	00		 mov	 DWORD PTR ?pointsExistsCalls@@3HA, edx ; pointsExistsCalls
$LN2@Exists:

; 67   : #endif
; 68   :   while (hashId[index]!=0)

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	8b 55 f4	 mov	 edx, DWORD PTR _index$[ebp]
  00059	89 4d f0	 mov	 DWORD PTR tv134[ebp], ecx
  0005c	89 55 ec	 mov	 DWORD PTR tv135[ebp], edx
  0005f	8b 45 ec	 mov	 eax, DWORD PTR tv135[ebp]
  00062	8b 4d f0	 mov	 ecx, DWORD PTR tv134[ebp]
  00065	8b 55 ec	 mov	 edx, DWORD PTR tv135[ebp]
  00068	8b 75 f0	 mov	 esi, DWORD PTR tv134[ebp]
  0006b	8b 04 c1	 mov	 eax, DWORD PTR [ecx+eax*8]
  0006e	0b 44 d6 04	 or	 eax, DWORD PTR [esi+edx*8+4]
  00072	74 7f		 je	 SHORT $LN3@Exists

; 69   :   {
; 70   :     if (hashId[index] == hash)

  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	8b 11		 mov	 edx, DWORD PTR [ecx]
  00079	8b 45 f4	 mov	 eax, DWORD PTR _index$[ebp]
  0007c	89 55 e8	 mov	 DWORD PTR tv145[ebp], edx
  0007f	89 45 e4	 mov	 DWORD PTR tv146[ebp], eax
  00082	8b 4d e4	 mov	 ecx, DWORD PTR tv146[ebp]
  00085	8b 55 e8	 mov	 edx, DWORD PTR tv145[ebp]
  00088	8b 04 ca	 mov	 eax, DWORD PTR [edx+ecx*8]
  0008b	3b 45 08	 cmp	 eax, DWORD PTR _hash$[ebp]
  0008e	75 23		 jne	 SHORT $LN4@Exists
  00090	8b 4d e4	 mov	 ecx, DWORD PTR tv146[ebp]
  00093	8b 55 e8	 mov	 edx, DWORD PTR tv145[ebp]
  00096	8b 44 ca 04	 mov	 eax, DWORD PTR [edx+ecx*8+4]
  0009a	3b 45 0c	 cmp	 eax, DWORD PTR _hash$[ebp+4]
  0009d	75 14		 jne	 SHORT $LN4@Exists

; 71   :     {
; 72   : #ifdef HASHSTATS
; 73   :       pointsExistsTrue++;

  0009f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pointsExistsTrue@@3HA ; pointsExistsTrue
  000a5	83 c1 01	 add	 ecx, 1
  000a8	89 0d 00 00 00
	00		 mov	 DWORD PTR ?pointsExistsTrue@@3HA, ecx ; pointsExistsTrue

; 74   : #endif
; 75   :       return index;

  000ae	8b 45 f4	 mov	 eax, DWORD PTR _index$[ebp]
  000b1	eb 43		 jmp	 SHORT $LN1@Exists
$LN4@Exists:

; 76   :     };
; 77   :     index += ((ui32)hash & 0xff) + 1;

  000b3	8b 55 08	 mov	 edx, DWORD PTR _hash$[ebp]
  000b6	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000bc	8b 45 f4	 mov	 eax, DWORD PTR _index$[ebp]
  000bf	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  000c3	89 4d f4	 mov	 DWORD PTR _index$[ebp], ecx

; 78   :     j++;

  000c6	8b 55 f8	 mov	 edx, DWORD PTR _j$[ebp]
  000c9	83 c2 01	 add	 edx, 1
  000cc	89 55 f8	 mov	 DWORD PTR _j$[ebp], edx

; 79   :     if (j == SW_MAX_HASH_OFFSET) return -1;

  000cf	83 7d f8 0a	 cmp	 DWORD PTR _j$[ebp], 10	; 0000000aH
  000d3	75 05		 jne	 SHORT $LN5@Exists
  000d5	83 c8 ff	 or	 eax, -1
  000d8	eb 1c		 jmp	 SHORT $LN1@Exists
$LN5@Exists:

; 80   :     if (index >= SWHASHSIZE) index -= SWHASHSIZE;

  000da	81 7d f4 17 5e
	2d 00		 cmp	 DWORD PTR _index$[ebp], 2973207 ; 002d5e17H
  000e1	7c 0b		 jl	 SHORT $LN6@Exists
  000e3	8b 45 f4	 mov	 eax, DWORD PTR _index$[ebp]
  000e6	2d 17 5e 2d 00	 sub	 eax, 2973207		; 002d5e17H
  000eb	89 45 f4	 mov	 DWORD PTR _index$[ebp], eax
$LN6@Exists:

; 81   :   };

  000ee	e9 5e ff ff ff	 jmp	 $LN2@Exists
$LN3@Exists:

; 82   :   return -1;

  000f3	83 c8 ff	 or	 eax, -1
$LN1@Exists:

; 83   : }

  000f6	5e		 pop	 esi
  000f7	83 c4 1c	 add	 esp, 28			; 0000001cH
  000fa	3b ec		 cmp	 ebp, esp
  000fc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c2 08 00	 ret	 8
?Exists@SWHASHTABLE@@QAEH_K@Z ENDP			; SWHASHTABLE::Exists
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Hash.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1SWHASHTABLE@@QAE@XZ PROC				; SWHASHTABLE::~SWHASHTABLE
; _this$ = ecx

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 48   :   if (hashId != NULL) free(hashId);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 38 00	 cmp	 DWORD PTR [eax], 0
  00015	74 18		 je	 SHORT $LN2@SWHASHTABL
  00017	8b f4		 mov	 esi, esp
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001e	52		 push	 edx
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00025	83 c4 04	 add	 esp, 4
  00028	3b f4		 cmp	 esi, esp
  0002a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@SWHASHTABL:

; 49   :   hashId = NULL;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 50   :   if (valuePairs != NULL) free(valuePairs);

  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0003f	74 19		 je	 SHORT $LN3@SWHASHTABL
  00041	8b f4		 mov	 esi, esp
  00043	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00046	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00049	50		 push	 eax
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00050	83 c4 04	 add	 esp, 4
  00053	3b f4		 cmp	 esi, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@SWHASHTABL:

; 51   :   valuePairs = NULL;

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 52   : }

  00064	5e		 pop	 esi
  00065	83 c4 04	 add	 esp, 4
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
??1SWHASHTABLE@@QAE@XZ ENDP				; SWHASHTABLE::~SWHASHTABLE
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Hash.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0SWHASHTABLE@@QAE@XZ PROC				; SWHASHTABLE::SWHASHTABLE
; _this$ = ecx

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 28   : #ifdef HASHSTATS
; 29   :   pointsExistsCalls = 0;

  0000f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pointsExistsCalls@@3HA, 0 ; pointsExistsCalls

; 30   :   pointsExistsTrue = 0;

  00019	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pointsExistsTrue@@3HA, 0 ; pointsExistsTrue

; 31   :   totalPointsCacheEntries = 0;

  00023	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?totalPointsCacheEntries@@3HA, 0 ; totalPointsCacheEntries

; 32   :   pointsHashCacheCrash = 0;

  0002d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pointsHashCacheCrash@@3HA, 0 ; pointsHashCacheCrash

; 33   :   pointsCacheUpdate = 0;

  00037	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pointsCacheUpdate@@3HA, 0 ; pointsCacheUpdate

; 34   : #endif
; 35   :   hashId = (ui64 *)malloc(SWHASHSIZE * sizeof (hashId[0]));

  00041	8b f4		 mov	 esi, esp
  00043	68 b8 f0 6a 01	 push	 23785656		; 016af0b8H
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0004e	83 c4 04	 add	 esp, 4
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	89 01		 mov	 DWORD PTR [ecx], eax

; 36   :   valuePairs = (SWHASHVALUE *)malloc(SWHASHSIZE * sizeof (valuePairs[0]));

  0005d	8b f4		 mov	 esi, esp
  0005f	68 5c 78 b5 00	 push	 11892828		; 00b5785cH
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006a	83 c4 04	 add	 esp, 4
  0006d	3b f4		 cmp	 esi, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00077	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 37   :   if ( (hashId == NULL) || (valuePairs == NULL) )

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00080	74 09		 je	 SHORT $LN3@SWHASHTABL
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00089	75 0f		 jne	 SHORT $LN2@SWHASHTABL
$LN3@SWHASHTABL:

; 38   :   {
; 39   :     die("Cannot allocate hash table");

  0008b	68 00 00 00 00	 push	 OFFSET $SG225430
  00090	e8 00 00 00 00	 call	 ?die@@YAXPBD@Z		; die
  00095	83 c4 04	 add	 esp, 4

; 40   :     return;

  00098	eb 1f		 jmp	 SHORT $LN1@SWHASHTABL
$LN2@SWHASHTABL:

; 41   :   };
; 42   :   memset(hashId, 0, SWHASHSIZE*sizeof(hashId[0]));

  0009a	68 b8 f0 6a 01	 push	 23785656		; 016af0b8H
  0009f	6a 00		 push	 0
  000a1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a4	8b 02		 mov	 eax, DWORD PTR [edx]
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 _memset
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 43   :   numEnt = 0;

  000af	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
$LN1@SWHASHTABL:

; 44   : }

  000b9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bc	5e		 pop	 esi
  000bd	83 c4 04	 add	 esp, 4
  000c0	3b ec		 cmp	 ebp, esp
  000c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
??0SWHASHTABLE@@QAE@XZ ENDP				; SWHASHTABLE::SWHASHTABLE
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Hash.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\Hash.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
