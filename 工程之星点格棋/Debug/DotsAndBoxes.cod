; Listing generated by Microsoft (R) Optimizing Compiler Version 19.35.32217.1 

	TITLE	C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\Debug\DotsAndBoxes.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG74042 DB	'atlTraceException', 00H
	ORG $+2
$SG225035 DB	'#Comments are welcome anywhere', 0aH, 00H
$SG225036 DB	'#Human vertical = ', 00H
	ORG $+1
$SG225037 DB	0aH, 00H
	ORG $+2
$SG225038 DB	'#Computer vertical = ', 00H
	ORG $+2
$SG225039 DB	0aH, 00H
	ORG $+2
$SG225040 DB	'#Human horizontal = ', 00H
	ORG $+3
$SG225041 DB	0aH, 00H
	ORG $+2
$SG225042 DB	'#Computer horizontal = ', 00H
$SG225043 DB	0aH, 00H
	ORG $+2
$SG225044 DB	'#Human box ownership = ', 00H
$SG225045 DB	0aH, 00H
	ORG $+2
$SG225046 DB	'#Computer box ownership = ', 00H
	ORG $+1
$SG225047 DB	0aH, 00H
	ORG $+2
$SG225048 DB	'#', 0aH, 00H
	ORG $+1
$SG225054 DB	'#The first row determines width', 00H
$SG225055 DB	0aH, 00H
	ORG $+2
$SG225064 DB	0aH, 00H
	ORG $+2
$SG225065 DB	'Anything illegal in column one determines height.', 0aH, 00H
	ORG $+1
$SG225070 DB	'Improperly formatted Dots-and-Boxes File', 0aH, '%s', 00H
$SG225071 DB	'Error loading', 00H
	ORG $+2
$SG225114 DB	'Expected Horizontal line character', 00H
	ORG $+1
$SG225118 DB	'Expected vertical lines and owners.', 00H
$SG225134 DB	'Expected blank or Owner Type', 00H
	ORG $+3
$SG225136 DB	'No game found in file', 00H
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	__vswprintf_s_l
PUBLIC	_swprintf_s
PUBLIC	??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
PUBLIC	?RegisterCategory@CTrace@ATL@@SAXPBDI@Z		; ATL::CTrace::RegisterCategory
PUBLIC	??0VECTOR@@QAE@XZ				; VECTOR::VECTOR
PUBLIC	?ReadFromArchive@DOTS_AND_BOXES@@AAE_NAAVarInput@@@Z ; DOTS_AND_BOXES::ReadFromArchive
PUBLIC	?Clear@DOTS_AND_BOXES@@AAEXXZ			; DOTS_AND_BOXES::Clear
PUBLIC	?Setup@DOTS_AND_BOXES@@AAEXHH@Z			; DOTS_AND_BOXES::Setup
PUBLIC	?BuildXitionTable@DOTS_AND_BOXES@@AAEXQAY131H@Z	; DOTS_AND_BOXES::BuildXitionTable
PUBLIC	?v@DOTS_AND_BOXES@@AAEXXZ			; DOTS_AND_BOXES::v
PUBLIC	??0DOTS_AND_BOXES@@QAE@HH@Z			; DOTS_AND_BOXES::DOTS_AND_BOXES
PUBLIC	??1DOTS_AND_BOXES@@QAE@XZ			; DOTS_AND_BOXES::~DOTS_AND_BOXES
PUBLIC	??5DOTS_AND_BOXES@@QBEXAAVCArchive@@@Z		; DOTS_AND_BOXES::operator>>
PUBLIC	??6DOTS_AND_BOXES@@QAEXAAVarInput@@@Z		; DOTS_AND_BOXES::operator<<
PUBLIC	??4DOTS_AND_BOXES@@QAEAAV0@ABV0@@Z		; DOTS_AND_BOXES::operator=
PUBLIC	??4DOTS_AND_BOXES@@QAEAAV0@_K@Z			; DOTS_AND_BOXES::operator=
PUBLIC	?Width@DOTS_AND_BOXES@@QBEHXZ			; DOTS_AND_BOXES::Width
PUBLIC	?Height@DOTS_AND_BOXES@@QBEHXZ			; DOTS_AND_BOXES::Height
PUBLIC	?Size@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ	; DOTS_AND_BOXES::Size
PUBLIC	?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
PUBLIC	?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::VLineType
PUBLIC	?SetVLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetVLineType
PUBLIC	?SetVLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetVLineType
PUBLIC	?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
PUBLIC	?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::HLineType
PUBLIC	?SetHLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetHLineType
PUBLIC	?SetHLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetHLineType
PUBLIC	?BoxOwner@DOTS_AND_BOXES@@QBE?AW4OWNER_TYPE@@HH@Z ; DOTS_AND_BOXES::BoxOwner
PUBLIC	?SetBoxOwner@DOTS_AND_BOXES@@QAEXHHW4OWNER_TYPE@@@Z ; DOTS_AND_BOXES::SetBoxOwner
PUBLIC	?Dot2Line@DOTS_AND_BOXES@@QBEHHH_N@Z		; DOTS_AND_BOXES::Dot2Line
PUBLIC	?AvoidFlag@DOTS_AND_BOXES@@QBEHHH_N@Z		; DOTS_AND_BOXES::AvoidFlag
PUBLIC	?NumberOfLines@DOTS_AND_BOXES@@QBEHXZ		; DOTS_AND_BOXES::NumberOfLines
PUBLIC	?CountLines@DOTS_AND_BOXES@@QBEHUtagPOINT@@@Z	; DOTS_AND_BOXES::CountLines
PUBLIC	?RemoveCapturables@DOTS_AND_BOXES@@QAEXXZ	; DOTS_AND_BOXES::RemoveCapturables
PUBLIC	?CountCapturables@DOTS_AND_BOXES@@QBEHXZ	; DOTS_AND_BOXES::CountCapturables
PUBLIC	?IsFinished@DOTS_AND_BOXES@@QBE_NXZ		; DOTS_AND_BOXES::IsFinished
PUBLIC	?ComputeDivideAndConquerWeights_3@DOTS_AND_BOXES@@QAEXXZ ; DOTS_AND_BOXES::ComputeDivideAndConquerWeights_3
PUBLIC	?ComputeBreakUpLoopWeights@DOTS_AND_BOXES@@QAEXH@Z ; DOTS_AND_BOXES::ComputeBreakUpLoopWeights
PUBLIC	?MinMaxLoopWeight@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ ; DOTS_AND_BOXES::MinMaxLoopWeight
PUBLIC	?MinMaxDivideWeight@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ ; DOTS_AND_BOXES::MinMaxDivideWeight
PUBLIC	?AddPartner@DIVIDE_3@@AAEXHH@Z			; DIVIDE_3::AddPartner
PUBLIC	?FindNeighbors@DIVIDE_3@@AAEXHH@Z		; DIVIDE_3::FindNeighbors
PUBLIC	?FindDistances@DIVIDE_3@@AAEXPAH0@Z		; DIVIDE_3::FindDistances
PUBLIC	?LineNumber@DIVIDE_3@@AAEHHH@Z			; DIVIDE_3::LineNumber
PUBLIC	??0DIVIDE_3@@QAE@PBVDOTS_AND_BOXES@@@Z		; DIVIDE_3::DIVIDE_3
PUBLIC	?FindWeights@DIVIDE_3@@QAEXPAH00@Z		; DIVIDE_3::FindWeights
PUBLIC	?Write@@YAXAAVCArchive@@D@Z			; Write
PUBLIC	?Write@@YAXAAVCArchive@@PBD@Z			; Write
PUBLIC	?BadFormat@@YAXPAD@Z				; BadFormat
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs@		; `string'
PUBLIC	?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
PUBLIC	?m_nLastCategory@CTrace@ATL@@1IA		; ATL::CTrace::m_nLastCategory
PUBLIC	?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A	; ATL::CTrace::m_nMap
PUBLIC	??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs@		; `string'
PUBLIC	??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm@ ; `string'
PUBLIC	??_C@_1LM@KONDCONO@?$AAG?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi@ ; `string'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__wcscpy_s:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp____stdio_common_vswprintf_s:PROC
EXTRN	__imp___CrtDbgReportW:PROC
EXTRN	__imp_??A?$CSimpleStringT@D$00@ATL@@QBEDH@Z:PROC
EXTRN	__imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ:PROC
EXTRN	__imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ:PROC
EXTRN	?Write@CArchive@@QAEXPBXI@Z:PROC		; CArchive::Write
EXTRN	?ReadLine@arInput@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ:PROC ; arInput::ReadLine
EXTRN	?FindAvoids@DOTS_AND_BOXES@@QAEXXZ:PROC		; DOTS_AND_BOXES::FindAvoids
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__aullshr:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceException
_BSS	ENDS
;	COMDAT ?m_nLastCategory@CTrace@ATL@@1IA
_BSS	SEGMENT
?m_nLastCategory@CTrace@ATL@@1IA DD 01H DUP (?)		; ATL::CTrace::m_nLastCategory
_BSS	ENDS
;	COMDAT ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A
_BSS	SEGMENT
?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A DB 02080H DUP (?) ; ATL::CTrace::m_nMap
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceException$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceException@ATL@@YAXXZ ; ATL::atlTraceException$initializer$
CRT$XCU	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1LM@KONDCONO@?$AAG?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi@
CONST	SEGMENT
??_C@_1LM@KONDCONO@?$AAG?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi@ DB 'G'
	DB	00H, ':', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r', 00H
	DB	'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H, 'V'
	DB	00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' ', 00H
	DB	'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, '\'
	DB	00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H, 'C', 00H
	DB	'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H, 't'
	DB	00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T', 00H
	DB	'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H, 'S'
	DB	00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.', 00H
	DB	'3', 00H, '5', 00H, '.', 00H, '3', 00H, '2', 00H, '2', 00H, '1'
	DB	00H, '5', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm', 00H
	DB	'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't', 00H
	DB	'l', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'c', 00H, 'e', 00H, '.'
	DB	00H, 'h', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm@
CONST	SEGMENT
??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm@ DB 'f'
	DB	00H, 'a', 00H, 'l', 00H, 's', 00H, 'e', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, '"', 00H, 'T', 00H, 'o', 00H, 'o', 00H, ' '
	DB	00H, 'm', 00H, 'a', 00H, 'n', 00H, 'y', 00H, ' ', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, 'd', 00H, 'e', 00H, 'f', 00H
	DB	'i', 00H, 'n', 00H, 'e', 00H, 'd', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs@
CONST	SEGMENT
??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs@ DB '%', 00H, 'h', 00H, 's', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs@
CONST	SEGMENT
??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs@ DB '%', 00H, 'l', 00H, 's', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__unwindfunclet$?BadFormat@@YAXPAD@Z$0
	DD	020H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__unwindfunclet$??6DOTS_AND_BOXES@@QAEXAAVarInput@@@Z$0
	DD	016H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__ehhandler$??1DOTS_AND_BOXES@@QAE@XZ
	DD	09H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__unwindfunclet$?ReadFromArchive@DOTS_AND_BOXES@@AAE_NAAVarInput@@@Z$0
	DD	044H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?FindWeights@DIVIDE_3@@QAEXPAH00@Z
	DD	025H
	DD	017bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?FindDistances@DIVIDE_3@@AAEXPAH0@Z
	DD	025H
	DD	02a8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?ComputeBreakUpLoopWeights@DOTS_AND_BOXES@@QAEXH@Z
	DD	025H
	DD	0cd6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?ComputeDivideAndConquerWeights_3@DOTS_AND_BOXES@@QAEXXZ
	DD	02aH
	DD	041bH
voltbl	ENDS
xdata$x	SEGMENT
__unwindtable$?BadFormat@@YAXPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BadFormat@@YAXPAD@Z$0
__unwindtable$??6DOTS_AND_BOXES@@QAEXAAVarInput@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6DOTS_AND_BOXES@@QAEXAAVarInput@@@Z$0
__unwindtable$?ReadFromArchive@DOTS_AND_BOXES@@AAE_NAAVarInput@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReadFromArchive@DOTS_AND_BOXES@@AAE_NAAVarInput@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ReadFromArchive@DOTS_AND_BOXES@@AAE_NAAVarInput@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ReadFromArchive@DOTS_AND_BOXES@@AAE_NAAVarInput@@@Z$2
__ehfuncinfo$?BadFormat@@YAXPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?BadFormat@@YAXPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??6DOTS_AND_BOXES@@QAEXAAVarInput@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??6DOTS_AND_BOXES@@QAEXAAVarInput@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??1DOTS_AND_BOXES@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__ehfuncinfo$?ReadFromArchive@DOTS_AND_BOXES@@AAE_NAAVarInput@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ReadFromArchive@DOTS_AND_BOXES@@AAE_NAAVarInput@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	024H
	DW	0100H
voltbl	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
_m$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_message$ = 8						; size = 4
?BadFormat@@YAXPAD@Z PROC				; BadFormat

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?BadFormat@@YAXPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	c7 45 e8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-24], -858993460 ; ccccccccH
  0001d	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  00024	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 161  :   CString m;

  0003c	8b f4		 mov	 esi, esp
  0003e	8d 4d ec	 lea	 ecx, DWORD PTR _m$[ebp]
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00047	3b f4		 cmp	 esi, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 162  :   m.Format("Improperly formatted Dots-and-Boxes File\n%s",message);

  00055	8b f4		 mov	 esi, esp
  00057	8b 45 08	 mov	 eax, DWORD PTR _message$[ebp]
  0005a	50		 push	 eax
  0005b	68 00 00 00 00	 push	 OFFSET $SG225070
  00060	8d 4d ec	 lea	 ecx, DWORD PTR _m$[ebp]
  00063	51		 push	 ecx
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	3b f4		 cmp	 esi, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 163  :   MessageBox(NULL, m, "Error loading", MB_OK);

  00074	8b f4		 mov	 esi, esp
  00076	6a 00		 push	 0
  00078	68 00 00 00 00	 push	 OFFSET $SG225071
  0007d	8b fc		 mov	 edi, esp
  0007f	8d 4d ec	 lea	 ecx, DWORD PTR _m$[ebp]
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00088	3b fc		 cmp	 edi, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	50		 push	 eax
  00090	6a 00		 push	 0
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  00098	3b f4		 cmp	 esi, esp
  0009a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 164  : }

  0009f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000a6	8b f4		 mov	 esi, esp
  000a8	8d 4d ec	 lea	 ecx, DWORD PTR _m$[ebp]
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000b1	3b f4		 cmp	 esi, esp
  000b3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b8	52		 push	 edx
  000b9	8b cd		 mov	 ecx, ebp
  000bb	50		 push	 eax
  000bc	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@BadFormat
  000c2	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000c7	58		 pop	 eax
  000c8	5a		 pop	 edx
  000c9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d3	59		 pop	 ecx
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	83 c4 18	 add	 esp, 24			; 00000018H
  000d9	3b ec		 cmp	 ebp, esp
  000db	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
$LN7@BadFormat:
  000e4	01 00 00 00	 DD	 1
  000e8	00 00 00 00	 DD	 $LN6@BadFormat
$LN6@BadFormat:
  000ec	ec ff ff ff	 DD	 -20			; ffffffecH
  000f0	04 00 00 00	 DD	 4
  000f4	00 00 00 00	 DD	 $LN4@BadFormat
$LN4@BadFormat:
  000f8	6d		 DB	 109			; 0000006dH
  000f9	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?BadFormat@@YAXPAD@Z$0:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d ec	 lea	 ecx, DWORD PTR _m$[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
__ehhandler$?BadFormat@@YAXPAD@Z:
  00017	90		 npad	 1
  00018	90		 npad	 1
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?BadFormat@@YAXPAD@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?BadFormat@@YAXPAD@Z ENDP				; BadFormat
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
_len$ = -8						; size = 4
_i$ = -4						; size = 4
_ar$ = 8						; size = 4
_line$ = 12						; size = 4
?Write@@YAXAAVCArchive@@PBD@Z PROC			; Write

; 85   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 86   :   int i, len = strlen(line);

  00014	8b 45 0c	 mov	 eax, DWORD PTR _line$[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 _strlen
  0001d	83 c4 04	 add	 esp, 4
  00020	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 87   :   for (i=0; i<len; i++)

  00023	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002a	eb 09		 jmp	 SHORT $LN4@Write
$LN2@Write:
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0002f	83 c1 01	 add	 ecx, 1
  00032	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@Write:
  00035	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00038	3b 55 f8	 cmp	 edx, DWORD PTR _len$[ebp]
  0003b	7d 44		 jge	 SHORT $LN1@Write

; 88   :   {
; 89   :     if (line[i] == '\n')

  0003d	8b 45 0c	 mov	 eax, DWORD PTR _line$[ebp]
  00040	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00043	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00046	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00049	75 1e		 jne	 SHORT $LN5@Write

; 90   :     {
; 91   :       Write(ar, '\015');

  0004b	6a 0d		 push	 13			; 0000000dH
  0004d	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@D@Z ; Write
  00056	83 c4 08	 add	 esp, 8

; 92   :       Write(ar, '\012');

  00059	6a 0a		 push	 10			; 0000000aH
  0005b	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@D@Z ; Write
  00064	83 c4 08	 add	 esp, 8
  00067	eb 16		 jmp	 SHORT $LN6@Write
$LN5@Write:

; 93   :     } else Write(ar, line[i]);

  00069	8b 4d 0c	 mov	 ecx, DWORD PTR _line$[ebp]
  0006c	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  0006f	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00072	52		 push	 edx
  00073	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@D@Z ; Write
  0007c	83 c4 08	 add	 esp, 8
$LN6@Write:

; 94   :   };

  0007f	eb ab		 jmp	 SHORT $LN2@Write
$LN1@Write:

; 95   : }

  00081	83 c4 08	 add	 esp, 8
  00084	3b ec		 cmp	 ebp, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
?Write@@YAXAAVCArchive@@PBD@Z ENDP			; Write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
_ar$ = 8						; size = 4
_c$ = 12						; size = 1
?Write@@YAXAAVCArchive@@D@Z PROC			; Write

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 81   :   ar.Write(&c, 1);

  00003	6a 01		 push	 1
  00005	8d 45 0c	 lea	 eax, DWORD PTR _c$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0000c	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 82   : }

  00011	3b ec		 cmp	 ebp, esp
  00013	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?Write@@YAXAAVCArchive@@D@Z ENDP			; Write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
_line$1 = -924						; size = 4
_neighbor$2 = -920					; size = 4
_distance$3 = -916					; size = 4
_j$4 = -912						; size = 4
_dstDistances$ = -904					; size = 440
_srcDistances$ = -456					; size = 440
_i$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
_weights$ = 16						; size = 4
?FindWeights@DIVIDE_3@@QAEXPAH00@Z PROC			; DIVIDE_3::FindWeights
; _this$ = ecx

; 986  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 9c 03 00
	00		 sub	 esp, 924		; 0000039cH
  00009	57		 push	 edi
  0000a	51		 push	 ecx
  0000b	8d bd 64 fc ff
	ff		 lea	 edi, DWORD PTR [ebp-924]
  00011	b9 e7 00 00 00	 mov	 ecx, 231		; 000000e7H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	59		 pop	 ecx
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 987  :   int i;
; 988  :   int srcDistances[MAX_NODES], dstDistances[MAX_NODES];
; 989  :   FindDistances(src, srcDistances);

  0002b	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR _srcDistances$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  00035	51		 push	 ecx
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?FindDistances@DIVIDE_3@@AAEXPAH0@Z ; DIVIDE_3::FindDistances

; 990  :   FindDistances(dst, dstDistances);

  0003e	8d 95 78 fc ff
	ff		 lea	 edx, DWORD PTR _dstDistances$[ebp]
  00044	52		 push	 edx
  00045	8b 45 0c	 mov	 eax, DWORD PTR _dst$[ebp]
  00048	50		 push	 eax
  00049	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?FindDistances@DIVIDE_3@@AAEXPAH0@Z ; DIVIDE_3::FindDistances

; 991  :   for (i=0; i<m_numNodes; i++)

  00051	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00058	eb 09		 jmp	 SHORT $LN4@FindWeight
$LN2@FindWeight:
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0005d	83 c1 01	 add	 ecx, 1
  00060	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@FindWeight:
  00063	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00069	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  0006c	0f 8d f7 00 00
	00		 jge	 $LN1@FindWeight

; 992  :   {
; 993  :     int j;
; 994  :     int distance;
; 995  :     distance = srcDistances[i] + dstDistances[i];

  00072	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00075	8b 94 8d 38 fe
	ff ff		 mov	 edx, DWORD PTR _srcDistances$[ebp+ecx*4]
  0007c	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0007f	03 94 85 78 fc
	ff ff		 add	 edx, DWORD PTR _dstDistances$[ebp+eax*4]
  00086	89 95 6c fc ff
	ff		 mov	 DWORD PTR _distance$3[ebp], edx

; 996  :     for (j=0; j<m_numNeighbors[i]; j++)

  0008c	c7 85 70 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$4[ebp], 0
  00096	eb 0f		 jmp	 SHORT $LN7@FindWeight
$LN5@FindWeight:
  00098	8b 8d 70 fc ff
	ff		 mov	 ecx, DWORD PTR _j$4[ebp]
  0009e	83 c1 01	 add	 ecx, 1
  000a1	89 8d 70 fc ff
	ff		 mov	 DWORD PTR _j$4[ebp], ecx
$LN7@FindWeight:
  000a7	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000aa	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	8b 8d 70 fc ff
	ff		 mov	 ecx, DWORD PTR _j$4[ebp]
  000b3	3b 8c 90 80 03
	00 00		 cmp	 ecx, DWORD PTR [eax+edx*4+896]
  000ba	0f 8d a4 00 00
	00		 jge	 $LN6@FindWeight

; 997  :     {
; 998  :       int neighbor;
; 999  :       neighbor = m_neighbors[m_1stNeighbor[i]+j];

  000c0	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c6	8b 8c 90 38 05
	00 00		 mov	 ecx, DWORD PTR [eax+edx*4+1336]
  000cd	03 8d 70 fc ff
	ff		 add	 ecx, DWORD PTR _j$4[ebp]
  000d3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000d6	8b 84 8a f0 06
	00 00		 mov	 eax, DWORD PTR [edx+ecx*4+1776]
  000dd	89 85 68 fc ff
	ff		 mov	 DWORD PTR _neighbor$2[ebp], eax

; 1000 :       if (srcDistances[neighbor]+dstDistances[neighbor] == distance)

  000e3	8b 8d 68 fc ff
	ff		 mov	 ecx, DWORD PTR _neighbor$2[ebp]
  000e9	8b 94 8d 38 fe
	ff ff		 mov	 edx, DWORD PTR _srcDistances$[ebp+ecx*4]
  000f0	8b 85 68 fc ff
	ff		 mov	 eax, DWORD PTR _neighbor$2[ebp]
  000f6	03 94 85 78 fc
	ff ff		 add	 edx, DWORD PTR _dstDistances$[ebp+eax*4]
  000fd	3b 95 6c fc ff
	ff		 cmp	 edx, DWORD PTR _distance$3[ebp]
  00103	75 5a		 jne	 SHORT $LN8@FindWeight

; 1001 :       {
; 1002 :         if (srcDistances[neighbor] != srcDistances[i])

  00105	8b 8d 68 fc ff
	ff		 mov	 ecx, DWORD PTR _neighbor$2[ebp]
  0010b	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  0010e	8b 84 8d 38 fe
	ff ff		 mov	 eax, DWORD PTR _srcDistances$[ebp+ecx*4]
  00115	3b 84 95 38 fe
	ff ff		 cmp	 eax, DWORD PTR _srcDistances$[ebp+edx*4]
  0011c	74 41		 je	 SHORT $LN8@FindWeight

; 1003 :         {
; 1004 :           int line;
; 1005 :           line = LineNumber(i, neighbor);

  0011e	8b 8d 68 fc ff
	ff		 mov	 ecx, DWORD PTR _neighbor$2[ebp]
  00124	51		 push	 ecx
  00125	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00128	52		 push	 edx
  00129	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0012c	e8 00 00 00 00	 call	 ?LineNumber@DIVIDE_3@@AAEHHH@Z ; DIVIDE_3::LineNumber
  00131	89 85 64 fc ff
	ff		 mov	 DWORD PTR _line$1[ebp], eax

; 1006 :           if (weights[line] > 100 * distance) weights[line] = 100*distance;

  00137	6b 85 6c fc ff
	ff 64		 imul	 eax, DWORD PTR _distance$3[ebp], 100
  0013e	8b 8d 64 fc ff
	ff		 mov	 ecx, DWORD PTR _line$1[ebp]
  00144	8b 55 10	 mov	 edx, DWORD PTR _weights$[ebp]
  00147	39 04 8a	 cmp	 DWORD PTR [edx+ecx*4], eax
  0014a	7e 13		 jle	 SHORT $LN8@FindWeight
  0014c	6b 85 6c fc ff
	ff 64		 imul	 eax, DWORD PTR _distance$3[ebp], 100
  00153	8b 8d 64 fc ff
	ff		 mov	 ecx, DWORD PTR _line$1[ebp]
  00159	8b 55 10	 mov	 edx, DWORD PTR _weights$[ebp]
  0015c	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
$LN8@FindWeight:

; 1007 :         };
; 1008 :       };
; 1009 :     };

  0015f	e9 34 ff ff ff	 jmp	 $LN5@FindWeight
$LN6@FindWeight:

; 1010 :   };

  00164	e9 f1 fe ff ff	 jmp	 $LN2@FindWeight
$LN1@FindWeight:

; 1011 : }  

  00169	52		 push	 edx
  0016a	8b cd		 mov	 ecx, ebp
  0016c	50		 push	 eax
  0016d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@FindWeight
  00173	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00178	58		 pop	 eax
  00179	5a		 pop	 edx
  0017a	5f		 pop	 edi
  0017b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017e	33 cd		 xor	 ecx, ebp
  00180	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00185	81 c4 9c 03 00
	00		 add	 esp, 924		; 0000039cH
  0018b	3b ec		 cmp	 ebp, esp
  0018d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00192	8b e5		 mov	 esp, ebp
  00194	5d		 pop	 ebp
  00195	c2 0c 00	 ret	 12			; 0000000cH
$LN15@FindWeight:
  00198	02 00 00 00	 DD	 2
  0019c	00 00 00 00	 DD	 $LN14@FindWeight
$LN14@FindWeight:
  001a0	38 fe ff ff	 DD	 -456			; fffffe38H
  001a4	b8 01 00 00	 DD	 440			; 000001b8H
  001a8	00 00 00 00	 DD	 $LN12@FindWeight
  001ac	78 fc ff ff	 DD	 -904			; fffffc78H
  001b0	b8 01 00 00	 DD	 440			; 000001b8H
  001b4	00 00 00 00	 DD	 $LN13@FindWeight
$LN13@FindWeight:
  001b8	64		 DB	 100			; 00000064H
  001b9	73		 DB	 115			; 00000073H
  001ba	74		 DB	 116			; 00000074H
  001bb	44		 DB	 68			; 00000044H
  001bc	69		 DB	 105			; 00000069H
  001bd	73		 DB	 115			; 00000073H
  001be	74		 DB	 116			; 00000074H
  001bf	61		 DB	 97			; 00000061H
  001c0	6e		 DB	 110			; 0000006eH
  001c1	63		 DB	 99			; 00000063H
  001c2	65		 DB	 101			; 00000065H
  001c3	73		 DB	 115			; 00000073H
  001c4	00		 DB	 0
$LN12@FindWeight:
  001c5	73		 DB	 115			; 00000073H
  001c6	72		 DB	 114			; 00000072H
  001c7	63		 DB	 99			; 00000063H
  001c8	44		 DB	 68			; 00000044H
  001c9	69		 DB	 105			; 00000069H
  001ca	73		 DB	 115			; 00000073H
  001cb	74		 DB	 116			; 00000074H
  001cc	61		 DB	 97			; 00000061H
  001cd	6e		 DB	 110			; 0000006eH
  001ce	63		 DB	 99			; 00000063H
  001cf	65		 DB	 101			; 00000065H
  001d0	73		 DB	 115			; 00000073H
  001d1	00		 DB	 0
?FindWeights@DIVIDE_3@@QAEXPAH00@Z ENDP			; DIVIDE_3::FindWeights
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
_pointNum$ = -24					; size = 4
_dotNum$ = -16						; size = 8
_this$ = -4						; size = 4
_pDB$ = 8						; size = 4
??0DIVIDE_3@@QAE@PBVDOTS_AND_BOXES@@@Z PROC		; DIVIDE_3::DIVIDE_3
; _this$ = ecx

; 897  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00011	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00014	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00017	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001a	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001d	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 898  :   //First we build a table of partners and neighbors
; 899  :   //
; 900  :   POINT dotNum;
; 901  :   int pointNum;
; 902  :   m_pDB = pDB;

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _pDB$[ebp]
  00026	89 08		 mov	 DWORD PTR [eax], ecx

; 903  :   m_width = m_pDB->Width();

  00028	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002b	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0002d	e8 00 00 00 00	 call	 ?Width@DOTS_AND_BOXES@@QBEHXZ ; DOTS_AND_BOXES::Width
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 904  :   m_height = m_pDB->Height();

  00038	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0003d	e8 00 00 00 00	 call	 ?Height@DOTS_AND_BOXES@@QBEHXZ ; DOTS_AND_BOXES::Height
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 905  :   m_numNodes = m_width*m_height;

  00048	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00051	0f af 48 08	 imul	 ecx, DWORD PTR [eax+8]
  00055	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00058	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 906  :   m_totalPartners =0;

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	c7 80 e0 ca 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+51936], 0

; 907  :   m_totalNeighbors = 0;

  00068	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	c7 81 e4 ca 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+51940], 0

; 908  :   for (dotNum.y=0; dotNum.y<m_height; dotNum.y++)

  00075	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dotNum$[ebp+4], 0
  0007c	eb 09		 jmp	 SHORT $LN4@DIVIDE_3
$LN2@DIVIDE_3:
  0007e	8b 55 f4	 mov	 edx, DWORD PTR _dotNum$[ebp+4]
  00081	83 c2 01	 add	 edx, 1
  00084	89 55 f4	 mov	 DWORD PTR _dotNum$[ebp+4], edx
$LN4@DIVIDE_3:
  00087	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008a	8b 4d f4	 mov	 ecx, DWORD PTR _dotNum$[ebp+4]
  0008d	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00090	0f 8d a6 00 00
	00		 jge	 $LN1@DIVIDE_3

; 909  :   {
; 910  :     for (dotNum.x=0; dotNum.x<m_width; dotNum.x++)

  00096	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dotNum$[ebp], 0
  0009d	eb 09		 jmp	 SHORT $LN7@DIVIDE_3
$LN5@DIVIDE_3:
  0009f	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp]
  000a2	83 c2 01	 add	 edx, 1
  000a5	89 55 f0	 mov	 DWORD PTR _dotNum$[ebp], edx
$LN7@DIVIDE_3:
  000a8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	8b 4d f0	 mov	 ecx, DWORD PTR _dotNum$[ebp]
  000ae	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000b1	0f 8d 80 00 00
	00		 jge	 $LN6@DIVIDE_3

; 911  :     {
; 912  :       pointNum = dotNum.y*m_width+dotNum.x;

  000b7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ba	8b 45 f4	 mov	 eax, DWORD PTR _dotNum$[ebp+4]
  000bd	0f af 42 04	 imul	 eax, DWORD PTR [edx+4]
  000c1	03 45 f0	 add	 eax, DWORD PTR _dotNum$[ebp]
  000c4	89 45 e8	 mov	 DWORD PTR _pointNum$[ebp], eax

; 913  :       m_numPartners[pointNum] = 0;

  000c7	8b 4d e8	 mov	 ecx, DWORD PTR _pointNum$[ebp]
  000ca	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000cd	c7 44 8a 10 00
	00 00 00	 mov	 DWORD PTR [edx+ecx*4+16], 0

; 914  :       m_1stPartner[pointNum] = m_totalPartners;

  000d5	8b 45 e8	 mov	 eax, DWORD PTR _pointNum$[ebp]
  000d8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000db	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000de	8b 92 e0 ca 00
	00		 mov	 edx, DWORD PTR [edx+51936]
  000e4	89 94 81 c8 01
	00 00		 mov	 DWORD PTR [ecx+eax*4+456], edx

; 915  :       AddPartner(pointNum, pointNum);

  000eb	8b 45 e8	 mov	 eax, DWORD PTR _pointNum$[ebp]
  000ee	50		 push	 eax
  000ef	8b 4d e8	 mov	 ecx, DWORD PTR _pointNum$[ebp]
  000f2	51		 push	 ecx
  000f3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	e8 00 00 00 00	 call	 ?AddPartner@DIVIDE_3@@AAEXHH@Z ; DIVIDE_3::AddPartner

; 916  :       m_numNeighbors[pointNum] = 0;

  000fb	8b 55 e8	 mov	 edx, DWORD PTR _pointNum$[ebp]
  000fe	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00101	c7 84 90 80 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [eax+edx*4+896], 0

; 917  :       m_1stNeighbor[pointNum] = m_totalNeighbors;

  0010c	8b 4d e8	 mov	 ecx, DWORD PTR _pointNum$[ebp]
  0010f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00112	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00115	8b 80 e4 ca 00
	00		 mov	 eax, DWORD PTR [eax+51940]
  0011b	89 84 8a 38 05
	00 00		 mov	 DWORD PTR [edx+ecx*4+1336], eax

; 918  :       FindNeighbors(pointNum, pointNum);

  00122	8b 4d e8	 mov	 ecx, DWORD PTR _pointNum$[ebp]
  00125	51		 push	 ecx
  00126	8b 55 e8	 mov	 edx, DWORD PTR _pointNum$[ebp]
  00129	52		 push	 edx
  0012a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012d	e8 00 00 00 00	 call	 ?FindNeighbors@DIVIDE_3@@AAEXHH@Z ; DIVIDE_3::FindNeighbors

; 919  :     };

  00132	e9 68 ff ff ff	 jmp	 $LN5@DIVIDE_3
$LN6@DIVIDE_3:

; 920  :   };

  00137	e9 42 ff ff ff	 jmp	 $LN2@DIVIDE_3
$LN1@DIVIDE_3:

; 921  : }

  0013c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0013f	52		 push	 edx
  00140	8b cd		 mov	 ecx, ebp
  00142	50		 push	 eax
  00143	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@DIVIDE_3
  00149	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0014e	58		 pop	 eax
  0014f	5a		 pop	 edx
  00150	83 c4 18	 add	 esp, 24			; 00000018H
  00153	3b ec		 cmp	 ebp, esp
  00155	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c2 04 00	 ret	 4
$LN11@DIVIDE_3:
  00160	01 00 00 00	 DD	 1
  00164	00 00 00 00	 DD	 $LN10@DIVIDE_3
$LN10@DIVIDE_3:
  00168	f0 ff ff ff	 DD	 -16			; fffffff0H
  0016c	08 00 00 00	 DD	 8
  00170	00 00 00 00	 DD	 $LN9@DIVIDE_3
$LN9@DIVIDE_3:
  00174	64		 DB	 100			; 00000064H
  00175	6f		 DB	 111			; 0000006fH
  00176	74		 DB	 116			; 00000074H
  00177	4e		 DB	 78			; 0000004eH
  00178	75		 DB	 117			; 00000075H
  00179	6d		 DB	 109			; 0000006dH
  0017a	00		 DB	 0
??0DIVIDE_3@@QAE@PBVDOTS_AND_BOXES@@@Z ENDP		; DIVIDE_3::DIVIDE_3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
_line$ = -16						; size = 4
_y$ = -12						; size = 4
_x$ = -8						; size = 4
_this$ = -4						; size = 4
_p1$ = 8						; size = 4
_p2$ = 12						; size = 4
?LineNumber@DIVIDE_3@@AAEHHH@Z PROC			; DIVIDE_3::LineNumber
; _this$ = ecx

; 974  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 975  :   int x, y, line;
; 976  :   x = p1%m_width;

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	8b 45 08	 mov	 eax, DWORD PTR _p1$[ebp]
  0000f	99		 cdq
  00010	f7 79 04	 idiv	 DWORD PTR [ecx+4]
  00013	89 55 f8	 mov	 DWORD PTR _x$[ebp], edx

; 977  :   y = p1/m_width;

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	8b 45 08	 mov	 eax, DWORD PTR _p1$[ebp]
  0001c	99		 cdq
  0001d	f7 79 04	 idiv	 DWORD PTR [ecx+4]
  00020	89 45 f4	 mov	 DWORD PTR _y$[ebp], eax

; 978  :   line = y*(2*m_width-1)+x;

  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00029	8d 4c 00 ff	 lea	 ecx, DWORD PTR [eax+eax-1]
  0002d	0f af 4d f4	 imul	 ecx, DWORD PTR _y$[ebp]
  00031	03 4d f8	 add	 ecx, DWORD PTR _x$[ebp]
  00034	89 4d f0	 mov	 DWORD PTR _line$[ebp], ecx

; 979  :   if (p2 == p1+1) return line;

  00037	8b 55 08	 mov	 edx, DWORD PTR _p1$[ebp]
  0003a	83 c2 01	 add	 edx, 1
  0003d	39 55 0c	 cmp	 DWORD PTR _p2$[ebp], edx
  00040	75 07		 jne	 SHORT $LN2@LineNumber
  00042	8b 45 f0	 mov	 eax, DWORD PTR _line$[ebp]
  00045	eb 39		 jmp	 SHORT $LN1@LineNumber
  00047	eb 37		 jmp	 SHORT $LN1@LineNumber
$LN2@LineNumber:

; 980  :   else if (p2 == p1-1) return line-1;

  00049	8b 45 08	 mov	 eax, DWORD PTR _p1$[ebp]
  0004c	83 e8 01	 sub	 eax, 1
  0004f	39 45 0c	 cmp	 DWORD PTR _p2$[ebp], eax
  00052	75 0a		 jne	 SHORT $LN4@LineNumber
  00054	8b 45 f0	 mov	 eax, DWORD PTR _line$[ebp]
  00057	83 e8 01	 sub	 eax, 1
  0005a	eb 24		 jmp	 SHORT $LN1@LineNumber
  0005c	eb 22		 jmp	 SHORT $LN1@LineNumber
$LN4@LineNumber:

; 981  :   else if (p2 < p1) return line-m_width;

  0005e	8b 4d 0c	 mov	 ecx, DWORD PTR _p2$[ebp]
  00061	3b 4d 08	 cmp	 ecx, DWORD PTR _p1$[ebp]
  00064	7d 0d		 jge	 SHORT $LN6@LineNumber
  00066	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00069	8b 45 f0	 mov	 eax, DWORD PTR _line$[ebp]
  0006c	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  0006f	eb 0f		 jmp	 SHORT $LN1@LineNumber
  00071	eb 0d		 jmp	 SHORT $LN1@LineNumber
$LN6@LineNumber:

; 982  :   else return line+m_width-1;

  00073	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00076	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00079	8b 55 f0	 mov	 edx, DWORD PTR _line$[ebp]
  0007c	8d 44 0a ff	 lea	 eax, DWORD PTR [edx+ecx-1]
$LN1@LineNumber:

; 983  : }

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 08 00	 ret	 8
?LineNumber@DIVIDE_3@@AAEHHH@Z ENDP			; DIVIDE_3::LineNumber
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
_neighborPoint$1 = -944					; size = 4
_j$2 = -940						; size = 4
_neighbor$3 = -936					; size = 4
_pointNum$4 = -932					; size = 4
_i$5 = -928						; size = 4
_partner$6 = -924					; size = 4
_j$7 = -920						; size = 4
_numVisited$ = -916					; size = 4
_numInList$ = -912					; size = 4
_list$ = -904						; size = 440
_listed$ = -456						; size = 440
_i$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_src$ = 8						; size = 4
_distances$ = 12					; size = 4
?FindDistances@DIVIDE_3@@AAEXPAH0@Z PROC		; DIVIDE_3::FindDistances
; _this$ = ecx

; 924  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b0 03 00
	00		 sub	 esp, 944		; 000003b0H
  00009	57		 push	 edi
  0000a	51		 push	 ecx
  0000b	8d bd 50 fc ff
	ff		 lea	 edi, DWORD PTR [ebp-944]
  00011	b9 ec 00 00 00	 mov	 ecx, 236		; 000000ecH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	59		 pop	 ecx
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 925  :   int i;
; 926  :   int listed[MAX_NODES];
; 927  :   int list[MAX_NODES];
; 928  :   int numInList, numVisited;
; 929  :   memset(listed,0,4*MAX_NODES);

  0002b	68 b8 01 00 00	 push	 440			; 000001b8H
  00030	6a 00		 push	 0
  00032	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR _listed$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _memset
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 930  :   for (i=0; i<MAX_NODES; i++) distances[i] = 9999999;

  00041	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00048	eb 09		 jmp	 SHORT $LN4@FindDistan
$LN2@FindDistan:
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0004d	83 c1 01	 add	 ecx, 1
  00050	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@FindDistan:
  00053	83 7d f4 6e	 cmp	 DWORD PTR _i$[ebp], 110	; 0000006eH
  00057	7d 0f		 jge	 SHORT $LN3@FindDistan
  00059	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  0005c	8b 45 0c	 mov	 eax, DWORD PTR _distances$[ebp]
  0005f	c7 04 90 7f 96
	98 00		 mov	 DWORD PTR [eax+edx*4], 9999999 ; 0098967fH
  00066	eb e2		 jmp	 SHORT $LN2@FindDistan
$LN3@FindDistan:

; 931  :   numInList = 0;

  00068	c7 85 70 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _numInList$[ebp], 0
$LN5@FindDistan:

; 932  :   while (*src >= 0)

  00072	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  00075	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00078	0f 8c ba 00 00
	00		 jl	 $LN6@FindDistan

; 933  :   {
; 934  :     int j;
; 935  :     for (j=0; j<m_numPartners[*src]; j++)

  0007e	c7 85 68 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$7[ebp], 0
  00088	eb 0f		 jmp	 SHORT $LN9@FindDistan
$LN7@FindDistan:
  0008a	8b 95 68 fc ff
	ff		 mov	 edx, DWORD PTR _j$7[ebp]
  00090	83 c2 01	 add	 edx, 1
  00093	89 95 68 fc ff
	ff		 mov	 DWORD PTR _j$7[ebp], edx
$LN9@FindDistan:
  00099	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000a1	8b 85 68 fc ff
	ff		 mov	 eax, DWORD PTR _j$7[ebp]
  000a7	3b 44 8a 10	 cmp	 eax, DWORD PTR [edx+ecx*4+16]
  000ab	7d 7d		 jge	 SHORT $LN8@FindDistan

; 936  :     {
; 937  :       int partner;
; 938  :       partner = m_partners[m_1stPartner[*src]+j];

  000ad	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b5	8b 8c 90 c8 01
	00 00		 mov	 ecx, DWORD PTR [eax+edx*4+456]
  000bc	03 8d 68 fc ff
	ff		 add	 ecx, DWORD PTR _j$7[ebp]
  000c2	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000c5	8b 84 8a d0 0d
	00 00		 mov	 eax, DWORD PTR [edx+ecx*4+3536]
  000cc	89 85 64 fc ff
	ff		 mov	 DWORD PTR _partner$6[ebp], eax

; 939  :       if (listed[partner] == 0)

  000d2	8b 8d 64 fc ff
	ff		 mov	 ecx, DWORD PTR _partner$6[ebp]
  000d8	83 bc 8d 38 fe
	ff ff 00	 cmp	 DWORD PTR _listed$[ebp+ecx*4], 0
  000e0	75 43		 jne	 SHORT $LN18@FindDistan

; 940  :       {
; 941  :         list[numInList++] = partner;

  000e2	8b 95 70 fc ff
	ff		 mov	 edx, DWORD PTR _numInList$[ebp]
  000e8	8b 85 64 fc ff
	ff		 mov	 eax, DWORD PTR _partner$6[ebp]
  000ee	89 84 95 78 fc
	ff ff		 mov	 DWORD PTR _list$[ebp+edx*4], eax
  000f5	8b 8d 70 fc ff
	ff		 mov	 ecx, DWORD PTR _numInList$[ebp]
  000fb	83 c1 01	 add	 ecx, 1
  000fe	89 8d 70 fc ff
	ff		 mov	 DWORD PTR _numInList$[ebp], ecx

; 942  :         listed[partner] = 1;

  00104	8b 95 64 fc ff
	ff		 mov	 edx, DWORD PTR _partner$6[ebp]
  0010a	c7 84 95 38 fe
	ff ff 01 00 00
	00		 mov	 DWORD PTR _listed$[ebp+edx*4], 1

; 943  :         distances[partner] = 0;

  00115	8b 85 64 fc ff
	ff		 mov	 eax, DWORD PTR _partner$6[ebp]
  0011b	8b 4d 0c	 mov	 ecx, DWORD PTR _distances$[ebp]
  0011e	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*4], 0
$LN18@FindDistan:

; 944  :       };
; 945  :     };

  00125	e9 60 ff ff ff	 jmp	 $LN7@FindDistan
$LN8@FindDistan:

; 946  :     src++;

  0012a	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  0012d	83 c2 04	 add	 edx, 4
  00130	89 55 08	 mov	 DWORD PTR _src$[ebp], edx

; 947  :   };

  00133	e9 3a ff ff ff	 jmp	 $LN5@FindDistan
$LN6@FindDistan:

; 948  :   numVisited = 0;

  00138	c7 85 6c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _numVisited$[ebp], 0
$LN10@FindDistan:

; 949  :   while (numVisited < numInList)

  00142	8b 85 6c fc ff
	ff		 mov	 eax, DWORD PTR _numVisited$[ebp]
  00148	3b 85 70 fc ff
	ff		 cmp	 eax, DWORD PTR _numInList$[ebp]
  0014e	0f 8d 42 01 00
	00		 jge	 $LN1@FindDistan

; 950  :   {
; 951  :     int i, pointNum;
; 952  :     pointNum = list[numVisited++];

  00154	8b 8d 6c fc ff
	ff		 mov	 ecx, DWORD PTR _numVisited$[ebp]
  0015a	8b 94 8d 78 fc
	ff ff		 mov	 edx, DWORD PTR _list$[ebp+ecx*4]
  00161	89 95 5c fc ff
	ff		 mov	 DWORD PTR _pointNum$4[ebp], edx
  00167	8b 85 6c fc ff
	ff		 mov	 eax, DWORD PTR _numVisited$[ebp]
  0016d	83 c0 01	 add	 eax, 1
  00170	89 85 6c fc ff
	ff		 mov	 DWORD PTR _numVisited$[ebp], eax

; 953  :     for (i=0; i<m_numNeighbors[pointNum]; i++)

  00176	c7 85 60 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$5[ebp], 0
  00180	eb 0f		 jmp	 SHORT $LN14@FindDistan
$LN12@FindDistan:
  00182	8b 8d 60 fc ff
	ff		 mov	 ecx, DWORD PTR _i$5[ebp]
  00188	83 c1 01	 add	 ecx, 1
  0018b	89 8d 60 fc ff
	ff		 mov	 DWORD PTR _i$5[ebp], ecx
$LN14@FindDistan:
  00191	8b 95 5c fc ff
	ff		 mov	 edx, DWORD PTR _pointNum$4[ebp]
  00197	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0019a	8b 8d 60 fc ff
	ff		 mov	 ecx, DWORD PTR _i$5[ebp]
  001a0	3b 8c 90 80 03
	00 00		 cmp	 ecx, DWORD PTR [eax+edx*4+896]
  001a7	0f 8d e4 00 00
	00		 jge	 $LN13@FindDistan

; 954  :     {
; 955  :       int neighbor;
; 956  :       neighbor = m_neighbors[m_1stNeighbor[pointNum]+i];

  001ad	8b 95 5c fc ff
	ff		 mov	 edx, DWORD PTR _pointNum$4[ebp]
  001b3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001b6	8b 8c 90 38 05
	00 00		 mov	 ecx, DWORD PTR [eax+edx*4+1336]
  001bd	03 8d 60 fc ff
	ff		 add	 ecx, DWORD PTR _i$5[ebp]
  001c3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001c6	8b 84 8a f0 06
	00 00		 mov	 eax, DWORD PTR [edx+ecx*4+1776]
  001cd	89 85 58 fc ff
	ff		 mov	 DWORD PTR _neighbor$3[ebp], eax

; 957  :       if (distances[neighbor] > distances[pointNum]+1) 

  001d3	8b 8d 5c fc ff
	ff		 mov	 ecx, DWORD PTR _pointNum$4[ebp]
  001d9	8b 55 0c	 mov	 edx, DWORD PTR _distances$[ebp]
  001dc	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  001df	83 c0 01	 add	 eax, 1
  001e2	8b 8d 58 fc ff
	ff		 mov	 ecx, DWORD PTR _neighbor$3[ebp]
  001e8	8b 55 0c	 mov	 edx, DWORD PTR _distances$[ebp]
  001eb	39 04 8a	 cmp	 DWORD PTR [edx+ecx*4], eax
  001ee	0f 8e 98 00 00
	00		 jle	 $LN19@FindDistan

; 958  :       {
; 959  :         int j;
; 960  :         for (j=0; j<m_numPartners[neighbor]; j++)

  001f4	c7 85 54 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$2[ebp], 0
  001fe	eb 0f		 jmp	 SHORT $LN17@FindDistan
$LN15@FindDistan:
  00200	8b 85 54 fc ff
	ff		 mov	 eax, DWORD PTR _j$2[ebp]
  00206	83 c0 01	 add	 eax, 1
  00209	89 85 54 fc ff
	ff		 mov	 DWORD PTR _j$2[ebp], eax
$LN17@FindDistan:
  0020f	8b 8d 58 fc ff
	ff		 mov	 ecx, DWORD PTR _neighbor$3[ebp]
  00215	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00218	8b 85 54 fc ff
	ff		 mov	 eax, DWORD PTR _j$2[ebp]
  0021e	3b 44 8a 10	 cmp	 eax, DWORD PTR [edx+ecx*4+16]
  00222	7d 68		 jge	 SHORT $LN19@FindDistan

; 961  :         {
; 962  :           int neighborPoint;
; 963  :           neighborPoint = m_partners[m_1stPartner[neighbor] + j];

  00224	8b 8d 58 fc ff
	ff		 mov	 ecx, DWORD PTR _neighbor$3[ebp]
  0022a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0022d	8b 84 8a c8 01
	00 00		 mov	 eax, DWORD PTR [edx+ecx*4+456]
  00234	03 85 54 fc ff
	ff		 add	 eax, DWORD PTR _j$2[ebp]
  0023a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0023d	8b 94 81 d0 0d
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+3536]
  00244	89 95 50 fc ff
	ff		 mov	 DWORD PTR _neighborPoint$1[ebp], edx

; 964  :           distances[neighborPoint] = distances[pointNum] + 1;

  0024a	8b 85 5c fc ff
	ff		 mov	 eax, DWORD PTR _pointNum$4[ebp]
  00250	8b 4d 0c	 mov	 ecx, DWORD PTR _distances$[ebp]
  00253	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00256	83 c2 01	 add	 edx, 1
  00259	8b 85 50 fc ff
	ff		 mov	 eax, DWORD PTR _neighborPoint$1[ebp]
  0025f	8b 4d 0c	 mov	 ecx, DWORD PTR _distances$[ebp]
  00262	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 965  :           list[numInList++] = neighborPoint;

  00265	8b 95 70 fc ff
	ff		 mov	 edx, DWORD PTR _numInList$[ebp]
  0026b	8b 85 50 fc ff
	ff		 mov	 eax, DWORD PTR _neighborPoint$1[ebp]
  00271	89 84 95 78 fc
	ff ff		 mov	 DWORD PTR _list$[ebp+edx*4], eax
  00278	8b 8d 70 fc ff
	ff		 mov	 ecx, DWORD PTR _numInList$[ebp]
  0027e	83 c1 01	 add	 ecx, 1
  00281	89 8d 70 fc ff
	ff		 mov	 DWORD PTR _numInList$[ebp], ecx

; 966  :         };

  00287	e9 74 ff ff ff	 jmp	 $LN15@FindDistan
$LN19@FindDistan:

; 967  :       };
; 968  :     };

  0028c	e9 f1 fe ff ff	 jmp	 $LN12@FindDistan
$LN13@FindDistan:

; 969  :   };

  00291	e9 ac fe ff ff	 jmp	 $LN10@FindDistan
$LN1@FindDistan:

; 970  : }

  00296	52		 push	 edx
  00297	8b cd		 mov	 ecx, ebp
  00299	50		 push	 eax
  0029a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN24@FindDistan
  002a0	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002a5	58		 pop	 eax
  002a6	5a		 pop	 edx
  002a7	5f		 pop	 edi
  002a8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ab	33 cd		 xor	 ecx, ebp
  002ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b2	81 c4 b0 03 00
	00		 add	 esp, 944		; 000003b0H
  002b8	3b ec		 cmp	 ebp, esp
  002ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002bf	8b e5		 mov	 esp, ebp
  002c1	5d		 pop	 ebp
  002c2	c2 08 00	 ret	 8
  002c5	0f 1f 00	 npad	 3
$LN24@FindDistan:
  002c8	02 00 00 00	 DD	 2
  002cc	00 00 00 00	 DD	 $LN23@FindDistan
$LN23@FindDistan:
  002d0	38 fe ff ff	 DD	 -456			; fffffe38H
  002d4	b8 01 00 00	 DD	 440			; 000001b8H
  002d8	00 00 00 00	 DD	 $LN21@FindDistan
  002dc	78 fc ff ff	 DD	 -904			; fffffc78H
  002e0	b8 01 00 00	 DD	 440			; 000001b8H
  002e4	00 00 00 00	 DD	 $LN22@FindDistan
$LN22@FindDistan:
  002e8	6c		 DB	 108			; 0000006cH
  002e9	69		 DB	 105			; 00000069H
  002ea	73		 DB	 115			; 00000073H
  002eb	74		 DB	 116			; 00000074H
  002ec	00		 DB	 0
$LN21@FindDistan:
  002ed	6c		 DB	 108			; 0000006cH
  002ee	69		 DB	 105			; 00000069H
  002ef	73		 DB	 115			; 00000073H
  002f0	74		 DB	 116			; 00000074H
  002f1	65		 DB	 101			; 00000065H
  002f2	64		 DB	 100			; 00000064H
  002f3	00		 DB	 0
?FindDistances@DIVIDE_3@@AAEXPAH0@Z ENDP		; DIVIDE_3::FindDistances
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
_y$ = -12						; size = 4
_x$ = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
_pointNum$ = 12						; size = 4
?FindNeighbors@DIVIDE_3@@AAEXHH@Z PROC			; DIVIDE_3::FindNeighbors
; _this$ = ecx

; 856  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 857  :   //Add all neighbors of pointNum to list at index.
; 858  :   //This is pretty easy.  We just look in the four directions.
; 859  :   int x, y;
; 860  :   y = pointNum / m_width;

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	8b 45 0c	 mov	 eax, DWORD PTR _pointNum$[ebp]
  00024	99		 cdq
  00025	f7 79 04	 idiv	 DWORD PTR [ecx+4]
  00028	89 45 f4	 mov	 DWORD PTR _y$[ebp], eax

; 861  :   x = pointNum % m_width;

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8b 45 0c	 mov	 eax, DWORD PTR _pointNum$[ebp]
  00031	99		 cdq
  00032	f7 79 04	 idiv	 DWORD PTR [ecx+4]
  00035	89 55 f8	 mov	 DWORD PTR _x$[ebp], edx

; 862  :   if (x < m_width-1)

  00038	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003e	83 e8 01	 sub	 eax, 1
  00041	39 45 f8	 cmp	 DWORD PTR _x$[ebp], eax
  00044	7d 64		 jge	 SHORT $LN2@FindNeighb

; 863  :   {
; 864  :     if ((m_pDB->AvoidFlag(x, y, false) & (AV_PERIMETER|AV_OCCUPIED|AV_SACRIFICE)) == 0)

  00046	6a 00		 push	 0
  00048	8b 4d f4	 mov	 ecx, DWORD PTR _y$[ebp]
  0004b	51		 push	 ecx
  0004c	8b 55 f8	 mov	 edx, DWORD PTR _x$[ebp]
  0004f	52		 push	 edx
  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 08		 mov	 ecx, DWORD PTR [eax]
  00055	e8 00 00 00 00	 call	 ?AvoidFlag@DOTS_AND_BOXES@@QBEHHH_N@Z ; DOTS_AND_BOXES::AvoidFlag
  0005a	83 e0 07	 and	 eax, 7
  0005d	75 4b		 jne	 SHORT $LN2@FindNeighb

; 865  :     {
; 866  :       m_neighbors[m_totalNeighbors++] = pointNum+1;

  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR _pointNum$[ebp]
  00062	83 c1 01	 add	 ecx, 1
  00065	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00068	8b 82 e4 ca 00
	00		 mov	 eax, DWORD PTR [edx+51940]
  0006e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00071	89 8c 82 f0 06
	00 00		 mov	 DWORD PTR [edx+eax*4+1776], ecx
  00078	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 88 e4 ca 00
	00		 mov	 ecx, DWORD PTR [eax+51940]
  00081	83 c1 01	 add	 ecx, 1
  00084	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00087	89 8a e4 ca 00
	00		 mov	 DWORD PTR [edx+51940], ecx

; 867  :       m_numNeighbors[index]++;

  0008d	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00090	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	8b 94 81 80 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+896]
  0009a	83 c2 01	 add	 edx, 1
  0009d	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  000a0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	89 94 81 80 03
	00 00		 mov	 DWORD PTR [ecx+eax*4+896], edx
$LN2@FindNeighb:

; 868  :     };
; 869  :   };
; 870  :   if (x > 0)

  000aa	83 7d f8 00	 cmp	 DWORD PTR _x$[ebp], 0
  000ae	7e 67		 jle	 SHORT $LN4@FindNeighb

; 871  :   {
; 872  :     if ((m_pDB->AvoidFlag(x-1, y, false) & (AV_PERIMETER|AV_OCCUPIED|AV_SACRIFICE)) == 0)

  000b0	6a 00		 push	 0
  000b2	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  000b5	52		 push	 edx
  000b6	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  000b9	83 e8 01	 sub	 eax, 1
  000bc	50		 push	 eax
  000bd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000c2	e8 00 00 00 00	 call	 ?AvoidFlag@DOTS_AND_BOXES@@QBEHHH_N@Z ; DOTS_AND_BOXES::AvoidFlag
  000c7	83 e0 07	 and	 eax, 7
  000ca	75 4b		 jne	 SHORT $LN4@FindNeighb

; 873  :     {
; 874  :       m_neighbors[m_totalNeighbors++] = pointNum-1;

  000cc	8b 55 0c	 mov	 edx, DWORD PTR _pointNum$[ebp]
  000cf	83 ea 01	 sub	 edx, 1
  000d2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d5	8b 88 e4 ca 00
	00		 mov	 ecx, DWORD PTR [eax+51940]
  000db	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000de	89 94 88 f0 06
	00 00		 mov	 DWORD PTR [eax+ecx*4+1776], edx
  000e5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e8	8b 91 e4 ca 00
	00		 mov	 edx, DWORD PTR [ecx+51940]
  000ee	83 c2 01	 add	 edx, 1
  000f1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f4	89 90 e4 ca 00
	00		 mov	 DWORD PTR [eax+51940], edx

; 875  :       m_numNeighbors[index]++;

  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  000fd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00100	8b 84 8a 80 03
	00 00		 mov	 eax, DWORD PTR [edx+ecx*4+896]
  00107	83 c0 01	 add	 eax, 1
  0010a	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  0010d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00110	89 84 8a 80 03
	00 00		 mov	 DWORD PTR [edx+ecx*4+896], eax
$LN4@FindNeighb:

; 876  :     };
; 877  :   };
; 878  :   if (y < m_height-1)

  00117	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0011d	83 e9 01	 sub	 ecx, 1
  00120	39 4d f4	 cmp	 DWORD PTR _y$[ebp], ecx
  00123	7d 67		 jge	 SHORT $LN6@FindNeighb

; 879  :   {
; 880  :     if ((m_pDB->AvoidFlag(x, y, true) & (AV_PERIMETER|AV_OCCUPIED|AV_SACRIFICE)) == 0)

  00125	6a 01		 push	 1
  00127	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  0012a	52		 push	 edx
  0012b	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  0012e	50		 push	 eax
  0012f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00132	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00134	e8 00 00 00 00	 call	 ?AvoidFlag@DOTS_AND_BOXES@@QBEHHH_N@Z ; DOTS_AND_BOXES::AvoidFlag
  00139	83 e0 07	 and	 eax, 7
  0013c	75 4e		 jne	 SHORT $LN6@FindNeighb

; 881  :     {
; 882  :       m_neighbors[m_totalNeighbors++] = pointNum+m_width;

  0013e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00141	8b 45 0c	 mov	 eax, DWORD PTR _pointNum$[ebp]
  00144	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00147	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0014a	8b 91 e4 ca 00
	00		 mov	 edx, DWORD PTR [ecx+51940]
  00150	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00153	89 84 91 f0 06
	00 00		 mov	 DWORD PTR [ecx+edx*4+1776], eax
  0015a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0015d	8b 82 e4 ca 00
	00		 mov	 eax, DWORD PTR [edx+51940]
  00163	83 c0 01	 add	 eax, 1
  00166	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00169	89 81 e4 ca 00
	00		 mov	 DWORD PTR [ecx+51940], eax

; 883  :       m_numNeighbors[index]++;

  0016f	8b 55 08	 mov	 edx, DWORD PTR _index$[ebp]
  00172	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00175	8b 8c 90 80 03
	00 00		 mov	 ecx, DWORD PTR [eax+edx*4+896]
  0017c	83 c1 01	 add	 ecx, 1
  0017f	8b 55 08	 mov	 edx, DWORD PTR _index$[ebp]
  00182	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00185	89 8c 90 80 03
	00 00		 mov	 DWORD PTR [eax+edx*4+896], ecx
$LN6@FindNeighb:

; 884  :     };
; 885  :   };
; 886  :   if (y > 0)

  0018c	83 7d f4 00	 cmp	 DWORD PTR _y$[ebp], 0
  00190	7e 6a		 jle	 SHORT $LN1@FindNeighb

; 887  :   {
; 888  :     if ((m_pDB->AvoidFlag(x, y-1, true) & (AV_PERIMETER|AV_OCCUPIED|AV_SACRIFICE)) == 0)

  00192	6a 01		 push	 1
  00194	8b 4d f4	 mov	 ecx, DWORD PTR _y$[ebp]
  00197	83 e9 01	 sub	 ecx, 1
  0019a	51		 push	 ecx
  0019b	8b 55 f8	 mov	 edx, DWORD PTR _x$[ebp]
  0019e	52		 push	 edx
  0019f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a4	e8 00 00 00 00	 call	 ?AvoidFlag@DOTS_AND_BOXES@@QBEHHH_N@Z ; DOTS_AND_BOXES::AvoidFlag
  001a9	83 e0 07	 and	 eax, 7
  001ac	75 4e		 jne	 SHORT $LN1@FindNeighb

; 889  :     {
; 890  :       m_neighbors[m_totalNeighbors++] = pointNum-m_width;

  001ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b1	8b 55 0c	 mov	 edx, DWORD PTR _pointNum$[ebp]
  001b4	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  001b7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001ba	8b 88 e4 ca 00
	00		 mov	 ecx, DWORD PTR [eax+51940]
  001c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001c3	89 94 88 f0 06
	00 00		 mov	 DWORD PTR [eax+ecx*4+1776], edx
  001ca	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001cd	8b 91 e4 ca 00
	00		 mov	 edx, DWORD PTR [ecx+51940]
  001d3	83 c2 01	 add	 edx, 1
  001d6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001d9	89 90 e4 ca 00
	00		 mov	 DWORD PTR [eax+51940], edx

; 891  :       m_numNeighbors[index]++;

  001df	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  001e2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001e5	8b 84 8a 80 03
	00 00		 mov	 eax, DWORD PTR [edx+ecx*4+896]
  001ec	83 c0 01	 add	 eax, 1
  001ef	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  001f2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001f5	89 84 8a 80 03
	00 00		 mov	 DWORD PTR [edx+ecx*4+896], eax
$LN1@FindNeighb:

; 892  :     };
; 893  :   };
; 894  : }

  001fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ff	3b ec		 cmp	 ebp, esp
  00201	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00206	8b e5		 mov	 esp, ebp
  00208	5d		 pop	 ebp
  00209	c2 08 00	 ret	 8
?FindNeighbors@DIVIDE_3@@AAEXHH@Z ENDP			; DIVIDE_3::FindNeighbors
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
_y$ = -16						; size = 4
_x$ = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
_pointNum$ = 12						; size = 4
?AddPartner@DIVIDE_3@@AAEXHH@Z PROC			; DIVIDE_3::AddPartner
; _this$ = ecx

; 813  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 814  :   //Add all partners of pointNum to list at index.
; 815  :   int i, x, y;
; 816  :   for (i=0; i<m_numPartners[index]; i++)

  0001a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00021	eb 09		 jmp	 SHORT $LN4@AddPartner
$LN2@AddPartner:
  00023	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00026	83 c0 01	 add	 eax, 1
  00029	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@AddPartner:
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  0002f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00032	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00035	3b 44 8a 10	 cmp	 eax, DWORD PTR [edx+ecx*4+16]
  00039	7d 26		 jge	 SHORT $LN3@AddPartner

; 817  :   {
; 818  :     if (m_partners[m_1stPartner[index]+i] == pointNum) return; //Already in list

  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  0003e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00041	8b 84 8a c8 01
	00 00		 mov	 eax, DWORD PTR [edx+ecx*4+456]
  00048	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	8b 94 81 d0 0d
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+3536]
  00055	3b 55 0c	 cmp	 edx, DWORD PTR _pointNum$[ebp]
  00058	75 05		 jne	 SHORT $LN5@AddPartner
  0005a	e9 36 01 00 00	 jmp	 $LN1@AddPartner
$LN5@AddPartner:

; 819  :   };

  0005f	eb c2		 jmp	 SHORT $LN2@AddPartner
$LN3@AddPartner:

; 820  :   m_partners[m_totalPartners++] = pointNum;

  00061	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00064	8b 88 e0 ca 00
	00		 mov	 ecx, DWORD PTR [eax+51936]
  0006a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	8b 45 0c	 mov	 eax, DWORD PTR _pointNum$[ebp]
  00070	89 84 8a d0 0d
	00 00		 mov	 DWORD PTR [edx+ecx*4+3536], eax
  00077	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 91 e0 ca 00
	00		 mov	 edx, DWORD PTR [ecx+51936]
  00080	83 c2 01	 add	 edx, 1
  00083	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00086	89 90 e0 ca 00
	00		 mov	 DWORD PTR [eax+51936], edx

; 821  :   m_numPartners[index]++;

  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  0008f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00092	8b 44 8a 10	 mov	 eax, DWORD PTR [edx+ecx*4+16]
  00096	83 c0 01	 add	 eax, 1
  00099	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  0009c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009f	89 44 8a 10	 mov	 DWORD PTR [edx+ecx*4+16], eax

; 822  :   y = pointNum / m_width;

  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 45 0c	 mov	 eax, DWORD PTR _pointNum$[ebp]
  000a9	99		 cdq
  000aa	f7 79 04	 idiv	 DWORD PTR [ecx+4]
  000ad	89 45 f0	 mov	 DWORD PTR _y$[ebp], eax

; 823  :   x = pointNum % m_width;

  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	8b 45 0c	 mov	 eax, DWORD PTR _pointNum$[ebp]
  000b6	99		 cdq
  000b7	f7 79 04	 idiv	 DWORD PTR [ecx+4]
  000ba	89 55 f4	 mov	 DWORD PTR _x$[ebp], edx

; 824  :   if (x < m_width-1)

  000bd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c0	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c3	83 e8 01	 sub	 eax, 1
  000c6	39 45 f4	 cmp	 DWORD PTR _x$[ebp], eax
  000c9	7d 29		 jge	 SHORT $LN6@AddPartner

; 825  :   {
; 826  :     if (m_pDB->HLineType(x, y) != LINE_NONE)

  000cb	8b 4d f0	 mov	 ecx, DWORD PTR _y$[ebp]
  000ce	51		 push	 ecx
  000cf	8b 55 f4	 mov	 edx, DWORD PTR _x$[ebp]
  000d2	52		 push	 edx
  000d3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d8	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  000dd	85 c0		 test	 eax, eax
  000df	74 13		 je	 SHORT $LN6@AddPartner

; 827  :     {
; 828  :       AddPartner(index, pointNum+1);

  000e1	8b 4d 0c	 mov	 ecx, DWORD PTR _pointNum$[ebp]
  000e4	83 c1 01	 add	 ecx, 1
  000e7	51		 push	 ecx
  000e8	8b 55 08	 mov	 edx, DWORD PTR _index$[ebp]
  000eb	52		 push	 edx
  000ec	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ef	e8 00 00 00 00	 call	 ?AddPartner@DIVIDE_3@@AAEXHH@Z ; DIVIDE_3::AddPartner
$LN6@AddPartner:

; 829  :     };
; 830  :   };
; 831  :   if (x > 0)

  000f4	83 7d f4 00	 cmp	 DWORD PTR _x$[ebp], 0
  000f8	7e 2c		 jle	 SHORT $LN8@AddPartner

; 832  :   {
; 833  :     if (m_pDB->HLineType(x-1, y) != LINE_NONE)

  000fa	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  000fd	50		 push	 eax
  000fe	8b 4d f4	 mov	 ecx, DWORD PTR _x$[ebp]
  00101	83 e9 01	 sub	 ecx, 1
  00104	51		 push	 ecx
  00105	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00108	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0010a	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  0010f	85 c0		 test	 eax, eax
  00111	74 13		 je	 SHORT $LN8@AddPartner

; 834  :     {
; 835  :       AddPartner(index, pointNum-1);

  00113	8b 45 0c	 mov	 eax, DWORD PTR _pointNum$[ebp]
  00116	83 e8 01	 sub	 eax, 1
  00119	50		 push	 eax
  0011a	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  0011d	51		 push	 ecx
  0011e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00121	e8 00 00 00 00	 call	 ?AddPartner@DIVIDE_3@@AAEXHH@Z ; DIVIDE_3::AddPartner
$LN8@AddPartner:

; 836  :     };
; 837  :   };
; 838  :   if (y < m_height-1)

  00126	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00129	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0012c	83 e8 01	 sub	 eax, 1
  0012f	39 45 f0	 cmp	 DWORD PTR _y$[ebp], eax
  00132	7d 2c		 jge	 SHORT $LN10@AddPartner

; 839  :   {
; 840  :     if (m_pDB->VLineType(x, y) != LINE_NONE)

  00134	8b 4d f0	 mov	 ecx, DWORD PTR _y$[ebp]
  00137	51		 push	 ecx
  00138	8b 55 f4	 mov	 edx, DWORD PTR _x$[ebp]
  0013b	52		 push	 edx
  0013c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0013f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00141	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  00146	85 c0		 test	 eax, eax
  00148	74 16		 je	 SHORT $LN10@AddPartner

; 841  :     {
; 842  :       AddPartner(index, pointNum+m_width);

  0014a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0014d	8b 55 0c	 mov	 edx, DWORD PTR _pointNum$[ebp]
  00150	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00153	52		 push	 edx
  00154	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00157	50		 push	 eax
  00158	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015b	e8 00 00 00 00	 call	 ?AddPartner@DIVIDE_3@@AAEXHH@Z ; DIVIDE_3::AddPartner
$LN10@AddPartner:

; 843  :     };
; 844  :   };
; 845  :   if (y > 0)

  00160	83 7d f0 00	 cmp	 DWORD PTR _y$[ebp], 0
  00164	7e 2f		 jle	 SHORT $LN1@AddPartner

; 846  :   {
; 847  :     if (m_pDB->VLineType(x, y-1) != LINE_NONE)

  00166	8b 4d f0	 mov	 ecx, DWORD PTR _y$[ebp]
  00169	83 e9 01	 sub	 ecx, 1
  0016c	51		 push	 ecx
  0016d	8b 55 f4	 mov	 edx, DWORD PTR _x$[ebp]
  00170	52		 push	 edx
  00171	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00174	8b 08		 mov	 ecx, DWORD PTR [eax]
  00176	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  0017b	85 c0		 test	 eax, eax
  0017d	74 16		 je	 SHORT $LN1@AddPartner

; 848  :     {
; 849  :       AddPartner(index, pointNum-m_width);

  0017f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00182	8b 55 0c	 mov	 edx, DWORD PTR _pointNum$[ebp]
  00185	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  00188	52		 push	 edx
  00189	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0018c	50		 push	 eax
  0018d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00190	e8 00 00 00 00	 call	 ?AddPartner@DIVIDE_3@@AAEXHH@Z ; DIVIDE_3::AddPartner
$LN1@AddPartner:

; 850  :     };
; 851  :   };
; 852  : }

  00195	83 c4 10	 add	 esp, 16			; 00000010H
  00198	3b ec		 cmp	 ebp, esp
  0019a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0019f	8b e5		 mov	 esp, ebp
  001a1	5d		 pop	 ebp
  001a2	c2 08 00	 ret	 8
?AddPartner@DIVIDE_3@@AAEXHH@Z ENDP			; DIVIDE_3::AddPartner
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
_result$ = -24						; size = 8
_numEdge$ = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?MinMaxDivideWeight@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ PROC ; DOTS_AND_BOXES::MinMaxDivideWeight
; _this$ = ecx

; 1093 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1094 :   int i, numEdge;
; 1095 :   POINT result;
; 1096 :   result.x = 99999999;

  00023	c7 45 e8 ff e0
	f5 05		 mov	 DWORD PTR _result$[ebp], 99999999 ; 05f5e0ffH

; 1097 :   result.y = 0;

  0002a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _result$[ebp+4], 0

; 1098 :   numEdge = m_width*(m_height-1) + m_height*(m_width-1);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00037	83 e9 01	 sub	 ecx, 1
  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	0f af 4a 10	 imul	 ecx, DWORD PTR [edx+16]
  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00047	83 ea 01	 sub	 edx, 1
  0004a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	0f af 50 14	 imul	 edx, DWORD PTR [eax+20]
  00051	03 ca		 add	 ecx, edx
  00053	89 4d f4	 mov	 DWORD PTR _numEdge$[ebp], ecx

; 1099 :   for (i=0; i<numEdge; i++)

  00056	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0005d	eb 09		 jmp	 SHORT $LN4@MinMaxDivi
$LN2@MinMaxDivi:
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00062	83 c1 01	 add	 ecx, 1
  00065	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@MinMaxDivi:
  00068	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0006b	3b 55 f4	 cmp	 edx, DWORD PTR _numEdge$[ebp]
  0006e	7d 4c		 jge	 SHORT $LN3@MinMaxDivi

; 1100 :   {
; 1101 :     if (    (m_divideAndConquerWeight[i] < result.x)
; 1102 :          && (m_divideAndConquerWeight[i] != 0)

  00070	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 08		 mov	 ecx, DWORD PTR [eax]
  00075	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00078	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0007b	3b 45 e8	 cmp	 eax, DWORD PTR _result$[ebp]
  0007e	7d 1c		 jge	 SHORT $LN5@MinMaxDivi
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	8b 11		 mov	 edx, DWORD PTR [ecx]
  00085	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00088	83 3c 82 00	 cmp	 DWORD PTR [edx+eax*4], 0
  0008c	74 0e		 je	 SHORT $LN5@MinMaxDivi

; 1103 :        )
; 1104 :     {
; 1105 :       result.x = m_divideAndConquerWeight[i];

  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	8b 11		 mov	 edx, DWORD PTR [ecx]
  00093	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00096	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  00099	89 4d e8	 mov	 DWORD PTR _result$[ebp], ecx
$LN5@MinMaxDivi:

; 1106 :     };
; 1107 :     if (m_divideAndConquerWeight[i] > result.y)

  0009c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009f	8b 02		 mov	 eax, DWORD PTR [edx]
  000a1	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000a4	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  000a7	3b 55 ec	 cmp	 edx, DWORD PTR _result$[ebp+4]
  000aa	7e 0e		 jle	 SHORT $LN6@MinMaxDivi

; 1108 :     {
; 1109 :       result.y = m_divideAndConquerWeight[i];

  000ac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000af	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b1	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000b4	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  000b7	89 45 ec	 mov	 DWORD PTR _result$[ebp+4], eax
$LN6@MinMaxDivi:

; 1110 :     };
; 1111 :   };

  000ba	eb a3		 jmp	 SHORT $LN2@MinMaxDivi
$LN3@MinMaxDivi:

; 1112 :   return result;

  000bc	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000bf	8b 55 e8	 mov	 edx, DWORD PTR _result$[ebp]
  000c2	8b 45 ec	 mov	 eax, DWORD PTR _result$[ebp+4]
  000c5	89 11		 mov	 DWORD PTR [ecx], edx
  000c7	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000ca	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1113 : }

  000cd	52		 push	 edx
  000ce	8b cd		 mov	 ecx, ebp
  000d0	50		 push	 eax
  000d1	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@MinMaxDivi
  000d7	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000dc	58		 pop	 eax
  000dd	5a		 pop	 edx
  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c2 04 00	 ret	 4
$LN10@MinMaxDivi:
  000e4	01 00 00 00	 DD	 1
  000e8	00 00 00 00	 DD	 $LN9@MinMaxDivi
$LN9@MinMaxDivi:
  000ec	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000f0	08 00 00 00	 DD	 8
  000f4	00 00 00 00	 DD	 $LN8@MinMaxDivi
$LN8@MinMaxDivi:
  000f8	72		 DB	 114			; 00000072H
  000f9	65		 DB	 101			; 00000065H
  000fa	73		 DB	 115			; 00000073H
  000fb	75		 DB	 117			; 00000075H
  000fc	6c		 DB	 108			; 0000006cH
  000fd	74		 DB	 116			; 00000074H
  000fe	00		 DB	 0
?MinMaxDivideWeight@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ ENDP ; DOTS_AND_BOXES::MinMaxDivideWeight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
_result$ = -24						; size = 8
_numEdge$ = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?MinMaxLoopWeight@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ PROC ; DOTS_AND_BOXES::MinMaxLoopWeight
; _this$ = ecx

; 1070 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1071 :   int i, numEdge;
; 1072 :   POINT result;
; 1073 :   result.x = 99999999;

  00023	c7 45 e8 ff e0
	f5 05		 mov	 DWORD PTR _result$[ebp], 99999999 ; 05f5e0ffH

; 1074 :   result.y = 0;

  0002a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _result$[ebp+4], 0

; 1075 :   numEdge = m_width*(m_height-1) + m_height*(m_width-1);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00037	83 e9 01	 sub	 ecx, 1
  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	0f af 4a 10	 imul	 ecx, DWORD PTR [edx+16]
  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00047	83 ea 01	 sub	 edx, 1
  0004a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	0f af 50 14	 imul	 edx, DWORD PTR [eax+20]
  00051	03 ca		 add	 ecx, edx
  00053	89 4d f4	 mov	 DWORD PTR _numEdge$[ebp], ecx

; 1076 :   for (i=0; i<numEdge; i++)

  00056	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0005d	eb 09		 jmp	 SHORT $LN4@MinMaxLoop
$LN2@MinMaxLoop:
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00062	83 c1 01	 add	 ecx, 1
  00065	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@MinMaxLoop:
  00068	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0006b	3b 55 f4	 cmp	 edx, DWORD PTR _numEdge$[ebp]
  0006e	7d 51		 jge	 SHORT $LN3@MinMaxLoop

; 1077 :   {
; 1078 :     if (    (m_breakUpLoopsWeight[i] < result.x)
; 1079 :          && (m_breakUpLoopsWeight[i] != 0)

  00070	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00076	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00079	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0007c	3b 45 e8	 cmp	 eax, DWORD PTR _result$[ebp]
  0007f	7d 1e		 jge	 SHORT $LN5@MinMaxLoop
  00081	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00087	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0008a	83 3c 82 00	 cmp	 DWORD PTR [edx+eax*4], 0
  0008e	74 0f		 je	 SHORT $LN5@MinMaxLoop

; 1080 :        )
; 1081 :     {
; 1082 :       result.x = m_breakUpLoopsWeight[i];

  00090	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00096	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00099	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  0009c	89 4d e8	 mov	 DWORD PTR _result$[ebp], ecx
$LN5@MinMaxLoop:

; 1083 :     };
; 1084 :     if (m_breakUpLoopsWeight[i] > result.y)

  0009f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a2	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000a5	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000a8	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  000ab	3b 55 ec	 cmp	 edx, DWORD PTR _result$[ebp+4]
  000ae	7e 0f		 jle	 SHORT $LN6@MinMaxLoop

; 1085 :     {
; 1086 :       result.y = m_breakUpLoopsWeight[i];

  000b0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b6	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000b9	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  000bc	89 45 ec	 mov	 DWORD PTR _result$[ebp+4], eax
$LN6@MinMaxLoop:

; 1087 :     };
; 1088 :   };

  000bf	eb 9e		 jmp	 SHORT $LN2@MinMaxLoop
$LN3@MinMaxLoop:

; 1089 :   return result;

  000c1	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000c4	8b 55 e8	 mov	 edx, DWORD PTR _result$[ebp]
  000c7	8b 45 ec	 mov	 eax, DWORD PTR _result$[ebp+4]
  000ca	89 11		 mov	 DWORD PTR [ecx], edx
  000cc	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000cf	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1090 : }

  000d2	52		 push	 edx
  000d3	8b cd		 mov	 ecx, ebp
  000d5	50		 push	 eax
  000d6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@MinMaxLoop
  000dc	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000e1	58		 pop	 eax
  000e2	5a		 pop	 edx
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 04 00	 ret	 4
  000e9	0f 1f 00	 npad	 3
$LN10@MinMaxLoop:
  000ec	01 00 00 00	 DD	 1
  000f0	00 00 00 00	 DD	 $LN9@MinMaxLoop
$LN9@MinMaxLoop:
  000f4	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000f8	08 00 00 00	 DD	 8
  000fc	00 00 00 00	 DD	 $LN8@MinMaxLoop
$LN8@MinMaxLoop:
  00100	72		 DB	 114			; 00000072H
  00101	65		 DB	 101			; 00000065H
  00102	73		 DB	 115			; 00000073H
  00103	75		 DB	 117			; 00000075H
  00104	6c		 DB	 108			; 0000006cH
  00105	74		 DB	 116			; 00000074H
  00106	00		 DB	 0
?MinMaxLoopWeight@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ ENDP ; DOTS_AND_BOXES::MinMaxLoopWeight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
_i$1 = -332						; size = 4
_weight$2 = -328					; size = 4
_count$3 = -324						; size = 4
_weight$4 = -320					; size = 4
_count$5 = -316						; size = 4
_vLine$6 = -312						; size = 4
_hLine$7 = -308						; size = 4
_weight$8 = -304					; size = 4
_count$9 = -300						; size = 4
_vLine$10 = -296					; size = 4
_hLine$11 = -292					; size = 4
_loopWeightMin$ = -284					; size = 241
_numEdge$ = -36						; size = 4
_height$ = -32						; size = 4
_width$ = -28						; size = 4
_dotNum$ = -20						; size = 8
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_MINLOOPBREAK$ = 8					; size = 4
?ComputeBreakUpLoopWeights@DOTS_AND_BOXES@@QAEXH@Z PROC	; DOTS_AND_BOXES::ComputeBreakUpLoopWeights
; _this$ = ecx

; 516  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00009	57		 push	 edi
  0000a	51		 push	 ecx
  0000b	8d bd b4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-332]
  00011	b9 53 00 00 00	 mov	 ecx, 83			; 00000053H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	59		 pop	 ecx
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 517  :   POINT dotNum;
; 518  :   int width, height, numEdge;
; 519  :   char loopWeightMin[MAX_EDGES];
; 520  :   if (!m_loopWeightsValid)

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  00032	85 c9		 test	 ecx, ecx
  00034	0f 85 8a 0c 00
	00		 jne	 $LN1@ComputeBre

; 521  :   {
; 522  :     width = Width();

  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?Width@DOTS_AND_BOXES@@QBEHXZ ; DOTS_AND_BOXES::Width
  00042	89 45 e4	 mov	 DWORD PTR _width$[ebp], eax

; 523  :     height = Height();

  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?Height@DOTS_AND_BOXES@@QBEHXZ ; DOTS_AND_BOXES::Height
  0004d	89 45 e0	 mov	 DWORD PTR _height$[ebp], eax

; 524  :     numEdge = width*(height-1) + height*(width-1);

  00050	8b 55 e0	 mov	 edx, DWORD PTR _height$[ebp]
  00053	83 ea 01	 sub	 edx, 1
  00056	0f af 55 e4	 imul	 edx, DWORD PTR _width$[ebp]
  0005a	8b 45 e4	 mov	 eax, DWORD PTR _width$[ebp]
  0005d	83 e8 01	 sub	 eax, 1
  00060	0f af 45 e0	 imul	 eax, DWORD PTR _height$[ebp]
  00064	03 d0		 add	 edx, eax
  00066	89 55 dc	 mov	 DWORD PTR _numEdge$[ebp], edx

; 525  :     memset(m_breakUpLoopsWeight,0,numEdge*sizeof(m_breakUpLoopsWeight[0]));

  00069	8b 4d dc	 mov	 ecx, DWORD PTR _numEdge$[ebp]
  0006c	c1 e1 02	 shl	 ecx, 2
  0006f	51		 push	 ecx
  00070	6a 00		 push	 0
  00072	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00075	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 _memset
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 526  :     memset(loopWeightMin, 0, numEdge);

  00081	8b 4d dc	 mov	 ecx, DWORD PTR _numEdge$[ebp]
  00084	51		 push	 ecx
  00085	6a 00		 push	 0
  00087	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _loopWeightMin$[ebp]
  0008d	52		 push	 edx
  0008e	e8 00 00 00 00	 call	 _memset
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH

; 527  :     for (dotNum.x=1; dotNum.x<width-1; dotNum.x++)

  00096	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _dotNum$[ebp], 1
  0009d	eb 09		 jmp	 SHORT $LN4@ComputeBre
$LN2@ComputeBre:
  0009f	8b 45 ec	 mov	 eax, DWORD PTR _dotNum$[ebp]
  000a2	83 c0 01	 add	 eax, 1
  000a5	89 45 ec	 mov	 DWORD PTR _dotNum$[ebp], eax
$LN4@ComputeBre:
  000a8	8b 4d e4	 mov	 ecx, DWORD PTR _width$[ebp]
  000ab	83 e9 01	 sub	 ecx, 1
  000ae	39 4d ec	 cmp	 DWORD PTR _dotNum$[ebp], ecx
  000b1	0f 8d 07 03 00
	00		 jge	 $LN3@ComputeBre

; 528  :     {
; 529  :       for (dotNum.y=1; dotNum.y<height-1; dotNum.y++)

  000b7	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _dotNum$[ebp+4], 1
  000be	eb 09		 jmp	 SHORT $LN7@ComputeBre
$LN5@ComputeBre:
  000c0	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp+4]
  000c3	83 c2 01	 add	 edx, 1
  000c6	89 55 f0	 mov	 DWORD PTR _dotNum$[ebp+4], edx
$LN7@ComputeBre:
  000c9	8b 45 e0	 mov	 eax, DWORD PTR _height$[ebp]
  000cc	83 e8 01	 sub	 eax, 1
  000cf	39 45 f0	 cmp	 DWORD PTR _dotNum$[ebp+4], eax
  000d2	0f 8d e1 02 00
	00		 jge	 $LN6@ComputeBre

; 530  :       {
; 531  :         int hLine, vLine, count;
; 532  :         if (HLineType(dotNum.x, dotNum.y) != LINE_NONE) continue;

  000d8	8b 4d f0	 mov	 ecx, DWORD PTR _dotNum$[ebp+4]
  000db	51		 push	 ecx
  000dc	8b 55 ec	 mov	 edx, DWORD PTR _dotNum$[ebp]
  000df	52		 push	 edx
  000e0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  000e8	85 c0		 test	 eax, eax
  000ea	74 02		 je	 SHORT $LN18@ComputeBre
  000ec	eb d2		 jmp	 SHORT $LN5@ComputeBre
$LN18@ComputeBre:

; 533  :         if (VLineType(dotNum.x, dotNum.y) != LINE_NONE) continue;

  000ee	8b 45 f0	 mov	 eax, DWORD PTR _dotNum$[ebp+4]
  000f1	50		 push	 eax
  000f2	8b 4d ec	 mov	 ecx, DWORD PTR _dotNum$[ebp]
  000f5	51		 push	 ecx
  000f6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f9	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  000fe	85 c0		 test	 eax, eax
  00100	74 02		 je	 SHORT $LN19@ComputeBre
  00102	eb bc		 jmp	 SHORT $LN5@ComputeBre
$LN19@ComputeBre:

; 534  :         if (HLineType(dotNum.x-1, dotNum.y) != LINE_NONE) continue;

  00104	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp+4]
  00107	52		 push	 edx
  00108	8b 45 ec	 mov	 eax, DWORD PTR _dotNum$[ebp]
  0010b	83 e8 01	 sub	 eax, 1
  0010e	50		 push	 eax
  0010f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00112	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  00117	85 c0		 test	 eax, eax
  00119	74 02		 je	 SHORT $LN20@ComputeBre
  0011b	eb a3		 jmp	 SHORT $LN5@ComputeBre
$LN20@ComputeBre:

; 535  :         if (VLineType(dotNum.x, dotNum.y-1) != LINE_NONE) continue;

  0011d	8b 4d f0	 mov	 ecx, DWORD PTR _dotNum$[ebp+4]
  00120	83 e9 01	 sub	 ecx, 1
  00123	51		 push	 ecx
  00124	8b 55 ec	 mov	 edx, DWORD PTR _dotNum$[ebp]
  00127	52		 push	 edx
  00128	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0012b	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  00130	85 c0		 test	 eax, eax
  00132	74 02		 je	 SHORT $LN21@ComputeBre
  00134	eb 8a		 jmp	 SHORT $LN5@ComputeBre
$LN21@ComputeBre:

; 536  :         hLine = dotNum.y*(2*width-1) + dotNum.x;

  00136	8b 45 e4	 mov	 eax, DWORD PTR _width$[ebp]
  00139	8d 4c 00 ff	 lea	 ecx, DWORD PTR [eax+eax-1]
  0013d	0f af 4d f0	 imul	 ecx, DWORD PTR _dotNum$[ebp+4]
  00141	03 4d ec	 add	 ecx, DWORD PTR _dotNum$[ebp]
  00144	89 8d dc fe ff
	ff		 mov	 DWORD PTR _hLine$11[ebp], ecx

; 537  :         vLine = hLine + width - 1;

  0014a	8b 55 e4	 mov	 edx, DWORD PTR _width$[ebp]
  0014d	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _hLine$11[ebp]
  00153	8d 4c 10 ff	 lea	 ecx, DWORD PTR [eax+edx-1]
  00157	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _vLine$10[ebp], ecx

; 538  :         //Count Lines around this point
; 539  :         count = 1;

  0015d	c7 85 d4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _count$9[ebp], 1

; 540  :         if (HLineType(dotNum.x-1, dotNum.y-1) != LINE_NONE) count++;

  00167	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp+4]
  0016a	83 ea 01	 sub	 edx, 1
  0016d	52		 push	 edx
  0016e	8b 45 ec	 mov	 eax, DWORD PTR _dotNum$[ebp]
  00171	83 e8 01	 sub	 eax, 1
  00174	50		 push	 eax
  00175	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00178	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  0017d	85 c0		 test	 eax, eax
  0017f	74 0f		 je	 SHORT $LN22@ComputeBre
  00181	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _count$9[ebp]
  00187	83 c1 01	 add	 ecx, 1
  0018a	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _count$9[ebp], ecx
$LN22@ComputeBre:

; 541  :         if (HLineType(dotNum.x  , dotNum.y-1) != LINE_NONE) count++;

  00190	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp+4]
  00193	83 ea 01	 sub	 edx, 1
  00196	52		 push	 edx
  00197	8b 45 ec	 mov	 eax, DWORD PTR _dotNum$[ebp]
  0019a	50		 push	 eax
  0019b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0019e	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  001a3	85 c0		 test	 eax, eax
  001a5	74 0f		 je	 SHORT $LN23@ComputeBre
  001a7	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _count$9[ebp]
  001ad	83 c1 01	 add	 ecx, 1
  001b0	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _count$9[ebp], ecx
$LN23@ComputeBre:

; 542  :         if (HLineType(dotNum.x-1, dotNum.y+1) != LINE_NONE) count++;

  001b6	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp+4]
  001b9	83 c2 01	 add	 edx, 1
  001bc	52		 push	 edx
  001bd	8b 45 ec	 mov	 eax, DWORD PTR _dotNum$[ebp]
  001c0	83 e8 01	 sub	 eax, 1
  001c3	50		 push	 eax
  001c4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c7	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  001cc	85 c0		 test	 eax, eax
  001ce	74 0f		 je	 SHORT $LN24@ComputeBre
  001d0	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _count$9[ebp]
  001d6	83 c1 01	 add	 ecx, 1
  001d9	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _count$9[ebp], ecx
$LN24@ComputeBre:

; 543  :         if (HLineType(dotNum.x  , dotNum.y+1) != LINE_NONE) count++;

  001df	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp+4]
  001e2	83 c2 01	 add	 edx, 1
  001e5	52		 push	 edx
  001e6	8b 45 ec	 mov	 eax, DWORD PTR _dotNum$[ebp]
  001e9	50		 push	 eax
  001ea	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ed	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  001f2	85 c0		 test	 eax, eax
  001f4	74 0f		 je	 SHORT $LN25@ComputeBre
  001f6	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _count$9[ebp]
  001fc	83 c1 01	 add	 ecx, 1
  001ff	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _count$9[ebp], ecx
$LN25@ComputeBre:

; 544  :         if (VLineType(dotNum.x-1, dotNum.y-1) != LINE_NONE) count++;

  00205	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp+4]
  00208	83 ea 01	 sub	 edx, 1
  0020b	52		 push	 edx
  0020c	8b 45 ec	 mov	 eax, DWORD PTR _dotNum$[ebp]
  0020f	83 e8 01	 sub	 eax, 1
  00212	50		 push	 eax
  00213	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00216	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  0021b	85 c0		 test	 eax, eax
  0021d	74 0f		 je	 SHORT $LN26@ComputeBre
  0021f	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _count$9[ebp]
  00225	83 c1 01	 add	 ecx, 1
  00228	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _count$9[ebp], ecx
$LN26@ComputeBre:

; 545  :         if (VLineType(dotNum.x-1, dotNum.y  ) != LINE_NONE) count++;

  0022e	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp+4]
  00231	52		 push	 edx
  00232	8b 45 ec	 mov	 eax, DWORD PTR _dotNum$[ebp]
  00235	83 e8 01	 sub	 eax, 1
  00238	50		 push	 eax
  00239	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0023c	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  00241	85 c0		 test	 eax, eax
  00243	74 0f		 je	 SHORT $LN27@ComputeBre
  00245	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _count$9[ebp]
  0024b	83 c1 01	 add	 ecx, 1
  0024e	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _count$9[ebp], ecx
$LN27@ComputeBre:

; 546  :         if (VLineType(dotNum.x+1, dotNum.y-1) != LINE_NONE) count++;

  00254	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp+4]
  00257	83 ea 01	 sub	 edx, 1
  0025a	52		 push	 edx
  0025b	8b 45 ec	 mov	 eax, DWORD PTR _dotNum$[ebp]
  0025e	83 c0 01	 add	 eax, 1
  00261	50		 push	 eax
  00262	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00265	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  0026a	85 c0		 test	 eax, eax
  0026c	74 0f		 je	 SHORT $LN28@ComputeBre
  0026e	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _count$9[ebp]
  00274	83 c1 01	 add	 ecx, 1
  00277	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _count$9[ebp], ecx
$LN28@ComputeBre:

; 547  :         if (VLineType(dotNum.x+1, dotNum.y  ) != LINE_NONE) count++;

  0027d	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp+4]
  00280	52		 push	 edx
  00281	8b 45 ec	 mov	 eax, DWORD PTR _dotNum$[ebp]
  00284	83 c0 01	 add	 eax, 1
  00287	50		 push	 eax
  00288	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0028b	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  00290	85 c0		 test	 eax, eax
  00292	74 0f		 je	 SHORT $LN29@ComputeBre
  00294	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _count$9[ebp]
  0029a	83 c1 01	 add	 ecx, 1
  0029d	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _count$9[ebp], ecx
$LN29@ComputeBre:

; 548  :         if (count < 8)

  002a3	83 bd d4 fe ff
	ff 08		 cmp	 DWORD PTR _count$9[ebp], 8
  002aa	0f 8d 04 01 00
	00		 jge	 $LN30@ComputeBre

; 549  :         {
; 550  :           int weight = 9*count*count;

  002b0	6b 95 d4 fe ff
	ff 09		 imul	 edx, DWORD PTR _count$9[ebp], 9
  002b7	0f af 95 d4 fe
	ff ff		 imul	 edx, DWORD PTR _count$9[ebp]
  002be	89 95 d0 fe ff
	ff		 mov	 DWORD PTR _weight$8[ebp], edx

; 551  :           if (count >= MINLOOPBREAK)

  002c4	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _count$9[ebp]
  002ca	3b 45 08	 cmp	 eax, DWORD PTR _MINLOOPBREAK$[ebp]
  002cd	7c 41		 jl	 SHORT $LN31@ComputeBre

; 552  :           {
; 553  :             loopWeightMin[hLine] = 1;

  002cf	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _hLine$11[ebp]
  002d5	c6 84 0d e4 fe
	ff ff 01	 mov	 BYTE PTR _loopWeightMin$[ebp+ecx], 1

; 554  :             loopWeightMin[vLine] = 1;

  002dd	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _vLine$10[ebp]
  002e3	c6 84 15 e4 fe
	ff ff 01	 mov	 BYTE PTR _loopWeightMin$[ebp+edx], 1

; 555  :             loopWeightMin[hLine-1] =1;

  002eb	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _hLine$11[ebp]
  002f1	c6 84 05 e3 fe
	ff ff 01	 mov	 BYTE PTR _loopWeightMin$[ebp+eax-1], 1

; 556  :             loopWeightMin[vLine - (2*width-1)] =1;

  002f9	8b 4d e4	 mov	 ecx, DWORD PTR _width$[ebp]
  002fc	8d 54 09 ff	 lea	 edx, DWORD PTR [ecx+ecx-1]
  00300	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _vLine$10[ebp]
  00306	2b c2		 sub	 eax, edx
  00308	c6 84 05 e4 fe
	ff ff 01	 mov	 BYTE PTR _loopWeightMin$[ebp+eax], 1
$LN31@ComputeBre:

; 557  :           };
; 558  :           m_breakUpLoopsWeight[hLine] += weight;

  00310	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00313	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00316	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _hLine$11[ebp]
  0031c	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  0031f	03 8d d0 fe ff
	ff		 add	 ecx, DWORD PTR _weight$8[ebp]
  00325	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00328	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0032b	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _hLine$11[ebp]
  00331	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 559  :           m_breakUpLoopsWeight[vLine] += weight;

  00334	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00337	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0033a	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _vLine$10[ebp]
  00340	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00343	03 85 d0 fe ff
	ff		 add	 eax, DWORD PTR _weight$8[ebp]
  00349	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0034c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0034f	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _vLine$10[ebp]
  00355	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 560  :           m_breakUpLoopsWeight[hLine-1] += weight;

  00358	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0035b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0035e	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _hLine$11[ebp]
  00364	8b 54 88 fc	 mov	 edx, DWORD PTR [eax+ecx*4-4]
  00368	03 95 d0 fe ff
	ff		 add	 edx, DWORD PTR _weight$8[ebp]
  0036e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00371	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00374	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _hLine$11[ebp]
  0037a	89 54 81 fc	 mov	 DWORD PTR [ecx+eax*4-4], edx

; 561  :           m_breakUpLoopsWeight[vLine - (2*width-1)] += weight;

  0037e	8b 4d e4	 mov	 ecx, DWORD PTR _width$[ebp]
  00381	8d 54 09 ff	 lea	 edx, DWORD PTR [ecx+ecx-1]
  00385	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _vLine$10[ebp]
  0038b	2b c2		 sub	 eax, edx
  0038d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00390	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00393	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  00396	03 85 d0 fe ff
	ff		 add	 eax, DWORD PTR _weight$8[ebp]
  0039c	8b 4d e4	 mov	 ecx, DWORD PTR _width$[ebp]
  0039f	8d 54 09 ff	 lea	 edx, DWORD PTR [ecx+ecx-1]
  003a3	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _vLine$10[ebp]
  003a9	2b ca		 sub	 ecx, edx
  003ab	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  003ae	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  003b1	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
$LN30@ComputeBre:

; 562  :         };
; 563  :       };

  003b4	e9 07 fd ff ff	 jmp	 $LN5@ComputeBre
$LN6@ComputeBre:

; 564  :     };

  003b9	e9 e1 fc ff ff	 jmp	 $LN2@ComputeBre
$LN3@ComputeBre:

; 565  :     for (dotNum.x=1; dotNum.x<width-1; dotNum.x++)

  003be	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _dotNum$[ebp], 1
  003c5	eb 09		 jmp	 SHORT $LN10@ComputeBre
$LN8@ComputeBre:
  003c7	8b 45 ec	 mov	 eax, DWORD PTR _dotNum$[ebp]
  003ca	83 c0 01	 add	 eax, 1
  003cd	89 45 ec	 mov	 DWORD PTR _dotNum$[ebp], eax
$LN10@ComputeBre:
  003d0	8b 4d e4	 mov	 ecx, DWORD PTR _width$[ebp]
  003d3	83 e9 01	 sub	 ecx, 1
  003d6	39 4d ec	 cmp	 DWORD PTR _dotNum$[ebp], ecx
  003d9	0f 8d 69 08 00
	00		 jge	 $LN9@ComputeBre

; 566  :     {
; 567  :       for (dotNum.y=1; dotNum.y<height-1; dotNum.y++)

  003df	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _dotNum$[ebp+4], 1
  003e6	eb 09		 jmp	 SHORT $LN13@ComputeBre
$LN11@ComputeBre:
  003e8	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp+4]
  003eb	83 c2 01	 add	 edx, 1
  003ee	89 55 f0	 mov	 DWORD PTR _dotNum$[ebp+4], edx
$LN13@ComputeBre:
  003f1	8b 45 e0	 mov	 eax, DWORD PTR _height$[ebp]
  003f4	83 e8 01	 sub	 eax, 1
  003f7	39 45 f0	 cmp	 DWORD PTR _dotNum$[ebp+4], eax
  003fa	0f 8d 43 08 00
	00		 jge	 $LN12@ComputeBre

; 568  :       {
; 569  :         int hLine, vLine;
; 570  :         hLine = dotNum.y*(2*width-1) + dotNum.x;

  00400	8b 4d e4	 mov	 ecx, DWORD PTR _width$[ebp]
  00403	8d 54 09 ff	 lea	 edx, DWORD PTR [ecx+ecx-1]
  00407	0f af 55 f0	 imul	 edx, DWORD PTR _dotNum$[ebp+4]
  0040b	03 55 ec	 add	 edx, DWORD PTR _dotNum$[ebp]
  0040e	89 95 cc fe ff
	ff		 mov	 DWORD PTR _hLine$7[ebp], edx

; 571  :         vLine = hLine + width - 1;

  00414	8b 45 e4	 mov	 eax, DWORD PTR _width$[ebp]
  00417	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _hLine$7[ebp]
  0041d	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  00421	89 95 c8 fe ff
	ff		 mov	 DWORD PTR _vLine$6[ebp], edx

; 572  :         //Horizontal 6-loops
; 573  :         if (
; 574  :                 (dotNum.x < width-2)
; 575  :             && (HLineType(dotNum.x  , dotNum.y  ) != LINE_NONE)
; 576  :             && (VLineType(dotNum.x  , dotNum.y-1) == LINE_NONE)
; 577  :             && (VLineType(dotNum.x+1, dotNum.y-1) == LINE_NONE)
; 578  :             && (HLineType(dotNum.x+1, dotNum.y  ) == LINE_NONE)
; 579  :             && (VLineType(dotNum.x+1, dotNum.y  ) == LINE_NONE)
; 580  :             && (VLineType(dotNum.x  , dotNum.y  ) == LINE_NONE)
; 581  :             && (HLineType(dotNum.x-1, dotNum.y  ) == LINE_NONE)

  00427	8b 45 e4	 mov	 eax, DWORD PTR _width$[ebp]
  0042a	83 e8 02	 sub	 eax, 2
  0042d	39 45 ec	 cmp	 DWORD PTR _dotNum$[ebp], eax
  00430	0f 8d f1 03 00
	00		 jge	 $LN32@ComputeBre
  00436	8b 4d f0	 mov	 ecx, DWORD PTR _dotNum$[ebp+4]
  00439	51		 push	 ecx
  0043a	8b 55 ec	 mov	 edx, DWORD PTR _dotNum$[ebp]
  0043d	52		 push	 edx
  0043e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00441	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  00446	85 c0		 test	 eax, eax
  00448	0f 84 d9 03 00
	00		 je	 $LN32@ComputeBre
  0044e	8b 45 f0	 mov	 eax, DWORD PTR _dotNum$[ebp+4]
  00451	83 e8 01	 sub	 eax, 1
  00454	50		 push	 eax
  00455	8b 4d ec	 mov	 ecx, DWORD PTR _dotNum$[ebp]
  00458	51		 push	 ecx
  00459	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0045c	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  00461	85 c0		 test	 eax, eax
  00463	0f 85 be 03 00
	00		 jne	 $LN32@ComputeBre
  00469	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp+4]
  0046c	83 ea 01	 sub	 edx, 1
  0046f	52		 push	 edx
  00470	8b 45 ec	 mov	 eax, DWORD PTR _dotNum$[ebp]
  00473	83 c0 01	 add	 eax, 1
  00476	50		 push	 eax
  00477	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0047a	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  0047f	85 c0		 test	 eax, eax
  00481	0f 85 a0 03 00
	00		 jne	 $LN32@ComputeBre
  00487	8b 4d f0	 mov	 ecx, DWORD PTR _dotNum$[ebp+4]
  0048a	51		 push	 ecx
  0048b	8b 55 ec	 mov	 edx, DWORD PTR _dotNum$[ebp]
  0048e	83 c2 01	 add	 edx, 1
  00491	52		 push	 edx
  00492	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00495	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  0049a	85 c0		 test	 eax, eax
  0049c	0f 85 85 03 00
	00		 jne	 $LN32@ComputeBre
  004a2	8b 45 f0	 mov	 eax, DWORD PTR _dotNum$[ebp+4]
  004a5	50		 push	 eax
  004a6	8b 4d ec	 mov	 ecx, DWORD PTR _dotNum$[ebp]
  004a9	83 c1 01	 add	 ecx, 1
  004ac	51		 push	 ecx
  004ad	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004b0	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  004b5	85 c0		 test	 eax, eax
  004b7	0f 85 6a 03 00
	00		 jne	 $LN32@ComputeBre
  004bd	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp+4]
  004c0	52		 push	 edx
  004c1	8b 45 ec	 mov	 eax, DWORD PTR _dotNum$[ebp]
  004c4	50		 push	 eax
  004c5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004c8	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  004cd	85 c0		 test	 eax, eax
  004cf	0f 85 52 03 00
	00		 jne	 $LN32@ComputeBre
  004d5	8b 4d f0	 mov	 ecx, DWORD PTR _dotNum$[ebp+4]
  004d8	51		 push	 ecx
  004d9	8b 55 ec	 mov	 edx, DWORD PTR _dotNum$[ebp]
  004dc	83 ea 01	 sub	 edx, 1
  004df	52		 push	 edx
  004e0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004e3	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  004e8	85 c0		 test	 eax, eax
  004ea	0f 85 37 03 00
	00		 jne	 $LN32@ComputeBre

; 582  :           )
; 583  :         {
; 584  :           //Count Lines around this point
; 585  :           int count = 0;

  004f0	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _count$5[ebp], 0

; 586  :           if (HLineType(dotNum.x-1, dotNum.y-1) != LINE_NONE) count++;

  004fa	8b 45 f0	 mov	 eax, DWORD PTR _dotNum$[ebp+4]
  004fd	83 e8 01	 sub	 eax, 1
  00500	50		 push	 eax
  00501	8b 4d ec	 mov	 ecx, DWORD PTR _dotNum$[ebp]
  00504	83 e9 01	 sub	 ecx, 1
  00507	51		 push	 ecx
  00508	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0050b	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  00510	85 c0		 test	 eax, eax
  00512	74 0f		 je	 SHORT $LN33@ComputeBre
  00514	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _count$5[ebp]
  0051a	83 c2 01	 add	 edx, 1
  0051d	89 95 c4 fe ff
	ff		 mov	 DWORD PTR _count$5[ebp], edx
$LN33@ComputeBre:

; 587  :           if (HLineType(dotNum.x  , dotNum.y-1) != LINE_NONE) count++;

  00523	8b 45 f0	 mov	 eax, DWORD PTR _dotNum$[ebp+4]
  00526	83 e8 01	 sub	 eax, 1
  00529	50		 push	 eax
  0052a	8b 4d ec	 mov	 ecx, DWORD PTR _dotNum$[ebp]
  0052d	51		 push	 ecx
  0052e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00531	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  00536	85 c0		 test	 eax, eax
  00538	74 0f		 je	 SHORT $LN34@ComputeBre
  0053a	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _count$5[ebp]
  00540	83 c2 01	 add	 edx, 1
  00543	89 95 c4 fe ff
	ff		 mov	 DWORD PTR _count$5[ebp], edx
$LN34@ComputeBre:

; 588  :           if (HLineType(dotNum.x+1, dotNum.y-1) != LINE_NONE) count++;

  00549	8b 45 f0	 mov	 eax, DWORD PTR _dotNum$[ebp+4]
  0054c	83 e8 01	 sub	 eax, 1
  0054f	50		 push	 eax
  00550	8b 4d ec	 mov	 ecx, DWORD PTR _dotNum$[ebp]
  00553	83 c1 01	 add	 ecx, 1
  00556	51		 push	 ecx
  00557	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0055a	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  0055f	85 c0		 test	 eax, eax
  00561	74 0f		 je	 SHORT $LN35@ComputeBre
  00563	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _count$5[ebp]
  00569	83 c2 01	 add	 edx, 1
  0056c	89 95 c4 fe ff
	ff		 mov	 DWORD PTR _count$5[ebp], edx
$LN35@ComputeBre:

; 589  :           if (HLineType(dotNum.x-1, dotNum.y+1) != LINE_NONE) count++;

  00572	8b 45 f0	 mov	 eax, DWORD PTR _dotNum$[ebp+4]
  00575	83 c0 01	 add	 eax, 1
  00578	50		 push	 eax
  00579	8b 4d ec	 mov	 ecx, DWORD PTR _dotNum$[ebp]
  0057c	83 e9 01	 sub	 ecx, 1
  0057f	51		 push	 ecx
  00580	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00583	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  00588	85 c0		 test	 eax, eax
  0058a	74 0f		 je	 SHORT $LN36@ComputeBre
  0058c	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _count$5[ebp]
  00592	83 c2 01	 add	 edx, 1
  00595	89 95 c4 fe ff
	ff		 mov	 DWORD PTR _count$5[ebp], edx
$LN36@ComputeBre:

; 590  :           if (HLineType(dotNum.x  , dotNum.y+1) != LINE_NONE) count++;

  0059b	8b 45 f0	 mov	 eax, DWORD PTR _dotNum$[ebp+4]
  0059e	83 c0 01	 add	 eax, 1
  005a1	50		 push	 eax
  005a2	8b 4d ec	 mov	 ecx, DWORD PTR _dotNum$[ebp]
  005a5	51		 push	 ecx
  005a6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005a9	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  005ae	85 c0		 test	 eax, eax
  005b0	74 0f		 je	 SHORT $LN37@ComputeBre
  005b2	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _count$5[ebp]
  005b8	83 c2 01	 add	 edx, 1
  005bb	89 95 c4 fe ff
	ff		 mov	 DWORD PTR _count$5[ebp], edx
$LN37@ComputeBre:

; 591  :           if (HLineType(dotNum.x+1, dotNum.y+1) != LINE_NONE) count++;

  005c1	8b 45 f0	 mov	 eax, DWORD PTR _dotNum$[ebp+4]
  005c4	83 c0 01	 add	 eax, 1
  005c7	50		 push	 eax
  005c8	8b 4d ec	 mov	 ecx, DWORD PTR _dotNum$[ebp]
  005cb	83 c1 01	 add	 ecx, 1
  005ce	51		 push	 ecx
  005cf	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005d2	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  005d7	85 c0		 test	 eax, eax
  005d9	74 0f		 je	 SHORT $LN38@ComputeBre
  005db	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _count$5[ebp]
  005e1	83 c2 01	 add	 edx, 1
  005e4	89 95 c4 fe ff
	ff		 mov	 DWORD PTR _count$5[ebp], edx
$LN38@ComputeBre:

; 592  :           if (VLineType(dotNum.x-1, dotNum.y-1) != LINE_NONE) count++;

  005ea	8b 45 f0	 mov	 eax, DWORD PTR _dotNum$[ebp+4]
  005ed	83 e8 01	 sub	 eax, 1
  005f0	50		 push	 eax
  005f1	8b 4d ec	 mov	 ecx, DWORD PTR _dotNum$[ebp]
  005f4	83 e9 01	 sub	 ecx, 1
  005f7	51		 push	 ecx
  005f8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005fb	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  00600	85 c0		 test	 eax, eax
  00602	74 0f		 je	 SHORT $LN39@ComputeBre
  00604	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _count$5[ebp]
  0060a	83 c2 01	 add	 edx, 1
  0060d	89 95 c4 fe ff
	ff		 mov	 DWORD PTR _count$5[ebp], edx
$LN39@ComputeBre:

; 593  :           if (VLineType(dotNum.x-1, dotNum.y  ) != LINE_NONE) count++;

  00613	8b 45 f0	 mov	 eax, DWORD PTR _dotNum$[ebp+4]
  00616	50		 push	 eax
  00617	8b 4d ec	 mov	 ecx, DWORD PTR _dotNum$[ebp]
  0061a	83 e9 01	 sub	 ecx, 1
  0061d	51		 push	 ecx
  0061e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00621	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  00626	85 c0		 test	 eax, eax
  00628	74 0f		 je	 SHORT $LN40@ComputeBre
  0062a	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _count$5[ebp]
  00630	83 c2 01	 add	 edx, 1
  00633	89 95 c4 fe ff
	ff		 mov	 DWORD PTR _count$5[ebp], edx
$LN40@ComputeBre:

; 594  :           if (VLineType(dotNum.x+2, dotNum.y-1) != LINE_NONE) count++;

  00639	8b 45 f0	 mov	 eax, DWORD PTR _dotNum$[ebp+4]
  0063c	83 e8 01	 sub	 eax, 1
  0063f	50		 push	 eax
  00640	8b 4d ec	 mov	 ecx, DWORD PTR _dotNum$[ebp]
  00643	83 c1 02	 add	 ecx, 2
  00646	51		 push	 ecx
  00647	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0064a	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  0064f	85 c0		 test	 eax, eax
  00651	74 0f		 je	 SHORT $LN41@ComputeBre
  00653	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _count$5[ebp]
  00659	83 c2 01	 add	 edx, 1
  0065c	89 95 c4 fe ff
	ff		 mov	 DWORD PTR _count$5[ebp], edx
$LN41@ComputeBre:

; 595  :           if (VLineType(dotNum.x+2, dotNum.y  ) != LINE_NONE) count++;

  00662	8b 45 f0	 mov	 eax, DWORD PTR _dotNum$[ebp+4]
  00665	50		 push	 eax
  00666	8b 4d ec	 mov	 ecx, DWORD PTR _dotNum$[ebp]
  00669	83 c1 02	 add	 ecx, 2
  0066c	51		 push	 ecx
  0066d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00670	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  00675	85 c0		 test	 eax, eax
  00677	74 0f		 je	 SHORT $LN42@ComputeBre
  00679	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _count$5[ebp]
  0067f	83 c2 01	 add	 edx, 1
  00682	89 95 c4 fe ff
	ff		 mov	 DWORD PTR _count$5[ebp], edx
$LN42@ComputeBre:

; 596  :           if (count < 10)

  00688	83 bd c4 fe ff
	ff 0a		 cmp	 DWORD PTR _count$5[ebp], 10 ; 0000000aH
  0068f	0f 8d 92 01 00
	00		 jge	 $LN32@ComputeBre

; 597  :           {
; 598  :             int weight = 4*count*count;

  00695	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _count$5[ebp]
  0069b	c1 e0 02	 shl	 eax, 2
  0069e	0f af 85 c4 fe
	ff ff		 imul	 eax, DWORD PTR _count$5[ebp]
  006a5	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _weight$4[ebp], eax

; 599  :             if (count >= MINLOOPBREAK)

  006ab	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _count$5[ebp]
  006b1	3b 4d 08	 cmp	 ecx, DWORD PTR _MINLOOPBREAK$[ebp]
  006b4	7c 69		 jl	 SHORT $LN44@ComputeBre

; 600  :             {            
; 601  :               loopWeightMin[hLine+1] = 1;

  006b6	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR _hLine$7[ebp]
  006bc	c6 84 15 e5 fe
	ff ff 01	 mov	 BYTE PTR _loopWeightMin$[ebp+edx+1], 1

; 602  :               loopWeightMin[vLine] = 1;

  006c4	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _vLine$6[ebp]
  006ca	c6 84 05 e4 fe
	ff ff 01	 mov	 BYTE PTR _loopWeightMin$[ebp+eax], 1

; 603  :               loopWeightMin[vLine+1] = 1;

  006d2	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR _vLine$6[ebp]
  006d8	c6 84 0d e5 fe
	ff ff 01	 mov	 BYTE PTR _loopWeightMin$[ebp+ecx+1], 1

; 604  :               loopWeightMin[hLine-1] = 1;

  006e0	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR _hLine$7[ebp]
  006e6	c6 84 15 e3 fe
	ff ff 01	 mov	 BYTE PTR _loopWeightMin$[ebp+edx-1], 1

; 605  :               loopWeightMin[vLine - (2*width-1)] = 1;

  006ee	8b 45 e4	 mov	 eax, DWORD PTR _width$[ebp]
  006f1	8d 4c 00 ff	 lea	 ecx, DWORD PTR [eax+eax-1]
  006f5	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR _vLine$6[ebp]
  006fb	2b d1		 sub	 edx, ecx
  006fd	c6 84 15 e4 fe
	ff ff 01	 mov	 BYTE PTR _loopWeightMin$[ebp+edx], 1

; 606  :               loopWeightMin[vLine+1 - (2*width-1)] = 1;

  00705	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _vLine$6[ebp]
  0070b	83 c0 01	 add	 eax, 1
  0070e	8b 4d e4	 mov	 ecx, DWORD PTR _width$[ebp]
  00711	8d 54 09 ff	 lea	 edx, DWORD PTR [ecx+ecx-1]
  00715	2b c2		 sub	 eax, edx
  00717	c6 84 05 e4 fe
	ff ff 01	 mov	 BYTE PTR _loopWeightMin$[ebp+eax], 1
$LN44@ComputeBre:

; 607  :             };
; 608  :             m_breakUpLoopsWeight[hLine+1] += weight;

  0071f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00722	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00725	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR _hLine$7[ebp]
  0072b	8b 44 91 04	 mov	 eax, DWORD PTR [ecx+edx*4+4]
  0072f	03 85 c0 fe ff
	ff		 add	 eax, DWORD PTR _weight$4[ebp]
  00735	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00738	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0073b	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _hLine$7[ebp]
  00741	89 44 8a 04	 mov	 DWORD PTR [edx+ecx*4+4], eax

; 609  :             m_breakUpLoopsWeight[vLine] += weight;

  00745	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00748	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0074b	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR _vLine$6[ebp]
  00751	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  00754	03 95 c0 fe ff
	ff		 add	 edx, DWORD PTR _weight$4[ebp]
  0075a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0075d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00760	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _vLine$6[ebp]
  00766	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 610  :             m_breakUpLoopsWeight[vLine+1] += weight;

  00769	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0076c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0076f	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _vLine$6[ebp]
  00775	8b 4c 82 04	 mov	 ecx, DWORD PTR [edx+eax*4+4]
  00779	03 8d c0 fe ff
	ff		 add	 ecx, DWORD PTR _weight$4[ebp]
  0077f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00782	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00785	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR _vLine$6[ebp]
  0078b	89 4c 90 04	 mov	 DWORD PTR [eax+edx*4+4], ecx

; 611  :             m_breakUpLoopsWeight[hLine-1] += weight;

  0078f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00792	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00795	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR _hLine$7[ebp]
  0079b	8b 44 91 fc	 mov	 eax, DWORD PTR [ecx+edx*4-4]
  0079f	03 85 c0 fe ff
	ff		 add	 eax, DWORD PTR _weight$4[ebp]
  007a5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007a8	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  007ab	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _hLine$7[ebp]
  007b1	89 44 8a fc	 mov	 DWORD PTR [edx+ecx*4-4], eax

; 612  :             m_breakUpLoopsWeight[vLine - (2*width-1)] += weight;

  007b5	8b 55 e4	 mov	 edx, DWORD PTR _width$[ebp]
  007b8	8d 44 12 ff	 lea	 eax, DWORD PTR [edx+edx-1]
  007bc	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR _vLine$6[ebp]
  007c2	2b c8		 sub	 ecx, eax
  007c4	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  007c7	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  007ca	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  007cd	03 8d c0 fe ff
	ff		 add	 ecx, DWORD PTR _weight$4[ebp]
  007d3	8b 55 e4	 mov	 edx, DWORD PTR _width$[ebp]
  007d6	8d 44 12 ff	 lea	 eax, DWORD PTR [edx+edx-1]
  007da	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR _vLine$6[ebp]
  007e0	2b d0		 sub	 edx, eax
  007e2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  007e5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  007e8	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 613  :             m_breakUpLoopsWeight[vLine+1 - (2*width-1)] += weight;

  007eb	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR _vLine$6[ebp]
  007f1	83 c1 01	 add	 ecx, 1
  007f4	8b 55 e4	 mov	 edx, DWORD PTR _width$[ebp]
  007f7	8d 44 12 ff	 lea	 eax, DWORD PTR [edx+edx-1]
  007fb	2b c8		 sub	 ecx, eax
  007fd	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00800	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00803	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  00806	03 8d c0 fe ff
	ff		 add	 ecx, DWORD PTR _weight$4[ebp]
  0080c	8b 55 e4	 mov	 edx, DWORD PTR _width$[ebp]
  0080f	8d 44 12 ff	 lea	 eax, DWORD PTR [edx+edx-1]
  00813	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR _vLine$6[ebp]
  00819	83 c2 01	 add	 edx, 1
  0081c	2b d0		 sub	 edx, eax
  0081e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00821	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00824	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
$LN32@ComputeBre:

; 614  :           };
; 615  :         };
; 616  :         //Vertical 6-loops
; 617  :         if (
; 618  :                 (dotNum.y < height-2)
; 619  :             && (VLineType(dotNum.x  , dotNum.y  ) != LINE_NONE)
; 620  :             && (HLineType(dotNum.x  , dotNum.y  ) == LINE_NONE)
; 621  :             && (HLineType(dotNum.x  , dotNum.y+1) == LINE_NONE)
; 622  :             && (VLineType(dotNum.x  , dotNum.y+1) == LINE_NONE)
; 623  :             && (HLineType(dotNum.x-1, dotNum.y+1) == LINE_NONE)
; 624  :             && (HLineType(dotNum.x-1, dotNum.y  ) == LINE_NONE)
; 625  :             && (VLineType(dotNum.x  , dotNum.y-1) == LINE_NONE)

  00827	8b 4d e0	 mov	 ecx, DWORD PTR _height$[ebp]
  0082a	83 e9 02	 sub	 ecx, 2
  0082d	39 4d f0	 cmp	 DWORD PTR _dotNum$[ebp+4], ecx
  00830	0f 8d 08 04 00
	00		 jge	 $LN45@ComputeBre
  00836	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp+4]
  00839	52		 push	 edx
  0083a	8b 45 ec	 mov	 eax, DWORD PTR _dotNum$[ebp]
  0083d	50		 push	 eax
  0083e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00841	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  00846	85 c0		 test	 eax, eax
  00848	0f 84 f0 03 00
	00		 je	 $LN45@ComputeBre
  0084e	8b 4d f0	 mov	 ecx, DWORD PTR _dotNum$[ebp+4]
  00851	51		 push	 ecx
  00852	8b 55 ec	 mov	 edx, DWORD PTR _dotNum$[ebp]
  00855	52		 push	 edx
  00856	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00859	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  0085e	85 c0		 test	 eax, eax
  00860	0f 85 d8 03 00
	00		 jne	 $LN45@ComputeBre
  00866	8b 45 f0	 mov	 eax, DWORD PTR _dotNum$[ebp+4]
  00869	83 c0 01	 add	 eax, 1
  0086c	50		 push	 eax
  0086d	8b 4d ec	 mov	 ecx, DWORD PTR _dotNum$[ebp]
  00870	51		 push	 ecx
  00871	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00874	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  00879	85 c0		 test	 eax, eax
  0087b	0f 85 bd 03 00
	00		 jne	 $LN45@ComputeBre
  00881	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp+4]
  00884	83 c2 01	 add	 edx, 1
  00887	52		 push	 edx
  00888	8b 45 ec	 mov	 eax, DWORD PTR _dotNum$[ebp]
  0088b	50		 push	 eax
  0088c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0088f	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  00894	85 c0		 test	 eax, eax
  00896	0f 85 a2 03 00
	00		 jne	 $LN45@ComputeBre
  0089c	8b 4d f0	 mov	 ecx, DWORD PTR _dotNum$[ebp+4]
  0089f	83 c1 01	 add	 ecx, 1
  008a2	51		 push	 ecx
  008a3	8b 55 ec	 mov	 edx, DWORD PTR _dotNum$[ebp]
  008a6	83 ea 01	 sub	 edx, 1
  008a9	52		 push	 edx
  008aa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008ad	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  008b2	85 c0		 test	 eax, eax
  008b4	0f 85 84 03 00
	00		 jne	 $LN45@ComputeBre
  008ba	8b 45 f0	 mov	 eax, DWORD PTR _dotNum$[ebp+4]
  008bd	50		 push	 eax
  008be	8b 4d ec	 mov	 ecx, DWORD PTR _dotNum$[ebp]
  008c1	83 e9 01	 sub	 ecx, 1
  008c4	51		 push	 ecx
  008c5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008c8	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  008cd	85 c0		 test	 eax, eax
  008cf	0f 85 69 03 00
	00		 jne	 $LN45@ComputeBre
  008d5	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp+4]
  008d8	83 ea 01	 sub	 edx, 1
  008db	52		 push	 edx
  008dc	8b 45 ec	 mov	 eax, DWORD PTR _dotNum$[ebp]
  008df	50		 push	 eax
  008e0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008e3	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  008e8	85 c0		 test	 eax, eax
  008ea	0f 85 4e 03 00
	00		 jne	 $LN45@ComputeBre

; 626  :           )
; 627  :         {
; 628  :           //Count Lines around this point
; 629  :           int count = 0;

  008f0	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _count$3[ebp], 0

; 630  :           if (HLineType(dotNum.x-1, dotNum.y-1) != LINE_NONE) count++;

  008fa	8b 4d f0	 mov	 ecx, DWORD PTR _dotNum$[ebp+4]
  008fd	83 e9 01	 sub	 ecx, 1
  00900	51		 push	 ecx
  00901	8b 55 ec	 mov	 edx, DWORD PTR _dotNum$[ebp]
  00904	83 ea 01	 sub	 edx, 1
  00907	52		 push	 edx
  00908	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0090b	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  00910	85 c0		 test	 eax, eax
  00912	74 0f		 je	 SHORT $LN46@ComputeBre
  00914	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _count$3[ebp]
  0091a	83 c0 01	 add	 eax, 1
  0091d	89 85 bc fe ff
	ff		 mov	 DWORD PTR _count$3[ebp], eax
$LN46@ComputeBre:

; 631  :           if (HLineType(dotNum.x  , dotNum.y-1) != LINE_NONE) count++;

  00923	8b 4d f0	 mov	 ecx, DWORD PTR _dotNum$[ebp+4]
  00926	83 e9 01	 sub	 ecx, 1
  00929	51		 push	 ecx
  0092a	8b 55 ec	 mov	 edx, DWORD PTR _dotNum$[ebp]
  0092d	52		 push	 edx
  0092e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00931	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  00936	85 c0		 test	 eax, eax
  00938	74 0f		 je	 SHORT $LN47@ComputeBre
  0093a	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _count$3[ebp]
  00940	83 c0 01	 add	 eax, 1
  00943	89 85 bc fe ff
	ff		 mov	 DWORD PTR _count$3[ebp], eax
$LN47@ComputeBre:

; 632  :           if (HLineType(dotNum.x-1, dotNum.y+2) != LINE_NONE) count++;

  00949	8b 4d f0	 mov	 ecx, DWORD PTR _dotNum$[ebp+4]
  0094c	83 c1 02	 add	 ecx, 2
  0094f	51		 push	 ecx
  00950	8b 55 ec	 mov	 edx, DWORD PTR _dotNum$[ebp]
  00953	83 ea 01	 sub	 edx, 1
  00956	52		 push	 edx
  00957	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0095a	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  0095f	85 c0		 test	 eax, eax
  00961	74 0f		 je	 SHORT $LN48@ComputeBre
  00963	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _count$3[ebp]
  00969	83 c0 01	 add	 eax, 1
  0096c	89 85 bc fe ff
	ff		 mov	 DWORD PTR _count$3[ebp], eax
$LN48@ComputeBre:

; 633  :           if (HLineType(dotNum.x  , dotNum.y+2) != LINE_NONE) count++;

  00972	8b 4d f0	 mov	 ecx, DWORD PTR _dotNum$[ebp+4]
  00975	83 c1 02	 add	 ecx, 2
  00978	51		 push	 ecx
  00979	8b 55 ec	 mov	 edx, DWORD PTR _dotNum$[ebp]
  0097c	52		 push	 edx
  0097d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00980	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  00985	85 c0		 test	 eax, eax
  00987	74 0f		 je	 SHORT $LN49@ComputeBre
  00989	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _count$3[ebp]
  0098f	83 c0 01	 add	 eax, 1
  00992	89 85 bc fe ff
	ff		 mov	 DWORD PTR _count$3[ebp], eax
$LN49@ComputeBre:

; 634  :           if (VLineType(dotNum.x-1, dotNum.y-1) != LINE_NONE) count++;

  00998	8b 4d f0	 mov	 ecx, DWORD PTR _dotNum$[ebp+4]
  0099b	83 e9 01	 sub	 ecx, 1
  0099e	51		 push	 ecx
  0099f	8b 55 ec	 mov	 edx, DWORD PTR _dotNum$[ebp]
  009a2	83 ea 01	 sub	 edx, 1
  009a5	52		 push	 edx
  009a6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  009a9	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  009ae	85 c0		 test	 eax, eax
  009b0	74 0f		 je	 SHORT $LN50@ComputeBre
  009b2	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _count$3[ebp]
  009b8	83 c0 01	 add	 eax, 1
  009bb	89 85 bc fe ff
	ff		 mov	 DWORD PTR _count$3[ebp], eax
$LN50@ComputeBre:

; 635  :           if (VLineType(dotNum.x-1, dotNum.y  ) != LINE_NONE) count++;

  009c1	8b 4d f0	 mov	 ecx, DWORD PTR _dotNum$[ebp+4]
  009c4	51		 push	 ecx
  009c5	8b 55 ec	 mov	 edx, DWORD PTR _dotNum$[ebp]
  009c8	83 ea 01	 sub	 edx, 1
  009cb	52		 push	 edx
  009cc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  009cf	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  009d4	85 c0		 test	 eax, eax
  009d6	74 0f		 je	 SHORT $LN51@ComputeBre
  009d8	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _count$3[ebp]
  009de	83 c0 01	 add	 eax, 1
  009e1	89 85 bc fe ff
	ff		 mov	 DWORD PTR _count$3[ebp], eax
$LN51@ComputeBre:

; 636  :           if (VLineType(dotNum.x-1, dotNum.y+1) != LINE_NONE) count++;

  009e7	8b 4d f0	 mov	 ecx, DWORD PTR _dotNum$[ebp+4]
  009ea	83 c1 01	 add	 ecx, 1
  009ed	51		 push	 ecx
  009ee	8b 55 ec	 mov	 edx, DWORD PTR _dotNum$[ebp]
  009f1	83 ea 01	 sub	 edx, 1
  009f4	52		 push	 edx
  009f5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  009f8	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  009fd	85 c0		 test	 eax, eax
  009ff	74 0f		 je	 SHORT $LN52@ComputeBre
  00a01	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _count$3[ebp]
  00a07	83 c0 01	 add	 eax, 1
  00a0a	89 85 bc fe ff
	ff		 mov	 DWORD PTR _count$3[ebp], eax
$LN52@ComputeBre:

; 637  :           if (VLineType(dotNum.x+1, dotNum.y-1) != LINE_NONE) count++;

  00a10	8b 4d f0	 mov	 ecx, DWORD PTR _dotNum$[ebp+4]
  00a13	83 e9 01	 sub	 ecx, 1
  00a16	51		 push	 ecx
  00a17	8b 55 ec	 mov	 edx, DWORD PTR _dotNum$[ebp]
  00a1a	83 c2 01	 add	 edx, 1
  00a1d	52		 push	 edx
  00a1e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a21	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  00a26	85 c0		 test	 eax, eax
  00a28	74 0f		 je	 SHORT $LN53@ComputeBre
  00a2a	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _count$3[ebp]
  00a30	83 c0 01	 add	 eax, 1
  00a33	89 85 bc fe ff
	ff		 mov	 DWORD PTR _count$3[ebp], eax
$LN53@ComputeBre:

; 638  :           if (VLineType(dotNum.x+1, dotNum.y  ) != LINE_NONE) count++;

  00a39	8b 4d f0	 mov	 ecx, DWORD PTR _dotNum$[ebp+4]
  00a3c	51		 push	 ecx
  00a3d	8b 55 ec	 mov	 edx, DWORD PTR _dotNum$[ebp]
  00a40	83 c2 01	 add	 edx, 1
  00a43	52		 push	 edx
  00a44	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a47	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  00a4c	85 c0		 test	 eax, eax
  00a4e	74 0f		 je	 SHORT $LN54@ComputeBre
  00a50	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _count$3[ebp]
  00a56	83 c0 01	 add	 eax, 1
  00a59	89 85 bc fe ff
	ff		 mov	 DWORD PTR _count$3[ebp], eax
$LN54@ComputeBre:

; 639  :           if (VLineType(dotNum.x+1, dotNum.y+1) != LINE_NONE) count++;

  00a5f	8b 4d f0	 mov	 ecx, DWORD PTR _dotNum$[ebp+4]
  00a62	83 c1 01	 add	 ecx, 1
  00a65	51		 push	 ecx
  00a66	8b 55 ec	 mov	 edx, DWORD PTR _dotNum$[ebp]
  00a69	83 c2 01	 add	 edx, 1
  00a6c	52		 push	 edx
  00a6d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a70	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  00a75	85 c0		 test	 eax, eax
  00a77	74 0f		 je	 SHORT $LN55@ComputeBre
  00a79	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _count$3[ebp]
  00a7f	83 c0 01	 add	 eax, 1
  00a82	89 85 bc fe ff
	ff		 mov	 DWORD PTR _count$3[ebp], eax
$LN55@ComputeBre:

; 640  :           if (count < 10)

  00a88	83 bd bc fe ff
	ff 0a		 cmp	 DWORD PTR _count$3[ebp], 10 ; 0000000aH
  00a8f	0f 8d a9 01 00
	00		 jge	 $LN45@ComputeBre

; 641  :           {
; 642  :             int weight = 4*count*count;

  00a95	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR _count$3[ebp]
  00a9b	c1 e1 02	 shl	 ecx, 2
  00a9e	0f af 8d bc fe
	ff ff		 imul	 ecx, DWORD PTR _count$3[ebp]
  00aa5	89 8d b8 fe ff
	ff		 mov	 DWORD PTR _weight$2[ebp], ecx

; 643  :             if (count >= MINLOOPBREAK)

  00aab	8b 95 bc fe ff
	ff		 mov	 edx, DWORD PTR _count$3[ebp]
  00ab1	3b 55 08	 cmp	 edx, DWORD PTR _MINLOOPBREAK$[ebp]
  00ab4	7c 72		 jl	 SHORT $LN57@ComputeBre

; 644  :             {
; 645  :               loopWeightMin[hLine] = 1;

  00ab6	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _hLine$7[ebp]
  00abc	c6 84 05 e4 fe
	ff ff 01	 mov	 BYTE PTR _loopWeightMin$[ebp+eax], 1

; 646  :               loopWeightMin[hLine + (2*width-1)] = 1;

  00ac4	8b 4d e4	 mov	 ecx, DWORD PTR _width$[ebp]
  00ac7	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR _hLine$7[ebp]
  00acd	8d 44 4a ff	 lea	 eax, DWORD PTR [edx+ecx*2-1]
  00ad1	c6 84 05 e4 fe
	ff ff 01	 mov	 BYTE PTR _loopWeightMin$[ebp+eax], 1

; 647  :               loopWeightMin[vLine + (2*width-1)] = 1;

  00ad9	8b 4d e4	 mov	 ecx, DWORD PTR _width$[ebp]
  00adc	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR _vLine$6[ebp]
  00ae2	8d 44 4a ff	 lea	 eax, DWORD PTR [edx+ecx*2-1]
  00ae6	c6 84 05 e4 fe
	ff ff 01	 mov	 BYTE PTR _loopWeightMin$[ebp+eax], 1

; 648  :               loopWeightMin[hLine-1 + (2*width-1)] = 1;

  00aee	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _hLine$7[ebp]
  00af4	8d 94 0d e3 fe
	ff ff		 lea	 edx, DWORD PTR _loopWeightMin$[ebp+ecx-1]
  00afb	8b 45 e4	 mov	 eax, DWORD PTR _width$[ebp]
  00afe	c6 44 42 ff 01	 mov	 BYTE PTR [edx+eax*2-1], 1

; 649  :               loopWeightMin[hLine-1] = 1;

  00b03	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _hLine$7[ebp]
  00b09	c6 84 0d e3 fe
	ff ff 01	 mov	 BYTE PTR _loopWeightMin$[ebp+ecx-1], 1

; 650  :               loopWeightMin[vLine - (2*width-1)] = 1;

  00b11	8b 55 e4	 mov	 edx, DWORD PTR _width$[ebp]
  00b14	8d 44 12 ff	 lea	 eax, DWORD PTR [edx+edx-1]
  00b18	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR _vLine$6[ebp]
  00b1e	2b c8		 sub	 ecx, eax
  00b20	c6 84 0d e4 fe
	ff ff 01	 mov	 BYTE PTR _loopWeightMin$[ebp+ecx], 1
$LN57@ComputeBre:

; 651  :             };
; 652  :             m_breakUpLoopsWeight[hLine] += weight;

  00b28	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00b2b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00b2e	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _hLine$7[ebp]
  00b34	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  00b37	03 95 b8 fe ff
	ff		 add	 edx, DWORD PTR _weight$2[ebp]
  00b3d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00b40	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00b43	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _hLine$7[ebp]
  00b49	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 653  :             m_breakUpLoopsWeight[hLine + (2*width-1)] += weight;

  00b4c	8b 4d e4	 mov	 ecx, DWORD PTR _width$[ebp]
  00b4f	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR _hLine$7[ebp]
  00b55	8d 44 4a ff	 lea	 eax, DWORD PTR [edx+ecx*2-1]
  00b59	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b5c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00b5f	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  00b62	03 85 b8 fe ff
	ff		 add	 eax, DWORD PTR _weight$2[ebp]
  00b68	8b 4d e4	 mov	 ecx, DWORD PTR _width$[ebp]
  00b6b	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR _hLine$7[ebp]
  00b71	8d 4c 4a ff	 lea	 ecx, DWORD PTR [edx+ecx*2-1]
  00b75	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00b78	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00b7b	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 654  :             m_breakUpLoopsWeight[vLine + (2*width-1)] += weight;

  00b7e	8b 45 e4	 mov	 eax, DWORD PTR _width$[ebp]
  00b81	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR _vLine$6[ebp]
  00b87	8d 54 41 ff	 lea	 edx, DWORD PTR [ecx+eax*2-1]
  00b8b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00b8e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00b91	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  00b94	03 95 b8 fe ff
	ff		 add	 edx, DWORD PTR _weight$2[ebp]
  00b9a	8b 45 e4	 mov	 eax, DWORD PTR _width$[ebp]
  00b9d	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR _vLine$6[ebp]
  00ba3	8d 44 41 ff	 lea	 eax, DWORD PTR [ecx+eax*2-1]
  00ba7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00baa	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00bad	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 655  :             m_breakUpLoopsWeight[hLine-1 + (2*width-1)] += weight;

  00bb0	8b 55 e4	 mov	 edx, DWORD PTR _width$[ebp]
  00bb3	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _hLine$7[ebp]
  00bb9	8d 4c 50 fe	 lea	 ecx, DWORD PTR [eax+edx*2-2]
  00bbd	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00bc0	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00bc3	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  00bc6	03 8d b8 fe ff
	ff		 add	 ecx, DWORD PTR _weight$2[ebp]
  00bcc	8b 55 e4	 mov	 edx, DWORD PTR _width$[ebp]
  00bcf	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _hLine$7[ebp]
  00bd5	8d 54 50 fe	 lea	 edx, DWORD PTR [eax+edx*2-2]
  00bd9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00bdc	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00bdf	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 656  :             m_breakUpLoopsWeight[hLine-1] += weight;

  00be2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00be5	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00be8	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _hLine$7[ebp]
  00bee	8b 4c 82 fc	 mov	 ecx, DWORD PTR [edx+eax*4-4]
  00bf2	03 8d b8 fe ff
	ff		 add	 ecx, DWORD PTR _weight$2[ebp]
  00bf8	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00bfb	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00bfe	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR _hLine$7[ebp]
  00c04	89 4c 90 fc	 mov	 DWORD PTR [eax+edx*4-4], ecx

; 657  :             m_breakUpLoopsWeight[vLine - (2*width-1)] += weight;

  00c08	8b 45 e4	 mov	 eax, DWORD PTR _width$[ebp]
  00c0b	8d 4c 00 ff	 lea	 ecx, DWORD PTR [eax+eax-1]
  00c0f	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR _vLine$6[ebp]
  00c15	2b d1		 sub	 edx, ecx
  00c17	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00c1a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00c1d	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  00c20	03 95 b8 fe ff
	ff		 add	 edx, DWORD PTR _weight$2[ebp]
  00c26	8b 45 e4	 mov	 eax, DWORD PTR _width$[ebp]
  00c29	8d 4c 00 ff	 lea	 ecx, DWORD PTR [eax+eax-1]
  00c2d	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _vLine$6[ebp]
  00c33	2b c1		 sub	 eax, ecx
  00c35	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00c38	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00c3b	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
$LN45@ComputeBre:

; 658  :           };
; 659  :         };
; 660  :       };

  00c3e	e9 a5 f7 ff ff	 jmp	 $LN11@ComputeBre
$LN12@ComputeBre:

; 661  :     };

  00c43	e9 7f f7 ff ff	 jmp	 $LN8@ComputeBre
$LN9@ComputeBre:

; 662  :     for (int i=0; i<numEdge; i++)

  00c48	c7 85 b4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$1[ebp], 0
  00c52	eb 0f		 jmp	 SHORT $LN16@ComputeBre
$LN14@ComputeBre:
  00c54	8b 95 b4 fe ff
	ff		 mov	 edx, DWORD PTR _i$1[ebp]
  00c5a	83 c2 01	 add	 edx, 1
  00c5d	89 95 b4 fe ff
	ff		 mov	 DWORD PTR _i$1[ebp], edx
$LN16@ComputeBre:
  00c63	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  00c69	3b 45 dc	 cmp	 eax, DWORD PTR _numEdge$[ebp]
  00c6c	7d 4f		 jge	 SHORT $LN15@ComputeBre

; 663  :     {
; 664  :       if ((m_avoidFlgs[i]&(AV_OCCUPIED|AV_SACRIFICE)) != 0)

  00c6e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00c71	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00c74	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  00c7a	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  00c7e	83 e1 03	 and	 ecx, 3
  00c81	74 13		 je	 SHORT $LN58@ComputeBre

; 665  :       {
; 666  :         m_breakUpLoopsWeight[i] = 0;

  00c83	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00c86	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00c89	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR _i$1[ebp]
  00c8f	c7 04 88 00 00
	00 00		 mov	 DWORD PTR [eax+ecx*4], 0
$LN58@ComputeBre:

; 667  :       };
; 668  :       if (loopWeightMin[i] == 0)

  00c96	8b 95 b4 fe ff
	ff		 mov	 edx, DWORD PTR _i$1[ebp]
  00c9c	0f be 84 15 e4
	fe ff ff	 movsx	 eax, BYTE PTR _loopWeightMin$[ebp+edx]
  00ca4	85 c0		 test	 eax, eax
  00ca6	75 13		 jne	 SHORT $LN59@ComputeBre

; 669  :       {
; 670  :         m_breakUpLoopsWeight[i] = 0;

  00ca8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00cab	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00cae	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  00cb4	c7 04 82 00 00
	00 00		 mov	 DWORD PTR [edx+eax*4], 0
$LN59@ComputeBre:

; 671  :       };
; 672  :     };

  00cbb	eb 97		 jmp	 SHORT $LN14@ComputeBre
$LN15@ComputeBre:

; 673  :     m_loopWeightsValid = true;

  00cbd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00cc0	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1
$LN1@ComputeBre:

; 674  :   };
; 675  : }

  00cc4	52		 push	 edx
  00cc5	8b cd		 mov	 ecx, ebp
  00cc7	50		 push	 eax
  00cc8	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN64@ComputeBre
  00cce	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00cd3	58		 pop	 eax
  00cd4	5a		 pop	 edx
  00cd5	5f		 pop	 edi
  00cd6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00cd9	33 cd		 xor	 ecx, ebp
  00cdb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ce0	81 c4 4c 01 00
	00		 add	 esp, 332		; 0000014cH
  00ce6	3b ec		 cmp	 ebp, esp
  00ce8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00ced	8b e5		 mov	 esp, ebp
  00cef	5d		 pop	 ebp
  00cf0	c2 04 00	 ret	 4
  00cf3	90		 npad	 1
$LN64@ComputeBre:
  00cf4	02 00 00 00	 DD	 2
  00cf8	00 00 00 00	 DD	 $LN63@ComputeBre
$LN63@ComputeBre:
  00cfc	ec ff ff ff	 DD	 -20			; ffffffecH
  00d00	08 00 00 00	 DD	 8
  00d04	00 00 00 00	 DD	 $LN61@ComputeBre
  00d08	e4 fe ff ff	 DD	 -284			; fffffee4H
  00d0c	f1 00 00 00	 DD	 241			; 000000f1H
  00d10	00 00 00 00	 DD	 $LN62@ComputeBre
$LN62@ComputeBre:
  00d14	6c		 DB	 108			; 0000006cH
  00d15	6f		 DB	 111			; 0000006fH
  00d16	6f		 DB	 111			; 0000006fH
  00d17	70		 DB	 112			; 00000070H
  00d18	57		 DB	 87			; 00000057H
  00d19	65		 DB	 101			; 00000065H
  00d1a	69		 DB	 105			; 00000069H
  00d1b	67		 DB	 103			; 00000067H
  00d1c	68		 DB	 104			; 00000068H
  00d1d	74		 DB	 116			; 00000074H
  00d1e	4d		 DB	 77			; 0000004dH
  00d1f	69		 DB	 105			; 00000069H
  00d20	6e		 DB	 110			; 0000006eH
  00d21	00		 DB	 0
$LN61@ComputeBre:
  00d22	64		 DB	 100			; 00000064H
  00d23	6f		 DB	 111			; 0000006fH
  00d24	74		 DB	 116			; 00000074H
  00d25	4e		 DB	 78			; 0000004eH
  00d26	75		 DB	 117			; 00000075H
  00d27	6d		 DB	 109			; 0000006dH
  00d28	00		 DB	 0
?ComputeBreakUpLoopWeights@DOTS_AND_BOXES@@QAEXH@Z ENDP	; DOTS_AND_BOXES::ComputeBreakUpLoopWeights
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
_numEdge$1 = -53044					; size = 4
_maxWeight$2 = -53040					; size = 4
_divide$ = -53032					; size = 51944
_weights$ = -1080					; size = 964
_dst$ = -108						; size = 40
_src$ = -60						; size = 40
_numEdges$ = -16					; size = 4
_i$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?ComputeDivideAndConquerWeights_3@DOTS_AND_BOXES@@QAEXXZ PROC ; DOTS_AND_BOXES::ComputeDivideAndConquerWeights_3
; _this$ = ecx

; 1015 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 34 cf 00 00	 mov	 eax, 53044		; 0000cf34H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	51		 push	 ecx
  00010	8d bd cc 30 ff
	ff		 lea	 edi, DWORD PTR [ebp-53044]
  00016	b9 cd 33 00 00	 mov	 ecx, 13261		; 000033cdH
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	59		 pop	 ecx
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00028	33 c5		 xor	 eax, ebp
  0002a	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1016 :   int i, numEdges;
; 1017 :   int src[10], dst[10];
; 1018 :   int weights[MAX_EDGES];
; 1019 :   if (m_divideWeightsValid) return;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00033	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00037	85 c9		 test	 ecx, ecx
  00039	74 05		 je	 SHORT $LN35@ComputeDiv
  0003b	e9 c8 03 00 00	 jmp	 $LN1@ComputeDiv
$LN35@ComputeDiv:

; 1020 :   numEdges = Width()*(Height()-1) + Height()*(Width()-1);

  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?Width@DOTS_AND_BOXES@@QBEHXZ ; DOTS_AND_BOXES::Width
  00048	8b f0		 mov	 esi, eax
  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?Height@DOTS_AND_BOXES@@QBEHXZ ; DOTS_AND_BOXES::Height
  00052	83 e8 01	 sub	 eax, 1
  00055	0f af f0	 imul	 esi, eax
  00058	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ?Height@DOTS_AND_BOXES@@QBEHXZ ; DOTS_AND_BOXES::Height
  00060	8b f8		 mov	 edi, eax
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	e8 00 00 00 00	 call	 ?Width@DOTS_AND_BOXES@@QBEHXZ ; DOTS_AND_BOXES::Width
  0006a	83 e8 01	 sub	 eax, 1
  0006d	0f af f8	 imul	 edi, eax
  00070	03 f7		 add	 esi, edi
  00072	89 75 f0	 mov	 DWORD PTR _numEdges$[ebp], esi

; 1021 :   for (i=0; i<numEdges; i++) weights[i] = 999999999;

  00075	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0007c	eb 09		 jmp	 SHORT $LN4@ComputeDiv
$LN2@ComputeDiv:
  0007e	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00081	83 c2 01	 add	 edx, 1
  00084	89 55 f4	 mov	 DWORD PTR _i$[ebp], edx
$LN4@ComputeDiv:
  00087	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0008a	3b 45 f0	 cmp	 eax, DWORD PTR _numEdges$[ebp]
  0008d	7d 10		 jge	 SHORT $LN3@ComputeDiv
  0008f	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00092	c7 84 8d c8 fb
	ff ff ff c9 9a
	3b		 mov	 DWORD PTR _weights$[ebp+ecx*4], 999999999 ; 3b9ac9ffH
  0009d	eb df		 jmp	 SHORT $LN2@ComputeDiv
$LN3@ComputeDiv:

; 1022 :   FindAvoids();

  0009f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	e8 00 00 00 00	 call	 ?FindAvoids@DOTS_AND_BOXES@@QAEXXZ ; DOTS_AND_BOXES::FindAvoids

; 1023 :   DIVIDE_3 divide(this);

  000a7	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000aa	52		 push	 edx
  000ab	8d 8d d8 30 ff
	ff		 lea	 ecx, DWORD PTR _divide$[ebp]
  000b1	e8 00 00 00 00	 call	 ??0DIVIDE_3@@QAE@PBVDOTS_AND_BOXES@@@Z ; DIVIDE_3::DIVIDE_3

; 1024 :   //
; 1025 :   // Small line at top to long line at bottom
; 1026 :   for (i=2; i<m_width-2; i++) src[i-2] = i;

  000b6	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _i$[ebp], 2
  000bd	eb 09		 jmp	 SHORT $LN7@ComputeDiv
$LN5@ComputeDiv:
  000bf	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000c2	83 c0 01	 add	 eax, 1
  000c5	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN7@ComputeDiv:
  000c8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000ce	83 ea 02	 sub	 edx, 2
  000d1	39 55 f4	 cmp	 DWORD PTR _i$[ebp], edx
  000d4	7d 0c		 jge	 SHORT $LN6@ComputeDiv
  000d6	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000d9	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  000dc	89 4c 85 bc	 mov	 DWORD PTR _src$[ebp+eax*4-8], ecx
  000e0	eb dd		 jmp	 SHORT $LN5@ComputeDiv
$LN6@ComputeDiv:

; 1027 :   src[i-2] = -1;

  000e2	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000e5	c7 44 95 bc ff
	ff ff ff	 mov	 DWORD PTR _src$[ebp+edx*4-8], -1

; 1028 :   for (i=1; i<m_width-1; i++) dst[i-1] = (m_height-1)*m_width+i;

  000ed	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  000f4	eb 09		 jmp	 SHORT $LN10@ComputeDiv
$LN8@ComputeDiv:
  000f6	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000f9	83 c0 01	 add	 eax, 1
  000fc	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN10@ComputeDiv:
  000ff	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00102	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00105	83 ea 01	 sub	 edx, 1
  00108	39 55 f4	 cmp	 DWORD PTR _i$[ebp], edx
  0010b	7d 1c		 jge	 SHORT $LN9@ComputeDiv
  0010d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00110	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00113	83 e9 01	 sub	 ecx, 1
  00116	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00119	0f af 4a 10	 imul	 ecx, DWORD PTR [edx+16]
  0011d	03 4d f4	 add	 ecx, DWORD PTR _i$[ebp]
  00120	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00123	89 4c 85 90	 mov	 DWORD PTR _dst$[ebp+eax*4-4], ecx
  00127	eb cd		 jmp	 SHORT $LN8@ComputeDiv
$LN9@ComputeDiv:

; 1029 :   dst[i-1] = -1;

  00129	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0012c	c7 44 8d 90 ff
	ff ff ff	 mov	 DWORD PTR _dst$[ebp+ecx*4-4], -1

; 1030 :   divide.FindWeights(src, dst, weights);

  00134	8d 95 c8 fb ff
	ff		 lea	 edx, DWORD PTR _weights$[ebp]
  0013a	52		 push	 edx
  0013b	8d 45 94	 lea	 eax, DWORD PTR _dst$[ebp]
  0013e	50		 push	 eax
  0013f	8d 4d c4	 lea	 ecx, DWORD PTR _src$[ebp]
  00142	51		 push	 ecx
  00143	8d 8d d8 30 ff
	ff		 lea	 ecx, DWORD PTR _divide$[ebp]
  00149	e8 00 00 00 00	 call	 ?FindWeights@DIVIDE_3@@QAEXPAH00@Z ; DIVIDE_3::FindWeights

; 1031 :   // Small line at bottom to long line at top
; 1032 :   for (i=1; i<m_width-1; i++) src[i-1] = i;

  0014e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00155	eb 09		 jmp	 SHORT $LN13@ComputeDiv
$LN11@ComputeDiv:
  00157	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  0015a	83 c2 01	 add	 edx, 1
  0015d	89 55 f4	 mov	 DWORD PTR _i$[ebp], edx
$LN13@ComputeDiv:
  00160	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00163	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00166	83 e9 01	 sub	 ecx, 1
  00169	39 4d f4	 cmp	 DWORD PTR _i$[ebp], ecx
  0016c	7d 0c		 jge	 SHORT $LN12@ComputeDiv
  0016e	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00171	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00174	89 44 95 c0	 mov	 DWORD PTR _src$[ebp+edx*4-4], eax
  00178	eb dd		 jmp	 SHORT $LN11@ComputeDiv
$LN12@ComputeDiv:

; 1033 :   src[i-1] = -1;

  0017a	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0017d	c7 44 8d c0 ff
	ff ff ff	 mov	 DWORD PTR _src$[ebp+ecx*4-4], -1

; 1034 :   for (i=2; i<m_width-2; i++) dst[i-2] = (m_height-1)*m_width+i;

  00185	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _i$[ebp], 2
  0018c	eb 09		 jmp	 SHORT $LN16@ComputeDiv
$LN14@ComputeDiv:
  0018e	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00191	83 c2 01	 add	 edx, 1
  00194	89 55 f4	 mov	 DWORD PTR _i$[ebp], edx
$LN16@ComputeDiv:
  00197	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0019a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0019d	83 e9 02	 sub	 ecx, 2
  001a0	39 4d f4	 cmp	 DWORD PTR _i$[ebp], ecx
  001a3	7d 1c		 jge	 SHORT $LN15@ComputeDiv
  001a5	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001a8	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  001ab	83 e8 01	 sub	 eax, 1
  001ae	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b1	0f af 41 10	 imul	 eax, DWORD PTR [ecx+16]
  001b5	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  001b8	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  001bb	89 44 95 8c	 mov	 DWORD PTR _dst$[ebp+edx*4-8], eax
  001bf	eb cd		 jmp	 SHORT $LN14@ComputeDiv
$LN15@ComputeDiv:

; 1035 :   dst[i-2] = -1;

  001c1	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  001c4	c7 44 85 8c ff
	ff ff ff	 mov	 DWORD PTR _dst$[ebp+eax*4-8], -1

; 1036 :   divide.FindWeights(src, dst, weights);

  001cc	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR _weights$[ebp]
  001d2	51		 push	 ecx
  001d3	8d 55 94	 lea	 edx, DWORD PTR _dst$[ebp]
  001d6	52		 push	 edx
  001d7	8d 45 c4	 lea	 eax, DWORD PTR _src$[ebp]
  001da	50		 push	 eax
  001db	8d 8d d8 30 ff
	ff		 lea	 ecx, DWORD PTR _divide$[ebp]
  001e1	e8 00 00 00 00	 call	 ?FindWeights@DIVIDE_3@@QAEXPAH00@Z ; DIVIDE_3::FindWeights

; 1037 :   // Small line at left to long line at right
; 1038 :   for (i=2; i<m_height-2; i++) src[i-2] = m_width*i;

  001e6	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _i$[ebp], 2
  001ed	eb 09		 jmp	 SHORT $LN19@ComputeDiv
$LN17@ComputeDiv:
  001ef	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  001f2	83 c1 01	 add	 ecx, 1
  001f5	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$LN19@ComputeDiv:
  001f8	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001fb	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  001fe	83 e8 02	 sub	 eax, 2
  00201	39 45 f4	 cmp	 DWORD PTR _i$[ebp], eax
  00204	7d 13		 jge	 SHORT $LN18@ComputeDiv
  00206	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00209	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0020c	0f af 55 f4	 imul	 edx, DWORD PTR _i$[ebp]
  00210	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00213	89 54 85 bc	 mov	 DWORD PTR _src$[ebp+eax*4-8], edx
  00217	eb d6		 jmp	 SHORT $LN17@ComputeDiv
$LN18@ComputeDiv:

; 1039 :   src[i-2] = -1;

  00219	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0021c	c7 44 8d bc ff
	ff ff ff	 mov	 DWORD PTR _src$[ebp+ecx*4-8], -1

; 1040 :   for (i=1; i<m_height-1; i++) dst[i-1] = m_width*(i+1)-1;

  00224	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  0022b	eb 09		 jmp	 SHORT $LN22@ComputeDiv
$LN20@ComputeDiv:
  0022d	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00230	83 c2 01	 add	 edx, 1
  00233	89 55 f4	 mov	 DWORD PTR _i$[ebp], edx
$LN22@ComputeDiv:
  00236	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00239	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0023c	83 e9 01	 sub	 ecx, 1
  0023f	39 4d f4	 cmp	 DWORD PTR _i$[ebp], ecx
  00242	7d 19		 jge	 SHORT $LN21@ComputeDiv
  00244	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00247	83 c2 01	 add	 edx, 1
  0024a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0024d	0f af 50 10	 imul	 edx, DWORD PTR [eax+16]
  00251	83 ea 01	 sub	 edx, 1
  00254	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00257	89 54 8d 90	 mov	 DWORD PTR _dst$[ebp+ecx*4-4], edx
  0025b	eb d0		 jmp	 SHORT $LN20@ComputeDiv
$LN21@ComputeDiv:

; 1041 :   dst[i-1] = -1;

  0025d	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00260	c7 44 95 90 ff
	ff ff ff	 mov	 DWORD PTR _dst$[ebp+edx*4-4], -1

; 1042 :   divide.FindWeights(src, dst, weights);

  00268	8d 85 c8 fb ff
	ff		 lea	 eax, DWORD PTR _weights$[ebp]
  0026e	50		 push	 eax
  0026f	8d 4d 94	 lea	 ecx, DWORD PTR _dst$[ebp]
  00272	51		 push	 ecx
  00273	8d 55 c4	 lea	 edx, DWORD PTR _src$[ebp]
  00276	52		 push	 edx
  00277	8d 8d d8 30 ff
	ff		 lea	 ecx, DWORD PTR _divide$[ebp]
  0027d	e8 00 00 00 00	 call	 ?FindWeights@DIVIDE_3@@QAEXPAH00@Z ; DIVIDE_3::FindWeights

; 1043 :   // Small line at left to long line at right
; 1044 :   for (i=2; i<m_height-2; i++) src[i-2] = m_width*i;

  00282	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _i$[ebp], 2
  00289	eb 09		 jmp	 SHORT $LN25@ComputeDiv
$LN23@ComputeDiv:
  0028b	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0028e	83 c0 01	 add	 eax, 1
  00291	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN25@ComputeDiv:
  00294	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00297	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0029a	83 ea 02	 sub	 edx, 2
  0029d	39 55 f4	 cmp	 DWORD PTR _i$[ebp], edx
  002a0	7d 13		 jge	 SHORT $LN24@ComputeDiv
  002a2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002a5	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  002a8	0f af 4d f4	 imul	 ecx, DWORD PTR _i$[ebp]
  002ac	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  002af	89 4c 95 bc	 mov	 DWORD PTR _src$[ebp+edx*4-8], ecx
  002b3	eb d6		 jmp	 SHORT $LN23@ComputeDiv
$LN24@ComputeDiv:

; 1045 :   src[i-2] = -1;

  002b5	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  002b8	c7 44 85 bc ff
	ff ff ff	 mov	 DWORD PTR _src$[ebp+eax*4-8], -1

; 1046 :   for (i=1; i<m_height-1; i++) dst[i-1] = m_width*(i+1)-1;

  002c0	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  002c7	eb 09		 jmp	 SHORT $LN28@ComputeDiv
$LN26@ComputeDiv:
  002c9	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  002cc	83 c1 01	 add	 ecx, 1
  002cf	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$LN28@ComputeDiv:
  002d2	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  002d5	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  002d8	83 e8 01	 sub	 eax, 1
  002db	39 45 f4	 cmp	 DWORD PTR _i$[ebp], eax
  002de	7d 19		 jge	 SHORT $LN27@ComputeDiv
  002e0	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  002e3	83 c1 01	 add	 ecx, 1
  002e6	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  002e9	0f af 4a 10	 imul	 ecx, DWORD PTR [edx+16]
  002ed	83 e9 01	 sub	 ecx, 1
  002f0	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  002f3	89 4c 85 90	 mov	 DWORD PTR _dst$[ebp+eax*4-4], ecx
  002f7	eb d0		 jmp	 SHORT $LN26@ComputeDiv
$LN27@ComputeDiv:

; 1047 :   dst[i-1] = -1;

  002f9	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  002fc	c7 44 8d 90 ff
	ff ff ff	 mov	 DWORD PTR _dst$[ebp+ecx*4-4], -1

; 1048 :   divide.FindWeights(src, dst, weights);

  00304	8d 95 c8 fb ff
	ff		 lea	 edx, DWORD PTR _weights$[ebp]
  0030a	52		 push	 edx
  0030b	8d 45 94	 lea	 eax, DWORD PTR _dst$[ebp]
  0030e	50		 push	 eax
  0030f	8d 4d c4	 lea	 ecx, DWORD PTR _src$[ebp]
  00312	51		 push	 ecx
  00313	8d 8d d8 30 ff
	ff		 lea	 ecx, DWORD PTR _divide$[ebp]
  00319	e8 00 00 00 00	 call	 ?FindWeights@DIVIDE_3@@QAEXPAH00@Z ; DIVIDE_3::FindWeights

; 1049 :   //Simply move the weights into m_divideAndConquerWeight
; 1050 :   {
; 1051 :     int maxWeight, numEdge;
; 1052 :     numEdge = (m_width-1)*m_height + (m_height-1)*m_width;

  0031e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00321	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00324	83 e8 01	 sub	 eax, 1
  00327	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0032a	0f af 41 14	 imul	 eax, DWORD PTR [ecx+20]
  0032e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00331	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  00334	83 e9 01	 sub	 ecx, 1
  00337	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0033a	0f af 4a 10	 imul	 ecx, DWORD PTR [edx+16]
  0033e	03 c1		 add	 eax, ecx
  00340	89 85 cc 30 ff
	ff		 mov	 DWORD PTR _numEdge$1[ebp], eax

; 1053 :     maxWeight = 0;

  00346	c7 85 d0 30 ff
	ff 00 00 00 00	 mov	 DWORD PTR _maxWeight$2[ebp], 0

; 1054 :     for (i=0; i<numEdge; i++)

  00350	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00357	eb 09		 jmp	 SHORT $LN31@ComputeDiv
$LN29@ComputeDiv:
  00359	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0035c	83 c0 01	 add	 eax, 1
  0035f	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN31@ComputeDiv:
  00362	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00365	3b 8d cc 30 ff
	ff		 cmp	 ecx, DWORD PTR _numEdge$1[ebp]
  0036b	7d 36		 jge	 SHORT $LN30@ComputeDiv

; 1055 :     {
; 1056 :       if (weights[i] == 999999999) continue;

  0036d	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00370	81 bc 95 c8 fb
	ff ff ff c9 9a
	3b		 cmp	 DWORD PTR _weights$[ebp+edx*4], 999999999 ; 3b9ac9ffH
  0037b	75 02		 jne	 SHORT $LN36@ComputeDiv
  0037d	eb da		 jmp	 SHORT $LN29@ComputeDiv
$LN36@ComputeDiv:

; 1057 :       if (weights[i] > maxWeight) maxWeight = weights[i];

  0037f	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00382	8b 8c 85 c8 fb
	ff ff		 mov	 ecx, DWORD PTR _weights$[ebp+eax*4]
  00389	3b 8d d0 30 ff
	ff		 cmp	 ecx, DWORD PTR _maxWeight$2[ebp]
  0038f	7e 10		 jle	 SHORT $LN37@ComputeDiv
  00391	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00394	8b 84 95 c8 fb
	ff ff		 mov	 eax, DWORD PTR _weights$[ebp+edx*4]
  0039b	89 85 d0 30 ff
	ff		 mov	 DWORD PTR _maxWeight$2[ebp], eax
$LN37@ComputeDiv:

; 1058 :     };

  003a1	eb b6		 jmp	 SHORT $LN29@ComputeDiv
$LN30@ComputeDiv:

; 1059 :     for (i=0; i<numEdge; i++)

  003a3	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  003aa	eb 09		 jmp	 SHORT $LN34@ComputeDiv
$LN32@ComputeDiv:
  003ac	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  003af	83 c1 01	 add	 ecx, 1
  003b2	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$LN34@ComputeDiv:
  003b5	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  003b8	3b 95 cc 30 ff
	ff		 cmp	 edx, DWORD PTR _numEdge$1[ebp]
  003be	7d 41		 jge	 SHORT $LN33@ComputeDiv

; 1060 :     {
; 1061 :       if (weights[i] == 999999999) m_divideAndConquerWeight[i] = 0;

  003c0	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  003c3	81 bc 85 c8 fb
	ff ff ff c9 9a
	3b		 cmp	 DWORD PTR _weights$[ebp+eax*4], 999999999 ; 3b9ac9ffH
  003ce	75 11		 jne	 SHORT $LN38@ComputeDiv
  003d0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003d3	8b 11		 mov	 edx, DWORD PTR [ecx]
  003d5	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  003d8	c7 04 82 00 00
	00 00		 mov	 DWORD PTR [edx+eax*4], 0
  003df	eb 1e		 jmp	 SHORT $LN39@ComputeDiv
$LN38@ComputeDiv:

; 1062 :       else m_divideAndConquerWeight[i] = maxWeight+1-weights[i];

  003e1	8b 8d d0 30 ff
	ff		 mov	 ecx, DWORD PTR _maxWeight$2[ebp]
  003e7	83 c1 01	 add	 ecx, 1
  003ea	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  003ed	2b 8c 95 c8 fb
	ff ff		 sub	 ecx, DWORD PTR _weights$[ebp+edx*4]
  003f4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003f7	8b 10		 mov	 edx, DWORD PTR [eax]
  003f9	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  003fc	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx
$LN39@ComputeDiv:

; 1063 :     };

  003ff	eb ab		 jmp	 SHORT $LN32@ComputeDiv
$LN33@ComputeDiv:

; 1064 :   };
; 1065 :   m_divideWeightsValid = true;

  00401	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00404	c6 41 04 01	 mov	 BYTE PTR [ecx+4], 1
$LN1@ComputeDiv:

; 1066 : }

  00408	52		 push	 edx
  00409	8b cd		 mov	 ecx, ebp
  0040b	50		 push	 eax
  0040c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN46@ComputeDiv
  00412	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00417	58		 pop	 eax
  00418	5a		 pop	 edx
  00419	5f		 pop	 edi
  0041a	5e		 pop	 esi
  0041b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0041e	33 cd		 xor	 ecx, ebp
  00420	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00425	81 c4 34 cf 00
	00		 add	 esp, 53044		; 0000cf34H
  0042b	3b ec		 cmp	 ebp, esp
  0042d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00432	8b e5		 mov	 esp, ebp
  00434	5d		 pop	 ebp
  00435	c3		 ret	 0
  00436	66 90		 npad	 2
$LN46@ComputeDiv:
  00438	04 00 00 00	 DD	 4
  0043c	00 00 00 00	 DD	 $LN45@ComputeDiv
$LN45@ComputeDiv:
  00440	c4 ff ff ff	 DD	 -60			; ffffffc4H
  00444	28 00 00 00	 DD	 40			; 00000028H
  00448	00 00 00 00	 DD	 $LN41@ComputeDiv
  0044c	94 ff ff ff	 DD	 -108			; ffffff94H
  00450	28 00 00 00	 DD	 40			; 00000028H
  00454	00 00 00 00	 DD	 $LN42@ComputeDiv
  00458	c8 fb ff ff	 DD	 -1080			; fffffbc8H
  0045c	c4 03 00 00	 DD	 964			; 000003c4H
  00460	00 00 00 00	 DD	 $LN43@ComputeDiv
  00464	d8 30 ff ff	 DD	 -53032			; ffff30d8H
  00468	e8 ca 00 00	 DD	 51944			; 0000cae8H
  0046c	00 00 00 00	 DD	 $LN44@ComputeDiv
$LN44@ComputeDiv:
  00470	64		 DB	 100			; 00000064H
  00471	69		 DB	 105			; 00000069H
  00472	76		 DB	 118			; 00000076H
  00473	69		 DB	 105			; 00000069H
  00474	64		 DB	 100			; 00000064H
  00475	65		 DB	 101			; 00000065H
  00476	00		 DB	 0
$LN43@ComputeDiv:
  00477	77		 DB	 119			; 00000077H
  00478	65		 DB	 101			; 00000065H
  00479	69		 DB	 105			; 00000069H
  0047a	67		 DB	 103			; 00000067H
  0047b	68		 DB	 104			; 00000068H
  0047c	74		 DB	 116			; 00000074H
  0047d	73		 DB	 115			; 00000073H
  0047e	00		 DB	 0
$LN42@ComputeDiv:
  0047f	64		 DB	 100			; 00000064H
  00480	73		 DB	 115			; 00000073H
  00481	74		 DB	 116			; 00000074H
  00482	00		 DB	 0
$LN41@ComputeDiv:
  00483	73		 DB	 115			; 00000073H
  00484	72		 DB	 114			; 00000072H
  00485	63		 DB	 99			; 00000063H
  00486	00		 DB	 0
?ComputeDivideAndConquerWeights_3@DOTS_AND_BOXES@@QAEXXZ ENDP ; DOTS_AND_BOXES::ComputeDivideAndConquerWeights_3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
_dot$ = -16						; size = 8
_this$ = -4						; size = 4
?IsFinished@DOTS_AND_BOXES@@QBE_NXZ PROC		; DOTS_AND_BOXES::IsFinished
; _this$ = ecx

; 398  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 399  :   VECTOR dot;

  0001d	8d 4d f0	 lea	 ecx, DWORD PTR _dot$[ebp]
  00020	e8 00 00 00 00	 call	 ??0VECTOR@@QAE@XZ	; VECTOR::VECTOR

; 400  :   for (dot.y=0; dot.y<m_height; dot.y++)

  00025	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dot$[ebp+4], 0
  0002c	eb 09		 jmp	 SHORT $LN4@IsFinished
$LN2@IsFinished:
  0002e	8b 45 f4	 mov	 eax, DWORD PTR _dot$[ebp+4]
  00031	83 c0 01	 add	 eax, 1
  00034	89 45 f4	 mov	 DWORD PTR _dot$[ebp+4], eax
$LN4@IsFinished:
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	8b 55 f4	 mov	 edx, DWORD PTR _dot$[ebp+4]
  0003d	3b 51 14	 cmp	 edx, DWORD PTR [ecx+20]
  00040	7d 65		 jge	 SHORT $LN3@IsFinished

; 401  :   {
; 402  :     for (dot.x=0; dot.x<m_width; dot.x++)

  00042	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dot$[ebp], 0
  00049	eb 09		 jmp	 SHORT $LN7@IsFinished
$LN5@IsFinished:
  0004b	8b 45 f0	 mov	 eax, DWORD PTR _dot$[ebp]
  0004e	83 c0 01	 add	 eax, 1
  00051	89 45 f0	 mov	 DWORD PTR _dot$[ebp], eax
$LN7@IsFinished:
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	8b 55 f0	 mov	 edx, DWORD PTR _dot$[ebp]
  0005a	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  0005d	7d 46		 jge	 SHORT $LN6@IsFinished

; 403  :     {
; 404  :       if (dot.x < m_width-1)

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00065	83 e9 01	 sub	 ecx, 1
  00068	39 4d f0	 cmp	 DWORD PTR _dot$[ebp], ecx
  0006b	7d 14		 jge	 SHORT $LN8@IsFinished

; 405  :       {
; 406  :         if (HLineType(dot) == LINE_NONE) return false;

  0006d	8d 55 f0	 lea	 edx, DWORD PTR _dot$[ebp]
  00070	52		 push	 edx
  00071	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::HLineType
  00079	85 c0		 test	 eax, eax
  0007b	75 04		 jne	 SHORT $LN8@IsFinished
  0007d	32 c0		 xor	 al, al
  0007f	eb 28		 jmp	 SHORT $LN1@IsFinished
$LN8@IsFinished:

; 407  :       };
; 408  :       if (dot.y < m_height-1)

  00081	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00084	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00087	83 e9 01	 sub	 ecx, 1
  0008a	39 4d f4	 cmp	 DWORD PTR _dot$[ebp+4], ecx
  0008d	7d 14		 jge	 SHORT $LN10@IsFinished

; 409  :       {
; 410  :         if (VLineType(dot) == LINE_NONE) return false;

  0008f	8d 55 f0	 lea	 edx, DWORD PTR _dot$[ebp]
  00092	52		 push	 edx
  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::VLineType
  0009b	85 c0		 test	 eax, eax
  0009d	75 04		 jne	 SHORT $LN10@IsFinished
  0009f	32 c0		 xor	 al, al
  000a1	eb 06		 jmp	 SHORT $LN1@IsFinished
$LN10@IsFinished:

; 411  :       };
; 412  :     };

  000a3	eb a6		 jmp	 SHORT $LN5@IsFinished
$LN6@IsFinished:

; 413  :   };

  000a5	eb 87		 jmp	 SHORT $LN2@IsFinished
$LN3@IsFinished:

; 414  :   return true;

  000a7	b0 01		 mov	 al, 1
$LN1@IsFinished:

; 415  : }

  000a9	52		 push	 edx
  000aa	8b cd		 mov	 ecx, ebp
  000ac	50		 push	 eax
  000ad	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@IsFinished
  000b3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000b8	58		 pop	 eax
  000b9	5a		 pop	 edx
  000ba	83 c4 14	 add	 esp, 20			; 00000014H
  000bd	3b ec		 cmp	 ebp, esp
  000bf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
$LN15@IsFinished:
  000c8	01 00 00 00	 DD	 1
  000cc	00 00 00 00	 DD	 $LN14@IsFinished
$LN14@IsFinished:
  000d0	f0 ff ff ff	 DD	 -16			; fffffff0H
  000d4	08 00 00 00	 DD	 8
  000d8	00 00 00 00	 DD	 $LN13@IsFinished
$LN13@IsFinished:
  000dc	64		 DB	 100			; 00000064H
  000dd	6f		 DB	 111			; 0000006fH
  000de	74		 DB	 116			; 00000074H
  000df	00		 DB	 0
?IsFinished@DOTS_AND_BOXES@@QBE_NXZ ENDP		; DOTS_AND_BOXES::IsFinished
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
$T1 = -32						; size = 8
_capture$ = -24						; size = 4
_dot$ = -16						; size = 8
_this$ = -4						; size = 4
?CountCapturables@DOTS_AND_BOXES@@QBEHXZ PROC		; DOTS_AND_BOXES::CountCapturables
; _this$ = ecx

; 361  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0000e	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00011	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00014	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00017	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001a	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001d	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00020	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00023	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 362  :   VECTOR dot;

  00026	8d 4d f0	 lea	 ecx, DWORD PTR _dot$[ebp]
  00029	e8 00 00 00 00	 call	 ??0VECTOR@@QAE@XZ	; VECTOR::VECTOR

; 363  :   int capture;
; 364  :   capture = 0;

  0002e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _capture$[ebp], 0

; 365  :   for (dot.y=0; dot.y<m_height-1; dot.y++)

  00035	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dot$[ebp+4], 0
  0003c	eb 09		 jmp	 SHORT $LN4@CountCaptu
$LN2@CountCaptu:
  0003e	8b 45 f4	 mov	 eax, DWORD PTR _dot$[ebp+4]
  00041	83 c0 01	 add	 eax, 1
  00044	89 45 f4	 mov	 DWORD PTR _dot$[ebp+4], eax
$LN4@CountCaptu:
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0004d	83 ea 01	 sub	 edx, 1
  00050	39 55 f4	 cmp	 DWORD PTR _dot$[ebp+4], edx
  00053	7d 4e		 jge	 SHORT $LN3@CountCaptu

; 366  :   {
; 367  :     for (dot.x=0; dot.x<m_width-1; dot.x++)

  00055	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dot$[ebp], 0
  0005c	eb 09		 jmp	 SHORT $LN7@CountCaptu
$LN5@CountCaptu:
  0005e	8b 45 f0	 mov	 eax, DWORD PTR _dot$[ebp]
  00061	83 c0 01	 add	 eax, 1
  00064	89 45 f0	 mov	 DWORD PTR _dot$[ebp], eax
$LN7@CountCaptu:
  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0006d	83 ea 01	 sub	 edx, 1
  00070	39 55 f0	 cmp	 DWORD PTR _dot$[ebp], edx
  00073	7d 2c		 jge	 SHORT $LN6@CountCaptu

; 368  :     {
; 369  :       if (CountLines(dot) == 3)

  00075	8b 45 f0	 mov	 eax, DWORD PTR _dot$[ebp]
  00078	8b 4d f4	 mov	 ecx, DWORD PTR _dot$[ebp+4]
  0007b	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
  0007e	89 4d e4	 mov	 DWORD PTR $T1[ebp+4], ecx
  00081	8b 55 e4	 mov	 edx, DWORD PTR $T1[ebp+4]
  00084	52		 push	 edx
  00085	8b 45 e0	 mov	 eax, DWORD PTR $T1[ebp]
  00088	50		 push	 eax
  00089	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	e8 00 00 00 00	 call	 ?CountLines@DOTS_AND_BOXES@@QBEHUtagPOINT@@@Z ; DOTS_AND_BOXES::CountLines
  00091	83 f8 03	 cmp	 eax, 3
  00094	75 09		 jne	 SHORT $LN8@CountCaptu

; 370  :       {
; 371  :         capture++;

  00096	8b 4d e8	 mov	 ecx, DWORD PTR _capture$[ebp]
  00099	83 c1 01	 add	 ecx, 1
  0009c	89 4d e8	 mov	 DWORD PTR _capture$[ebp], ecx
$LN8@CountCaptu:

; 372  :       };
; 373  :     };

  0009f	eb bd		 jmp	 SHORT $LN5@CountCaptu
$LN6@CountCaptu:

; 374  :   };

  000a1	eb 9b		 jmp	 SHORT $LN2@CountCaptu
$LN3@CountCaptu:

; 375  :   return capture;

  000a3	8b 45 e8	 mov	 eax, DWORD PTR _capture$[ebp]

; 376  : }

  000a6	52		 push	 edx
  000a7	8b cd		 mov	 ecx, ebp
  000a9	50		 push	 eax
  000aa	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@CountCaptu
  000b0	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000b5	58		 pop	 eax
  000b6	5a		 pop	 edx
  000b7	83 c4 20	 add	 esp, 32			; 00000020H
  000ba	3b ec		 cmp	 ebp, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
  000c5	0f 1f 00	 npad	 3
$LN12@CountCaptu:
  000c8	01 00 00 00	 DD	 1
  000cc	00 00 00 00	 DD	 $LN11@CountCaptu
$LN11@CountCaptu:
  000d0	f0 ff ff ff	 DD	 -16			; fffffff0H
  000d4	08 00 00 00	 DD	 8
  000d8	00 00 00 00	 DD	 $LN10@CountCaptu
$LN10@CountCaptu:
  000dc	64		 DB	 100			; 00000064H
  000dd	6f		 DB	 111			; 0000006fH
  000de	74		 DB	 116			; 00000074H
  000df	00		 DB	 0
?CountCapturables@DOTS_AND_BOXES@@QBEHXZ ENDP		; DOTS_AND_BOXES::CountCapturables
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
$T1 = -32						; size = 8
_capture$ = -21						; size = 1
_dot$ = -16						; size = 8
_this$ = -4						; size = 4
?RemoveCapturables@DOTS_AND_BOXES@@QAEXXZ PROC		; DOTS_AND_BOXES::RemoveCapturables
; _this$ = ecx

; 335  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0000e	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00011	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00014	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00017	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001a	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001d	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00020	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00023	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 336  :   VECTOR dot;

  00026	8d 4d f0	 lea	 ecx, DWORD PTR _dot$[ebp]
  00029	e8 00 00 00 00	 call	 ??0VECTOR@@QAE@XZ	; VECTOR::VECTOR
$LN4@RemoveCapt:

; 337  :   bool capture;
; 338  :   do
; 339  :   {
; 340  :     capture = false;

  0002e	c6 45 eb 00	 mov	 BYTE PTR _capture$[ebp], 0

; 341  :     for (dot.y=0; dot.y<m_height-1; dot.y++)

  00032	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dot$[ebp+4], 0
  00039	eb 09		 jmp	 SHORT $LN7@RemoveCapt
$LN5@RemoveCapt:
  0003b	8b 45 f4	 mov	 eax, DWORD PTR _dot$[ebp+4]
  0003e	83 c0 01	 add	 eax, 1
  00041	89 45 f4	 mov	 DWORD PTR _dot$[ebp+4], eax
$LN7@RemoveCapt:
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0004a	83 ea 01	 sub	 edx, 1
  0004d	39 55 f4	 cmp	 DWORD PTR _dot$[ebp+4], edx
  00050	0f 8d af 00 00
	00		 jge	 $LN2@RemoveCapt

; 342  :     {
; 343  :       for (dot.x=0; dot.x<m_width-1; dot.x++)

  00056	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dot$[ebp], 0
  0005d	eb 09		 jmp	 SHORT $LN10@RemoveCapt
$LN8@RemoveCapt:
  0005f	8b 45 f0	 mov	 eax, DWORD PTR _dot$[ebp]
  00062	83 c0 01	 add	 eax, 1
  00065	89 45 f0	 mov	 DWORD PTR _dot$[ebp], eax
$LN10@RemoveCapt:
  00068	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0006e	83 ea 01	 sub	 edx, 1
  00071	39 55 f0	 cmp	 DWORD PTR _dot$[ebp], edx
  00074	0f 8d 86 00 00
	00		 jge	 $LN9@RemoveCapt

; 344  :       {
; 345  :         if (CountLines(dot) == 3)

  0007a	8b 45 f0	 mov	 eax, DWORD PTR _dot$[ebp]
  0007d	8b 4d f4	 mov	 ecx, DWORD PTR _dot$[ebp+4]
  00080	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
  00083	89 4d e4	 mov	 DWORD PTR $T1[ebp+4], ecx
  00086	8b 55 e4	 mov	 edx, DWORD PTR $T1[ebp+4]
  00089	52		 push	 edx
  0008a	8b 45 e0	 mov	 eax, DWORD PTR $T1[ebp]
  0008d	50		 push	 eax
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	e8 00 00 00 00	 call	 ?CountLines@DOTS_AND_BOXES@@QBEHUtagPOINT@@@Z ; DOTS_AND_BOXES::CountLines
  00096	83 f8 03	 cmp	 eax, 3
  00099	75 60		 jne	 SHORT $LN11@RemoveCapt

; 346  :         {
; 347  :           SetVLineType(dot.x, dot.y, LINE_COMPUTER);

  0009b	6a 01		 push	 1
  0009d	8b 4d f4	 mov	 ecx, DWORD PTR _dot$[ebp+4]
  000a0	51		 push	 ecx
  000a1	8b 55 f0	 mov	 edx, DWORD PTR _dot$[ebp]
  000a4	52		 push	 edx
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	e8 00 00 00 00	 call	 ?SetVLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetVLineType

; 348  :           SetHLineType(dot.x, dot.y, LINE_COMPUTER);

  000ad	6a 01		 push	 1
  000af	8b 45 f4	 mov	 eax, DWORD PTR _dot$[ebp+4]
  000b2	50		 push	 eax
  000b3	8b 4d f0	 mov	 ecx, DWORD PTR _dot$[ebp]
  000b6	51		 push	 ecx
  000b7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	e8 00 00 00 00	 call	 ?SetHLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetHLineType

; 349  :           SetHLineType(dot.x, dot.y+1, LINE_COMPUTER);

  000bf	6a 01		 push	 1
  000c1	8b 55 f4	 mov	 edx, DWORD PTR _dot$[ebp+4]
  000c4	83 c2 01	 add	 edx, 1
  000c7	52		 push	 edx
  000c8	8b 45 f0	 mov	 eax, DWORD PTR _dot$[ebp]
  000cb	50		 push	 eax
  000cc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cf	e8 00 00 00 00	 call	 ?SetHLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetHLineType

; 350  :           SetVLineType(dot.x+1, dot.y, LINE_COMPUTER);

  000d4	6a 01		 push	 1
  000d6	8b 4d f4	 mov	 ecx, DWORD PTR _dot$[ebp+4]
  000d9	51		 push	 ecx
  000da	8b 55 f0	 mov	 edx, DWORD PTR _dot$[ebp]
  000dd	83 c2 01	 add	 edx, 1
  000e0	52		 push	 edx
  000e1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e4	e8 00 00 00 00	 call	 ?SetVLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetVLineType

; 351  :           m_loopWeightsValid = false;

  000e9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ec	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 352  :           m_divideWeightsValid = false;

  000f0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f3	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0

; 353  :           capture = true;

  000f7	c6 45 eb 01	 mov	 BYTE PTR _capture$[ebp], 1
$LN11@RemoveCapt:

; 354  :         };
; 355  :       };

  000fb	e9 5f ff ff ff	 jmp	 $LN8@RemoveCapt
$LN9@RemoveCapt:

; 356  :     };

  00100	e9 36 ff ff ff	 jmp	 $LN5@RemoveCapt
$LN2@RemoveCapt:

; 357  :   } while (capture);

  00105	0f b6 55 eb	 movzx	 edx, BYTE PTR _capture$[ebp]
  00109	85 d2		 test	 edx, edx
  0010b	0f 85 1d ff ff
	ff		 jne	 $LN4@RemoveCapt

; 358  : }

  00111	52		 push	 edx
  00112	8b cd		 mov	 ecx, ebp
  00114	50		 push	 eax
  00115	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@RemoveCapt
  0011b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00120	58		 pop	 eax
  00121	5a		 pop	 edx
  00122	83 c4 20	 add	 esp, 32			; 00000020H
  00125	3b ec		 cmp	 ebp, esp
  00127	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c3		 ret	 0
$LN15@RemoveCapt:
  00130	01 00 00 00	 DD	 1
  00134	00 00 00 00	 DD	 $LN14@RemoveCapt
$LN14@RemoveCapt:
  00138	f0 ff ff ff	 DD	 -16			; fffffff0H
  0013c	08 00 00 00	 DD	 8
  00140	00 00 00 00	 DD	 $LN13@RemoveCapt
$LN13@RemoveCapt:
  00144	64		 DB	 100			; 00000064H
  00145	6f		 DB	 111			; 0000006fH
  00146	74		 DB	 116			; 00000074H
  00147	00		 DB	 0
?RemoveCapturables@DOTS_AND_BOXES@@QAEXXZ ENDP		; DOTS_AND_BOXES::RemoveCapturables
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
$T1 = -24						; size = 8
$T2 = -16						; size = 8
_result$ = -8						; size = 4
_this$ = -4						; size = 4
_dotNum$ = 8						; size = 8
?CountLines@DOTS_AND_BOXES@@QBEHUtagPOINT@@@Z PROC	; DOTS_AND_BOXES::CountLines
; _this$ = ecx

; 380  : { // Count the lines around the box at dotNum (below and right)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00011	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00014	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00017	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001a	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001d	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 381  :   int result = 0;

  00020	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0

; 382  :   if (dotNum.x >= Size().x - 1) return 0;

  00027	8d 45 f0	 lea	 eax, DWORD PTR $T2[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?Size@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ ; DOTS_AND_BOXES::Size
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	83 e9 01	 sub	 ecx, 1
  00038	39 4d 08	 cmp	 DWORD PTR _dotNum$[ebp], ecx
  0003b	7c 07		 jl	 SHORT $LN2@CountLines
  0003d	33 c0		 xor	 eax, eax
  0003f	e9 a0 00 00 00	 jmp	 $LN1@CountLines
$LN2@CountLines:

; 383  :   if (dotNum.y >= Size().y - 1) return 0;

  00044	8d 55 e8	 lea	 edx, DWORD PTR $T1[ebp]
  00047	52		 push	 edx
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?Size@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ ; DOTS_AND_BOXES::Size
  00050	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00053	83 e8 01	 sub	 eax, 1
  00056	39 45 0c	 cmp	 DWORD PTR _dotNum$[ebp+4], eax
  00059	7c 07		 jl	 SHORT $LN3@CountLines
  0005b	33 c0		 xor	 eax, eax
  0005d	e9 82 00 00 00	 jmp	 $LN1@CountLines
$LN3@CountLines:

; 384  :   if (HLineType(dotNum) != LINE_NONE) result++;

  00062	8d 4d 08	 lea	 ecx, DWORD PTR _dotNum$[ebp]
  00065	51		 push	 ecx
  00066	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::HLineType
  0006e	85 c0		 test	 eax, eax
  00070	74 09		 je	 SHORT $LN4@CountLines
  00072	8b 55 f8	 mov	 edx, DWORD PTR _result$[ebp]
  00075	83 c2 01	 add	 edx, 1
  00078	89 55 f8	 mov	 DWORD PTR _result$[ebp], edx
$LN4@CountLines:

; 385  :   if (VLineType(dotNum)   != LINE_NONE) result++;

  0007b	8d 45 08	 lea	 eax, DWORD PTR _dotNum$[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::VLineType
  00087	85 c0		 test	 eax, eax
  00089	74 09		 je	 SHORT $LN5@CountLines
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR _result$[ebp]
  0008e	83 c1 01	 add	 ecx, 1
  00091	89 4d f8	 mov	 DWORD PTR _result$[ebp], ecx
$LN5@CountLines:

; 386  :   dotNum.x++;

  00094	8b 55 08	 mov	 edx, DWORD PTR _dotNum$[ebp]
  00097	83 c2 01	 add	 edx, 1
  0009a	89 55 08	 mov	 DWORD PTR _dotNum$[ebp], edx

; 387  :   if (VLineType(dotNum)   != LINE_NONE) result++;

  0009d	8d 45 08	 lea	 eax, DWORD PTR _dotNum$[ebp]
  000a0	50		 push	 eax
  000a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::VLineType
  000a9	85 c0		 test	 eax, eax
  000ab	74 09		 je	 SHORT $LN6@CountLines
  000ad	8b 4d f8	 mov	 ecx, DWORD PTR _result$[ebp]
  000b0	83 c1 01	 add	 ecx, 1
  000b3	89 4d f8	 mov	 DWORD PTR _result$[ebp], ecx
$LN6@CountLines:

; 388  :   dotNum.x--;

  000b6	8b 55 08	 mov	 edx, DWORD PTR _dotNum$[ebp]
  000b9	83 ea 01	 sub	 edx, 1
  000bc	89 55 08	 mov	 DWORD PTR _dotNum$[ebp], edx

; 389  :   dotNum.y++;

  000bf	8b 45 0c	 mov	 eax, DWORD PTR _dotNum$[ebp+4]
  000c2	83 c0 01	 add	 eax, 1
  000c5	89 45 0c	 mov	 DWORD PTR _dotNum$[ebp+4], eax

; 390  :   if (HLineType(dotNum) != LINE_NONE) result++;

  000c8	8d 4d 08	 lea	 ecx, DWORD PTR _dotNum$[ebp]
  000cb	51		 push	 ecx
  000cc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cf	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::HLineType
  000d4	85 c0		 test	 eax, eax
  000d6	74 09		 je	 SHORT $LN7@CountLines
  000d8	8b 55 f8	 mov	 edx, DWORD PTR _result$[ebp]
  000db	83 c2 01	 add	 edx, 1
  000de	89 55 f8	 mov	 DWORD PTR _result$[ebp], edx
$LN7@CountLines:

; 391  :   return result;

  000e1	8b 45 f8	 mov	 eax, DWORD PTR _result$[ebp]
$LN1@CountLines:

; 392  : }

  000e4	83 c4 18	 add	 esp, 24			; 00000018H
  000e7	3b ec		 cmp	 ebp, esp
  000e9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c2 08 00	 ret	 8
?CountLines@DOTS_AND_BOXES@@QBEHUtagPOINT@@@Z ENDP	; DOTS_AND_BOXES::CountLines
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
_count$ = -24						; size = 4
_dot$ = -16						; size = 8
_this$ = -4						; size = 4
?NumberOfLines@DOTS_AND_BOXES@@QBEHXZ PROC		; DOTS_AND_BOXES::NumberOfLines
; _this$ = ecx

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00011	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00014	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00017	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001a	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001d	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 313  :   POINT dot;
; 314  :   int count = 0;

  00020	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 315  :   for (dot.y = 0; dot.y < m_height-1; dot.y++)

  00027	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dot$[ebp+4], 0
  0002e	eb 09		 jmp	 SHORT $LN4@NumberOfLi
$LN2@NumberOfLi:
  00030	8b 45 f4	 mov	 eax, DWORD PTR _dot$[ebp+4]
  00033	83 c0 01	 add	 eax, 1
  00036	89 45 f4	 mov	 DWORD PTR _dot$[ebp+4], eax
$LN4@NumberOfLi:
  00039	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0003f	83 ea 01	 sub	 edx, 1
  00042	39 55 f4	 cmp	 DWORD PTR _dot$[ebp+4], edx
  00045	7d 3a		 jge	 SHORT $LN3@NumberOfLi

; 316  :   {
; 317  :     for (dot.x=0; dot.x<m_width; dot.x++)

  00047	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dot$[ebp], 0
  0004e	eb 09		 jmp	 SHORT $LN7@NumberOfLi
$LN5@NumberOfLi:
  00050	8b 45 f0	 mov	 eax, DWORD PTR _dot$[ebp]
  00053	83 c0 01	 add	 eax, 1
  00056	89 45 f0	 mov	 DWORD PTR _dot$[ebp], eax
$LN7@NumberOfLi:
  00059	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	8b 55 f0	 mov	 edx, DWORD PTR _dot$[ebp]
  0005f	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00062	7d 1b		 jge	 SHORT $LN6@NumberOfLi

; 318  :     {
; 319  :       if (VLineType(dot) != LINE_NONE) count++;

  00064	8d 45 f0	 lea	 eax, DWORD PTR _dot$[ebp]
  00067	50		 push	 eax
  00068	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::VLineType
  00070	85 c0		 test	 eax, eax
  00072	74 09		 je	 SHORT $LN14@NumberOfLi
  00074	8b 4d e8	 mov	 ecx, DWORD PTR _count$[ebp]
  00077	83 c1 01	 add	 ecx, 1
  0007a	89 4d e8	 mov	 DWORD PTR _count$[ebp], ecx
$LN14@NumberOfLi:

; 320  :     };

  0007d	eb d1		 jmp	 SHORT $LN5@NumberOfLi
$LN6@NumberOfLi:

; 321  :   };

  0007f	eb af		 jmp	 SHORT $LN2@NumberOfLi
$LN3@NumberOfLi:

; 322  :   for (dot.x=0; dot.x<m_width-1; dot.x++)

  00081	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dot$[ebp], 0
  00088	eb 09		 jmp	 SHORT $LN10@NumberOfLi
$LN8@NumberOfLi:
  0008a	8b 55 f0	 mov	 edx, DWORD PTR _dot$[ebp]
  0008d	83 c2 01	 add	 edx, 1
  00090	89 55 f0	 mov	 DWORD PTR _dot$[ebp], edx
$LN10@NumberOfLi:
  00093	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00096	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00099	83 e9 01	 sub	 ecx, 1
  0009c	39 4d f0	 cmp	 DWORD PTR _dot$[ebp], ecx
  0009f	7d 3a		 jge	 SHORT $LN9@NumberOfLi

; 323  :   {
; 324  :     for (dot.y=0; dot.y<m_height; dot.y++)

  000a1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dot$[ebp+4], 0
  000a8	eb 09		 jmp	 SHORT $LN13@NumberOfLi
$LN11@NumberOfLi:
  000aa	8b 55 f4	 mov	 edx, DWORD PTR _dot$[ebp+4]
  000ad	83 c2 01	 add	 edx, 1
  000b0	89 55 f4	 mov	 DWORD PTR _dot$[ebp+4], edx
$LN13@NumberOfLi:
  000b3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	8b 4d f4	 mov	 ecx, DWORD PTR _dot$[ebp+4]
  000b9	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  000bc	7d 1b		 jge	 SHORT $LN12@NumberOfLi

; 325  :     {
; 326  :       if (HLineType(dot) != LINE_NONE) count++;

  000be	8d 55 f0	 lea	 edx, DWORD PTR _dot$[ebp]
  000c1	52		 push	 edx
  000c2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c5	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ; DOTS_AND_BOXES::HLineType
  000ca	85 c0		 test	 eax, eax
  000cc	74 09		 je	 SHORT $LN15@NumberOfLi
  000ce	8b 45 e8	 mov	 eax, DWORD PTR _count$[ebp]
  000d1	83 c0 01	 add	 eax, 1
  000d4	89 45 e8	 mov	 DWORD PTR _count$[ebp], eax
$LN15@NumberOfLi:

; 327  :     };

  000d7	eb d1		 jmp	 SHORT $LN11@NumberOfLi
$LN12@NumberOfLi:

; 328  :   };

  000d9	eb af		 jmp	 SHORT $LN8@NumberOfLi
$LN9@NumberOfLi:

; 329  :   return count;

  000db	8b 45 e8	 mov	 eax, DWORD PTR _count$[ebp]

; 330  : }

  000de	52		 push	 edx
  000df	8b cd		 mov	 ecx, ebp
  000e1	50		 push	 eax
  000e2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@NumberOfLi
  000e8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000ed	58		 pop	 eax
  000ee	5a		 pop	 edx
  000ef	83 c4 18	 add	 esp, 24			; 00000018H
  000f2	3b ec		 cmp	 ebp, esp
  000f4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
  000fd	0f 1f 00	 npad	 3
$LN19@NumberOfLi:
  00100	01 00 00 00	 DD	 1
  00104	00 00 00 00	 DD	 $LN18@NumberOfLi
$LN18@NumberOfLi:
  00108	f0 ff ff ff	 DD	 -16			; fffffff0H
  0010c	08 00 00 00	 DD	 8
  00110	00 00 00 00	 DD	 $LN17@NumberOfLi
$LN17@NumberOfLi:
  00114	64		 DB	 100			; 00000064H
  00115	6f		 DB	 111			; 0000006fH
  00116	74		 DB	 116			; 00000074H
  00117	00		 DB	 0
?NumberOfLines@DOTS_AND_BOXES@@QBEHXZ ENDP		; DOTS_AND_BOXES::NumberOfLines
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?AvoidFlag@DOTS_AND_BOXES@@QBEHHH_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_vertical$ = 16						; size = 1
?AvoidFlag@DOTS_AND_BOXES@@QBEHHH_N@Z PROC		; DOTS_AND_BOXES::AvoidFlag, COMDAT
; _this$ = ecx

; 120  :   {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 121  :     return m_avoidFlgs[Dot2Line(x, y, vertical)];

  0000e	0f b6 45 10	 movzx	 eax, BYTE PTR _vertical$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  0001a	52		 push	 edx
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?Dot2Line@DOTS_AND_BOXES@@QBEHHH_N@Z ; DOTS_AND_BOXES::Dot2Line
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00029	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]

; 122  :   };

  0002d	83 c4 04	 add	 esp, 4
  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 0c 00	 ret	 12			; 0000000cH
?AvoidFlag@DOTS_AND_BOXES@@QBEHHH_N@Z ENDP		; DOTS_AND_BOXES::AvoidFlag
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?Dot2Line@DOTS_AND_BOXES@@QBEHHH_N@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_vertical$ = 16						; size = 1
?Dot2Line@DOTS_AND_BOXES@@QBEHHH_N@Z PROC		; DOTS_AND_BOXES::Dot2Line, COMDAT
; _this$ = ecx

; 112  :          {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 113  :            return y * (2*m_width-1) + x + (vertical?(m_width-1):0);

  00009	0f b6 45 10	 movzx	 eax, BYTE PTR _vertical$[ebp]
  0000d	85 c0		 test	 eax, eax
  0000f	74 0e		 je	 SHORT $LN3@Dot2Line
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00017	83 ea 01	 sub	 edx, 1
  0001a	89 55 f8	 mov	 DWORD PTR tv73[ebp], edx
  0001d	eb 07		 jmp	 SHORT $LN4@Dot2Line
$LN3@Dot2Line:
  0001f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN4@Dot2Line:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0002c	8d 54 09 ff	 lea	 edx, DWORD PTR [ecx+ecx-1]
  00030	8b c2		 mov	 eax, edx
  00032	0f af 45 0c	 imul	 eax, DWORD PTR _y$[ebp]
  00036	03 45 08	 add	 eax, DWORD PTR _x$[ebp]
  00039	03 45 f8	 add	 eax, DWORD PTR tv73[ebp]

; 114  :          };

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 0c 00	 ret	 12			; 0000000cH
?Dot2Line@DOTS_AND_BOXES@@QBEHHH_N@Z ENDP		; DOTS_AND_BOXES::Dot2Line
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?SetBoxOwner@DOTS_AND_BOXES@@QAEXHHW4OWNER_TYPE@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_col$ = 8						; size = 4
_row$ = 12						; size = 4
_ot$ = 16						; size = 4
?SetBoxOwner@DOTS_AND_BOXES@@QAEXHHW4OWNER_TYPE@@@Z PROC ; DOTS_AND_BOXES::SetBoxOwner, COMDAT
; _this$ = ecx

; 108  :   INLINE void SetBoxOwner(int col, int row, OWNER_TYPE ot){m_owners[row*(m_width-1)+col]=(ui8)ot;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000d	83 e9 01	 sub	 ecx, 1
  00010	0f af 4d 0c	 imul	 ecx, DWORD PTR _row$[ebp]
  00014	03 4d 08	 add	 ecx, DWORD PTR _col$[ebp]
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0001d	8a 55 10	 mov	 dl, BYTE PTR _ot$[ebp]
  00020	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 0c 00	 ret	 12			; 0000000cH
?SetBoxOwner@DOTS_AND_BOXES@@QAEXHHW4OWNER_TYPE@@@Z ENDP ; DOTS_AND_BOXES::SetBoxOwner
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?BoxOwner@DOTS_AND_BOXES@@QBE?AW4OWNER_TYPE@@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_col$ = 8						; size = 4
_row$ = 12						; size = 4
?BoxOwner@DOTS_AND_BOXES@@QBE?AW4OWNER_TYPE@@HH@Z PROC	; DOTS_AND_BOXES::BoxOwner, COMDAT
; _this$ = ecx

; 106  :   INLINE OWNER_TYPE BoxOwner(int col, int row)const{return (OWNER_TYPE)m_owners[row*(m_width-1) + col];};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000d	83 e9 01	 sub	 ecx, 1
  00010	0f af 4d 0c	 imul	 ecx, DWORD PTR _row$[ebp]
  00014	03 4d 08	 add	 ecx, DWORD PTR _col$[ebp]
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0001d	0f b6 04 08	 movzx	 eax, BYTE PTR [eax+ecx]
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?BoxOwner@DOTS_AND_BOXES@@QBE?AW4OWNER_TYPE@@HH@Z ENDP	; DOTS_AND_BOXES::BoxOwner
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?SetHLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dotNum$ = 8						; size = 4
_lt$ = 12						; size = 4
?SetHLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z PROC ; DOTS_AND_BOXES::SetHLineType, COMDAT
; _this$ = ecx

; 104  :   INLINE void SetHLineType(const POINT& dotNum, LINE_TYPE lt){SetHLineType(dotNum.x, dotNum.y, lt);};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _lt$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _dotNum$[ebp]
  00015	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00018	52		 push	 edx
  00019	8b 45 08	 mov	 eax, DWORD PTR _dotNum$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	51		 push	 ecx
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?SetHLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetHLineType
  00027	83 c4 04	 add	 esp, 4
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
?SetHLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ENDP ; DOTS_AND_BOXES::SetHLineType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?SetHLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_col$ = 8						; size = 4
_row$ = 12						; size = 4
_lt$ = 16						; size = 4
?SetHLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z PROC ; DOTS_AND_BOXES::SetHLineType, COMDAT
; _this$ = ecx

; 103  :   INLINE void SetHLineType(int col, int row, LINE_TYPE lt){v();m_hlines[row*(m_width-1)+col]=(ui8)lt;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?v@DOTS_AND_BOXES@@AAEXXZ ; DOTS_AND_BOXES::v
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0001c	83 e9 01	 sub	 ecx, 1
  0001f	0f af 4d 0c	 imul	 ecx, DWORD PTR _row$[ebp]
  00023	03 4d 08	 add	 ecx, DWORD PTR _col$[ebp]
  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0002c	8a 55 10	 mov	 dl, BYTE PTR _lt$[ebp]
  0002f	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  00032	83 c4 04	 add	 esp, 4
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 0c 00	 ret	 12			; 0000000cH
?SetHLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z ENDP ; DOTS_AND_BOXES::SetHLineType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dotNum$ = 8						; size = 4
?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z PROC ; DOTS_AND_BOXES::HLineType, COMDAT
; _this$ = ecx

; 102  :   INLINE LINE_TYPE HLineType(const POINT& dotNum)const{return HLineType(dotNum.x, dotNum.y);};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _dotNum$[ebp]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	51		 push	 ecx
  00015	8b 55 08	 mov	 edx, DWORD PTR _dotNum$[ebp]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  00023	83 c4 04	 add	 esp, 4
  00026	3b ec		 cmp	 ebp, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ENDP ; DOTS_AND_BOXES::HLineType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_col$ = 8						; size = 4
_row$ = 12						; size = 4
?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z PROC	; DOTS_AND_BOXES::HLineType, COMDAT
; _this$ = ecx

; 101  :   INLINE LINE_TYPE HLineType(int col, int row)const{return (LINE_TYPE)m_hlines[row*(m_width-1) + col];};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000d	83 e9 01	 sub	 ecx, 1
  00010	0f af 4d 0c	 imul	 ecx, DWORD PTR _row$[ebp]
  00014	03 4d 08	 add	 ecx, DWORD PTR _col$[ebp]
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001d	0f b6 04 08	 movzx	 eax, BYTE PTR [eax+ecx]
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ENDP	; DOTS_AND_BOXES::HLineType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?SetVLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dotNum$ = 8						; size = 4
_lt$ = 12						; size = 4
?SetVLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z PROC ; DOTS_AND_BOXES::SetVLineType, COMDAT
; _this$ = ecx

; 100  :   INLINE void SetVLineType(const POINT& dotNum, LINE_TYPE lt){SetVLineType(dotNum.x, dotNum.y, lt);};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _lt$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _dotNum$[ebp]
  00015	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00018	52		 push	 edx
  00019	8b 45 08	 mov	 eax, DWORD PTR _dotNum$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	51		 push	 ecx
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?SetVLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetVLineType
  00027	83 c4 04	 add	 esp, 4
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
?SetVLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ENDP ; DOTS_AND_BOXES::SetVLineType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?SetVLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_col$ = 8						; size = 4
_row$ = 12						; size = 4
_lt$ = 16						; size = 4
?SetVLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z PROC ; DOTS_AND_BOXES::SetVLineType, COMDAT
; _this$ = ecx

; 99   :   INLINE void SetVLineType(int col, int row, LINE_TYPE lt){v();m_vlines[row*m_width+col]=(ui8)lt;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?v@DOTS_AND_BOXES@@AAEXXZ ; DOTS_AND_BOXES::v
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _row$[ebp]
  0001c	0f af 48 10	 imul	 ecx, DWORD PTR [eax+16]
  00020	03 4d 08	 add	 ecx, DWORD PTR _col$[ebp]
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00029	8a 55 10	 mov	 dl, BYTE PTR _lt$[ebp]
  0002c	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 0c 00	 ret	 12			; 0000000cH
?SetVLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z ENDP ; DOTS_AND_BOXES::SetVLineType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dotNum$ = 8						; size = 4
?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z PROC ; DOTS_AND_BOXES::VLineType, COMDAT
; _this$ = ecx

; 98   :   INLINE LINE_TYPE VLineType(const POINT& dotNum)const{return VLineType(dotNum.x, dotNum.y);};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _dotNum$[ebp]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	51		 push	 ecx
  00015	8b 55 08	 mov	 edx, DWORD PTR _dotNum$[ebp]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  00023	83 c4 04	 add	 esp, 4
  00026	3b ec		 cmp	 ebp, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@ABUtagPOINT@@@Z ENDP ; DOTS_AND_BOXES::VLineType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_col$ = 8						; size = 4
_row$ = 12						; size = 4
?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z PROC	; DOTS_AND_BOXES::VLineType, COMDAT
; _this$ = ecx

; 97   :   INLINE LINE_TYPE VLineType(int col, int row)const{return (LINE_TYPE)m_vlines[row*m_width + col];};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _row$[ebp]
  0000d	0f af 48 10	 imul	 ecx, DWORD PTR [eax+16]
  00011	03 4d 08	 add	 ecx, DWORD PTR _col$[ebp]
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0001a	0f b6 04 08	 movzx	 eax, BYTE PTR [eax+ecx]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ENDP	; DOTS_AND_BOXES::VLineType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?Size@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ
_TEXT	SEGMENT
_p$ = -16						; size = 8
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Size@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ PROC		; DOTS_AND_BOXES::Size, COMDAT
; _this$ = ecx

; 95   :   INLINE POINT Size(void) const {POINT p; p.x=m_width; p.y=m_height; return p;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00023	89 4d f0	 mov	 DWORD PTR _p$[ebp], ecx
  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0002c	89 45 f4	 mov	 DWORD PTR _p$[ebp+4], eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00032	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  00035	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp+4]
  00038	89 11		 mov	 DWORD PTR [ecx], edx
  0003a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0003d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00040	52		 push	 edx
  00041	8b cd		 mov	 ecx, ebp
  00043	50		 push	 eax
  00044	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Size
  0004a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0004f	58		 pop	 eax
  00050	5a		 pop	 edx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
  00057	90		 npad	 1
$LN5@Size:
  00058	01 00 00 00	 DD	 1
  0005c	00 00 00 00	 DD	 $LN4@Size
$LN4@Size:
  00060	f0 ff ff ff	 DD	 -16			; fffffff0H
  00064	08 00 00 00	 DD	 8
  00068	00 00 00 00	 DD	 $LN3@Size
$LN3@Size:
  0006c	70		 DB	 112			; 00000070H
  0006d	00		 DB	 0
?Size@DOTS_AND_BOXES@@QBE?AUtagPOINT@@XZ ENDP		; DOTS_AND_BOXES::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?Height@DOTS_AND_BOXES@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Height@DOTS_AND_BOXES@@QBEHXZ PROC			; DOTS_AND_BOXES::Height, COMDAT
; _this$ = ecx

; 93   :   INLINE int Height(void) const {return m_height;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Height@DOTS_AND_BOXES@@QBEHXZ ENDP			; DOTS_AND_BOXES::Height
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?Width@DOTS_AND_BOXES@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Width@DOTS_AND_BOXES@@QBEHXZ PROC			; DOTS_AND_BOXES::Width, COMDAT
; _this$ = ecx

; 92   :   INLINE int Width(void) const {return m_width;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?Width@DOTS_AND_BOXES@@QBEHXZ ENDP			; DOTS_AND_BOXES::Width
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
tv197 = -44						; size = 8
tv175 = -36						; size = 8
tv152 = -28						; size = 8
_dot$ = -16						; size = 8
_this$ = -4						; size = 4
_p$ = 8							; size = 8
??4DOTS_AND_BOXES@@QAEAAV0@_K@Z PROC			; DOTS_AND_BOXES::operator=
; _this$ = ecx

; 283  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	57		 push	 edi
  00007	51		 push	 ecx
  00008	8d 7d d4	 lea	 edi, DWORD PTR [ebp-44]
  0000b	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	59		 pop	 ecx
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 284  :   POINT dot;
; 285  :   Clear();

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?Clear@DOTS_AND_BOXES@@AAEXXZ ; DOTS_AND_BOXES::Clear

; 286  :   Setup(m_width, m_height);

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00029	51		 push	 ecx
  0002a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00030	50		 push	 eax
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ?Setup@DOTS_AND_BOXES@@AAEXHH@Z ; DOTS_AND_BOXES::Setup

; 287  :   for (dot.y = 0; dot.y < m_height-1; dot.y++)

  00039	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dot$[ebp+4], 0
  00040	eb 09		 jmp	 SHORT $LN4@operator
$LN2@operator:
  00042	8b 4d f4	 mov	 ecx, DWORD PTR _dot$[ebp+4]
  00045	83 c1 01	 add	 ecx, 1
  00048	89 4d f4	 mov	 DWORD PTR _dot$[ebp+4], ecx
$LN4@operator:
  0004b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004e	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00051	83 e8 01	 sub	 eax, 1
  00054	39 45 f4	 cmp	 DWORD PTR _dot$[ebp+4], eax
  00057	0f 8d bc 00 00
	00		 jge	 $LN3@operator

; 288  :   {
; 289  :     for (dot.x=0; dot.x<m_width-1; dot.x++)

  0005d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dot$[ebp], 0
  00064	eb 09		 jmp	 SHORT $LN7@operator
$LN5@operator:
  00066	8b 4d f0	 mov	 ecx, DWORD PTR _dot$[ebp]
  00069	83 c1 01	 add	 ecx, 1
  0006c	89 4d f0	 mov	 DWORD PTR _dot$[ebp], ecx
$LN7@operator:
  0006f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00072	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00075	83 e8 01	 sub	 eax, 1
  00078	39 45 f0	 cmp	 DWORD PTR _dot$[ebp], eax
  0007b	7d 3d		 jge	 SHORT $LN6@operator

; 290  :     {
; 291  :       if (p & 1) SetHLineType(dot,LINE_COMPUTER);

  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00080	83 e1 01	 and	 ecx, 1
  00083	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp+4]
  00086	83 e2 00	 and	 edx, 0
  00089	89 4d e4	 mov	 DWORD PTR tv152[ebp], ecx
  0008c	89 55 e8	 mov	 DWORD PTR tv152[ebp+4], edx
  0008f	8b 45 e4	 mov	 eax, DWORD PTR tv152[ebp]
  00092	0b 45 e8	 or	 eax, DWORD PTR tv152[ebp+4]
  00095	74 0e		 je	 SHORT $LN14@operator
  00097	6a 01		 push	 1
  00099	8d 4d f0	 lea	 ecx, DWORD PTR _dot$[ebp]
  0009c	51		 push	 ecx
  0009d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	e8 00 00 00 00	 call	 ?SetHLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetHLineType
$LN14@operator:

; 292  :       p >>= 1;

  000a5	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000a8	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp+4]
  000ab	b1 01		 mov	 cl, 1
  000ad	e8 00 00 00 00	 call	 __aullshr
  000b2	89 45 08	 mov	 DWORD PTR _p$[ebp], eax
  000b5	89 55 0c	 mov	 DWORD PTR _p$[ebp+4], edx

; 293  :     };

  000b8	eb ac		 jmp	 SHORT $LN5@operator
$LN6@operator:

; 294  :     for (dot.x=0; dot.x<m_width; dot.x++)

  000ba	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dot$[ebp], 0
  000c1	eb 09		 jmp	 SHORT $LN10@operator
$LN8@operator:
  000c3	8b 55 f0	 mov	 edx, DWORD PTR _dot$[ebp]
  000c6	83 c2 01	 add	 edx, 1
  000c9	89 55 f0	 mov	 DWORD PTR _dot$[ebp], edx
$LN10@operator:
  000cc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000cf	8b 4d f0	 mov	 ecx, DWORD PTR _dot$[ebp]
  000d2	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  000d5	7d 3d		 jge	 SHORT $LN9@operator

; 295  :     {
; 296  :       if (p & 1) SetVLineType(dot,LINE_COMPUTER);

  000d7	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  000da	83 e2 01	 and	 edx, 1
  000dd	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp+4]
  000e0	83 e0 00	 and	 eax, 0
  000e3	89 55 dc	 mov	 DWORD PTR tv175[ebp], edx
  000e6	89 45 e0	 mov	 DWORD PTR tv175[ebp+4], eax
  000e9	8b 4d dc	 mov	 ecx, DWORD PTR tv175[ebp]
  000ec	0b 4d e0	 or	 ecx, DWORD PTR tv175[ebp+4]
  000ef	74 0e		 je	 SHORT $LN15@operator
  000f1	6a 01		 push	 1
  000f3	8d 55 f0	 lea	 edx, DWORD PTR _dot$[ebp]
  000f6	52		 push	 edx
  000f7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fa	e8 00 00 00 00	 call	 ?SetVLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetVLineType
$LN15@operator:

; 297  :       p >>= 1;

  000ff	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00102	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp+4]
  00105	b1 01		 mov	 cl, 1
  00107	e8 00 00 00 00	 call	 __aullshr
  0010c	89 45 08	 mov	 DWORD PTR _p$[ebp], eax
  0010f	89 55 0c	 mov	 DWORD PTR _p$[ebp+4], edx

; 298  :     };

  00112	eb af		 jmp	 SHORT $LN8@operator
$LN9@operator:

; 299  :   };

  00114	e9 29 ff ff ff	 jmp	 $LN2@operator
$LN3@operator:

; 300  :   for (dot.x=0; dot.x<m_width-1; dot.x++)

  00119	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dot$[ebp], 0
  00120	eb 09		 jmp	 SHORT $LN13@operator
$LN11@operator:
  00122	8b 45 f0	 mov	 eax, DWORD PTR _dot$[ebp]
  00125	83 c0 01	 add	 eax, 1
  00128	89 45 f0	 mov	 DWORD PTR _dot$[ebp], eax
$LN13@operator:
  0012b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00131	83 ea 01	 sub	 edx, 1
  00134	39 55 f0	 cmp	 DWORD PTR _dot$[ebp], edx
  00137	7d 3d		 jge	 SHORT $LN12@operator

; 301  :   {
; 302  :     if (p & 1) SetHLineType(dot,LINE_COMPUTER);

  00139	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0013c	83 e0 01	 and	 eax, 1
  0013f	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp+4]
  00142	83 e1 00	 and	 ecx, 0
  00145	89 45 d4	 mov	 DWORD PTR tv197[ebp], eax
  00148	89 4d d8	 mov	 DWORD PTR tv197[ebp+4], ecx
  0014b	8b 55 d4	 mov	 edx, DWORD PTR tv197[ebp]
  0014e	0b 55 d8	 or	 edx, DWORD PTR tv197[ebp+4]
  00151	74 0e		 je	 SHORT $LN16@operator
  00153	6a 01		 push	 1
  00155	8d 45 f0	 lea	 eax, DWORD PTR _dot$[ebp]
  00158	50		 push	 eax
  00159	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015c	e8 00 00 00 00	 call	 ?SetHLineType@DOTS_AND_BOXES@@QAEXABUtagPOINT@@W4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetHLineType
$LN16@operator:

; 303  :     p >>= 1;

  00161	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00164	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp+4]
  00167	b1 01		 mov	 cl, 1
  00169	e8 00 00 00 00	 call	 __aullshr
  0016e	89 45 08	 mov	 DWORD PTR _p$[ebp], eax
  00171	89 55 0c	 mov	 DWORD PTR _p$[ebp+4], edx

; 304  :   };

  00174	eb ac		 jmp	 SHORT $LN11@operator
$LN12@operator:

; 305  :   m_loopWeightsValid = false;

  00176	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00179	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 306  :   m_divideWeightsValid = false;

  0017d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00180	c6 42 04 00	 mov	 BYTE PTR [edx+4], 0

; 307  :   return *this;

  00184	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 308  : }

  00187	52		 push	 edx
  00188	8b cd		 mov	 ecx, ebp
  0018a	50		 push	 eax
  0018b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN20@operator
  00191	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00196	58		 pop	 eax
  00197	5a		 pop	 edx
  00198	5f		 pop	 edi
  00199	83 c4 2c	 add	 esp, 44			; 0000002cH
  0019c	3b ec		 cmp	 ebp, esp
  0019e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a3	8b e5		 mov	 esp, ebp
  001a5	5d		 pop	 ebp
  001a6	c2 08 00	 ret	 8
  001a9	0f 1f 00	 npad	 3
$LN20@operator:
  001ac	01 00 00 00	 DD	 1
  001b0	00 00 00 00	 DD	 $LN19@operator
$LN19@operator:
  001b4	f0 ff ff ff	 DD	 -16			; fffffff0H
  001b8	08 00 00 00	 DD	 8
  001bc	00 00 00 00	 DD	 $LN18@operator
$LN18@operator:
  001c0	64		 DB	 100			; 00000064H
  001c1	6f		 DB	 111			; 0000006fH
  001c2	74		 DB	 116			; 00000074H
  001c3	00		 DB	 0
??4DOTS_AND_BOXES@@QAEAAV0@_K@Z ENDP			; DOTS_AND_BOXES::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_game$ = 8						; size = 4
??4DOTS_AND_BOXES@@QAEAAV0@ABV0@@Z PROC			; DOTS_AND_BOXES::operator=
; _this$ = ecx

; 271  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 272  :   Clear();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?Clear@DOTS_AND_BOXES@@AAEXXZ ; DOTS_AND_BOXES::Clear

; 273  :   Setup(game.m_width, game.m_height);

  00016	8b 45 08	 mov	 eax, DWORD PTR _game$[ebp]
  00019	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0001c	51		 push	 ecx
  0001d	8b 55 08	 mov	 edx, DWORD PTR _game$[ebp]
  00020	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00023	50		 push	 eax
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?Setup@DOTS_AND_BOXES@@AAEXHH@Z ; DOTS_AND_BOXES::Setup

; 274  :   memcpy(m_vlines,game.m_vlines,m_width*(m_height-1));

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00032	83 ea 01	 sub	 edx, 1
  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	0f af 50 10	 imul	 edx, DWORD PTR [eax+16]
  0003c	52		 push	 edx
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _game$[ebp]
  00040	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00043	52		 push	 edx
  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 _memcpy
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH

; 275  :   memcpy(m_hlines,game.m_hlines,(m_width-1)*m_height);

  00053	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00056	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00059	83 e8 01	 sub	 eax, 1
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	0f af 41 14	 imul	 eax, DWORD PTR [ecx+20]
  00063	50		 push	 eax
  00064	8b 55 08	 mov	 edx, DWORD PTR _game$[ebp]
  00067	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0006a	50		 push	 eax
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00071	52		 push	 edx
  00072	e8 00 00 00 00	 call	 _memcpy
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH

; 276  :   memcpy(m_owners,game.m_owners,(m_width-1)*(m_height-1));

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00080	83 e9 01	 sub	 ecx, 1
  00083	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00086	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00089	83 e8 01	 sub	 eax, 1
  0008c	0f af c8	 imul	 ecx, eax
  0008f	51		 push	 ecx
  00090	8b 4d 08	 mov	 ecx, DWORD PTR _game$[ebp]
  00093	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00096	52		 push	 edx
  00097	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 _memcpy
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 277  :   m_loopWeightsValid = false;

  000a6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a9	c6 42 0c 00	 mov	 BYTE PTR [edx+12], 0

; 278  :   m_divideWeightsValid = false;

  000ad	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b0	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 279  :   return *this;

  000b4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 280  : }

  000b7	83 c4 04	 add	 esp, 4
  000ba	3b ec		 cmp	 ebp, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 04 00	 ret	 4
??4DOTS_AND_BOXES@@QAEAAV0@ABV0@@Z ENDP			; DOTS_AND_BOXES::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
_newGame$ = -72						; size = 48
_result$ = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_arIn$ = 8						; size = 4
??6DOTS_AND_BOXES@@QAEXAAVarInput@@@Z PROC		; DOTS_AND_BOXES::operator<<
; _this$ = ecx

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??6DOTS_AND_BOXES@@QAEXAAVarInput@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	57		 push	 edi
  00015	51		 push	 ecx
  00016	8d 7d b4	 lea	 edi, DWORD PTR [ebp-76]
  00019	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	59		 pop	 ecx
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	50		 push	 eax
  0002e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00037	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 264  :   bool result;
; 265  :   DOTS_AND_BOXES newGame(MAX_WIDTH, MAX_HEIGHT);

  0003a	6a 0b		 push	 11			; 0000000bH
  0003c	6a 0c		 push	 12			; 0000000cH
  0003e	8d 4d b8	 lea	 ecx, DWORD PTR _newGame$[ebp]
  00041	e8 00 00 00 00	 call	 ??0DOTS_AND_BOXES@@QAE@HH@Z ; DOTS_AND_BOXES::DOTS_AND_BOXES
  00046	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 266  :   result = newGame.ReadFromArchive(arIn);

  0004d	8b 45 08	 mov	 eax, DWORD PTR _arIn$[ebp]
  00050	50		 push	 eax
  00051	8d 4d b8	 lea	 ecx, DWORD PTR _newGame$[ebp]
  00054	e8 00 00 00 00	 call	 ?ReadFromArchive@DOTS_AND_BOXES@@AAE_NAAVarInput@@@Z ; DOTS_AND_BOXES::ReadFromArchive
  00059	88 45 ef	 mov	 BYTE PTR _result$[ebp], al

; 267  :   if (result) *this = newGame;

  0005c	0f b6 4d ef	 movzx	 ecx, BYTE PTR _result$[ebp]
  00060	85 c9		 test	 ecx, ecx
  00062	74 0c		 je	 SHORT $LN2@operator
  00064	8d 55 b8	 lea	 edx, DWORD PTR _newGame$[ebp]
  00067	52		 push	 edx
  00068	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ??4DOTS_AND_BOXES@@QAEAAV0@ABV0@@Z ; DOTS_AND_BOXES::operator=
$LN2@operator:

; 268  : }

  00070	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00077	8d 4d b8	 lea	 ecx, DWORD PTR _newGame$[ebp]
  0007a	e8 00 00 00 00	 call	 ??1DOTS_AND_BOXES@@QAE@XZ ; DOTS_AND_BOXES::~DOTS_AND_BOXES
  0007f	52		 push	 edx
  00080	8b cd		 mov	 ecx, ebp
  00082	50		 push	 eax
  00083	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@operator
  00089	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0008e	58		 pop	 eax
  0008f	5a		 pop	 edx
  00090	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00093	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009a	59		 pop	 ecx
  0009b	5f		 pop	 edi
  0009c	83 c4 4c	 add	 esp, 76			; 0000004cH
  0009f	3b ec		 cmp	 ebp, esp
  000a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 04 00	 ret	 4
$LN8@operator:
  000ac	01 00 00 00	 DD	 1
  000b0	00 00 00 00	 DD	 $LN7@operator
$LN7@operator:
  000b4	b8 ff ff ff	 DD	 -72			; ffffffb8H
  000b8	30 00 00 00	 DD	 48			; 00000030H
  000bc	00 00 00 00	 DD	 $LN5@operator
$LN5@operator:
  000c0	6e		 DB	 110			; 0000006eH
  000c1	65		 DB	 101			; 00000065H
  000c2	77		 DB	 119			; 00000077H
  000c3	47		 DB	 71			; 00000047H
  000c4	61		 DB	 97			; 00000061H
  000c5	6d		 DB	 109			; 0000006dH
  000c6	65		 DB	 101			; 00000065H
  000c7	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??6DOTS_AND_BOXES@@QAEXAAVarInput@@@Z$0:
  00000	8d 4d b8	 lea	 ecx, DWORD PTR _newGame$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1DOTS_AND_BOXES@@QAE@XZ ; DOTS_AND_BOXES::~DOTS_AND_BOXES
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??6DOTS_AND_BOXES@@QAEXAAVarInput@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??6DOTS_AND_BOXES@@QAEXAAVarInput@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??6DOTS_AND_BOXES@@QAEXAAVarInput@@@Z ENDP		; DOTS_AND_BOXES::operator<<
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
tv183 = -28						; size = 4
tv171 = -24						; size = 4
tv151 = -20						; size = 4
_c$ = -13						; size = 1
_col$ = -12						; size = 4
_row$ = -8						; size = 4
_this$ = -4						; size = 4
_ar$ = 8						; size = 4
??5DOTS_AND_BOXES@@QBEXAAVCArchive@@@Z PROC		; DOTS_AND_BOXES::operator>>
; _this$ = ecx

; 100  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 101  :   int row, col;
; 102  :   char c;
; 103  :   Write(ar,"#Comments are welcome anywhere\n");

  00023	68 00 00 00 00	 push	 OFFSET $SG225035
  00028	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@PBD@Z ; Write
  00031	83 c4 08	 add	 esp, 8

; 104  :   Write(ar,"#Human vertical = "); Write(ar, VERTICAL_HUMAN_CHAR); Write(ar,"\n");

  00034	68 00 00 00 00	 push	 OFFSET $SG225036
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@PBD@Z ; Write
  00042	83 c4 08	 add	 esp, 8
  00045	6a 49		 push	 73			; 00000049H
  00047	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  0004a	52		 push	 edx
  0004b	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@D@Z ; Write
  00050	83 c4 08	 add	 esp, 8
  00053	68 00 00 00 00	 push	 OFFSET $SG225037
  00058	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@PBD@Z ; Write
  00061	83 c4 08	 add	 esp, 8

; 105  :   Write(ar,"#Computer vertical = "); Write(ar, VERTICAL_COMPUTER_CHAR); Write(ar,"\n");

  00064	68 00 00 00 00	 push	 OFFSET $SG225038
  00069	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0006c	51		 push	 ecx
  0006d	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@PBD@Z ; Write
  00072	83 c4 08	 add	 esp, 8
  00075	6a 7c		 push	 124			; 0000007cH
  00077	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  0007a	52		 push	 edx
  0007b	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@D@Z ; Write
  00080	83 c4 08	 add	 esp, 8
  00083	68 00 00 00 00	 push	 OFFSET $SG225039
  00088	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@PBD@Z ; Write
  00091	83 c4 08	 add	 esp, 8

; 106  :   Write(ar,"#Human horizontal = "); Write(ar, HORIZONTAL_HUMAN_CHAR); Write(ar, "\n");

  00094	68 00 00 00 00	 push	 OFFSET $SG225040
  00099	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0009c	51		 push	 ecx
  0009d	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@PBD@Z ; Write
  000a2	83 c4 08	 add	 esp, 8
  000a5	6a 2d		 push	 45			; 0000002dH
  000a7	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@D@Z ; Write
  000b0	83 c4 08	 add	 esp, 8
  000b3	68 00 00 00 00	 push	 OFFSET $SG225041
  000b8	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@PBD@Z ; Write
  000c1	83 c4 08	 add	 esp, 8

; 107  :   Write(ar,"#Computer horizontal = "); Write(ar, HORIZONTAL_COMPUTER_CHAR); Write(ar, "\n");

  000c4	68 00 00 00 00	 push	 OFFSET $SG225042
  000c9	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  000cc	51		 push	 ecx
  000cd	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@PBD@Z ; Write
  000d2	83 c4 08	 add	 esp, 8
  000d5	6a 3d		 push	 61			; 0000003dH
  000d7	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  000da	52		 push	 edx
  000db	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@D@Z ; Write
  000e0	83 c4 08	 add	 esp, 8
  000e3	68 00 00 00 00	 push	 OFFSET $SG225043
  000e8	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@PBD@Z ; Write
  000f1	83 c4 08	 add	 esp, 8

; 108  :   Write(ar,"#Human box ownership = "); Write(ar, OWNER_HUMAN_CHAR); Write(ar,"\n");

  000f4	68 00 00 00 00	 push	 OFFSET $SG225044
  000f9	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  000fc	51		 push	 ecx
  000fd	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@PBD@Z ; Write
  00102	83 c4 08	 add	 esp, 8
  00105	6a 48		 push	 72			; 00000048H
  00107	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  0010a	52		 push	 edx
  0010b	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@D@Z ; Write
  00110	83 c4 08	 add	 esp, 8
  00113	68 00 00 00 00	 push	 OFFSET $SG225045
  00118	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@PBD@Z ; Write
  00121	83 c4 08	 add	 esp, 8

; 109  :   Write(ar,"#Computer box ownership = "); Write(ar, OWNER_COMPUTER_CHAR); Write(ar,"\n");

  00124	68 00 00 00 00	 push	 OFFSET $SG225046
  00129	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0012c	51		 push	 ecx
  0012d	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@PBD@Z ; Write
  00132	83 c4 08	 add	 esp, 8
  00135	6a 43		 push	 67			; 00000043H
  00137	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  0013a	52		 push	 edx
  0013b	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@D@Z ; Write
  00140	83 c4 08	 add	 esp, 8
  00143	68 00 00 00 00	 push	 OFFSET $SG225047
  00148	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  0014b	50		 push	 eax
  0014c	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@PBD@Z ; Write
  00151	83 c4 08	 add	 esp, 8

; 110  :   Write(ar,"#\n");

  00154	68 00 00 00 00	 push	 OFFSET $SG225048
  00159	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0015c	51		 push	 ecx
  0015d	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@PBD@Z ; Write
  00162	83 c4 08	 add	 esp, 8

; 111  :   for (row=0; row<m_height; row++)

  00165	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _row$[ebp], 0
  0016c	eb 09		 jmp	 SHORT $LN4@operator
$LN2@operator:
  0016e	8b 55 f8	 mov	 edx, DWORD PTR _row$[ebp]
  00171	83 c2 01	 add	 edx, 1
  00174	89 55 f8	 mov	 DWORD PTR _row$[ebp], edx
$LN4@operator:
  00177	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0017a	8b 4d f8	 mov	 ecx, DWORD PTR _row$[ebp]
  0017d	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00180	0f 8d 85 01 00
	00		 jge	 $LN3@operator

; 112  :   {
; 113  :     for (col=0; col<m_width; col++) // The Horizontal bars

  00186	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _col$[ebp], 0
  0018d	eb 09		 jmp	 SHORT $LN7@operator
$LN5@operator:
  0018f	8b 55 f4	 mov	 edx, DWORD PTR _col$[ebp]
  00192	83 c2 01	 add	 edx, 1
  00195	89 55 f4	 mov	 DWORD PTR _col$[ebp], edx
$LN7@operator:
  00198	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0019b	8b 4d f4	 mov	 ecx, DWORD PTR _col$[ebp]
  0019e	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  001a1	7d 60		 jge	 SHORT $LN6@operator

; 114  :     {
; 115  :       Write(ar, DOT_CHAR);

  001a3	6a 2b		 push	 43			; 0000002bH
  001a5	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  001a8	52		 push	 edx
  001a9	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@D@Z ; Write
  001ae	83 c4 08	 add	 esp, 8

; 116  :       if (col < m_width-1)

  001b1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001b4	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  001b7	83 e9 01	 sub	 ecx, 1
  001ba	39 4d f4	 cmp	 DWORD PTR _col$[ebp], ecx
  001bd	7d 42		 jge	 SHORT $LN17@operator

; 117  :       {
; 118  :         switch (HLineType(col, row))

  001bf	8b 55 f8	 mov	 edx, DWORD PTR _row$[ebp]
  001c2	52		 push	 edx
  001c3	8b 45 f4	 mov	 eax, DWORD PTR _col$[ebp]
  001c6	50		 push	 eax
  001c7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ca	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  001cf	89 45 ec	 mov	 DWORD PTR tv151[ebp], eax
  001d2	83 7d ec 01	 cmp	 DWORD PTR tv151[ebp], 1
  001d6	74 0e		 je	 SHORT $LN19@operator
  001d8	83 7d ec 02	 cmp	 DWORD PTR tv151[ebp], 2
  001dc	74 02		 je	 SHORT $LN18@operator
  001de	eb 0c		 jmp	 SHORT $LN20@operator
$LN18@operator:

; 119  :         {
; 120  :         case LINE_HUMAN: c = HORIZONTAL_HUMAN_CHAR; break;

  001e0	c6 45 f3 2d	 mov	 BYTE PTR _c$[ebp], 45	; 0000002dH
  001e4	eb 0a		 jmp	 SHORT $LN8@operator
$LN19@operator:

; 121  :         case LINE_COMPUTER: c = HORIZONTAL_COMPUTER_CHAR; break;

  001e6	c6 45 f3 3d	 mov	 BYTE PTR _c$[ebp], 61	; 0000003dH
  001ea	eb 04		 jmp	 SHORT $LN8@operator
$LN20@operator:

; 122  :         default: c = ' ';

  001ec	c6 45 f3 20	 mov	 BYTE PTR _c$[ebp], 32	; 00000020H
$LN8@operator:

; 123  :         };
; 124  :         Write(ar, c);

  001f0	0f b6 4d f3	 movzx	 ecx, BYTE PTR _c$[ebp]
  001f4	51		 push	 ecx
  001f5	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  001f8	52		 push	 edx
  001f9	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@D@Z ; Write
  001fe	83 c4 08	 add	 esp, 8
$LN17@operator:

; 125  :       };
; 126  :     };

  00201	eb 8c		 jmp	 SHORT $LN5@operator
$LN6@operator:

; 127  :     if (row == 0) Write(ar,"#The first row determines width");

  00203	83 7d f8 00	 cmp	 DWORD PTR _row$[ebp], 0
  00207	75 11		 jne	 SHORT $LN21@operator
  00209	68 00 00 00 00	 push	 OFFSET $SG225054
  0020e	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  00211	50		 push	 eax
  00212	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@PBD@Z ; Write
  00217	83 c4 08	 add	 esp, 8
$LN21@operator:

; 128  :     Write(ar, "\n");

  0021a	68 00 00 00 00	 push	 OFFSET $SG225055
  0021f	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00222	51		 push	 ecx
  00223	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@PBD@Z ; Write
  00228	83 c4 08	 add	 esp, 8

; 129  :     if (row < m_height-1)

  0022b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0022e	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00231	83 e8 01	 sub	 eax, 1
  00234	39 45 f8	 cmp	 DWORD PTR _row$[ebp], eax
  00237	0f 8d c9 00 00
	00		 jge	 $LN22@operator

; 130  :     {
; 131  :       // Now draw the vertical bars
; 132  :       for (col=0; col<m_width; col++)

  0023d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _col$[ebp], 0
  00244	eb 09		 jmp	 SHORT $LN12@operator
$LN10@operator:
  00246	8b 4d f4	 mov	 ecx, DWORD PTR _col$[ebp]
  00249	83 c1 01	 add	 ecx, 1
  0024c	89 4d f4	 mov	 DWORD PTR _col$[ebp], ecx
$LN12@operator:
  0024f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00252	8b 45 f4	 mov	 eax, DWORD PTR _col$[ebp]
  00255	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  00258	0f 8d 97 00 00
	00		 jge	 $LN11@operator

; 133  :       {
; 134  :         switch (VLineType(col, row))

  0025e	8b 4d f8	 mov	 ecx, DWORD PTR _row$[ebp]
  00261	51		 push	 ecx
  00262	8b 55 f4	 mov	 edx, DWORD PTR _col$[ebp]
  00265	52		 push	 edx
  00266	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00269	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  0026e	89 45 e8	 mov	 DWORD PTR tv171[ebp], eax
  00271	83 7d e8 01	 cmp	 DWORD PTR tv171[ebp], 1
  00275	74 0e		 je	 SHORT $LN24@operator
  00277	83 7d e8 02	 cmp	 DWORD PTR tv171[ebp], 2
  0027b	74 02		 je	 SHORT $LN23@operator
  0027d	eb 0c		 jmp	 SHORT $LN25@operator
$LN23@operator:

; 135  :         {
; 136  :         case LINE_HUMAN: c = VERTICAL_HUMAN_CHAR; break;

  0027f	c6 45 f3 49	 mov	 BYTE PTR _c$[ebp], 73	; 00000049H
  00283	eb 0a		 jmp	 SHORT $LN13@operator
$LN24@operator:

; 137  :         case LINE_COMPUTER: c = VERTICAL_COMPUTER_CHAR; break;

  00285	c6 45 f3 7c	 mov	 BYTE PTR _c$[ebp], 124	; 0000007cH
  00289	eb 04		 jmp	 SHORT $LN13@operator
$LN25@operator:

; 138  :         default: c = ' ';

  0028b	c6 45 f3 20	 mov	 BYTE PTR _c$[ebp], 32	; 00000020H
$LN13@operator:

; 139  :         };
; 140  :         Write(ar, c);

  0028f	0f b6 45 f3	 movzx	 eax, BYTE PTR _c$[ebp]
  00293	50		 push	 eax
  00294	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00297	51		 push	 ecx
  00298	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@D@Z ; Write
  0029d	83 c4 08	 add	 esp, 8

; 141  :         if (col < m_width-1)

  002a0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002a3	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  002a6	83 e8 01	 sub	 eax, 1
  002a9	39 45 f4	 cmp	 DWORD PTR _col$[ebp], eax
  002ac	7d 42		 jge	 SHORT $LN26@operator

; 142  :         {
; 143  :           switch(BoxOwner(col, row))

  002ae	8b 4d f8	 mov	 ecx, DWORD PTR _row$[ebp]
  002b1	51		 push	 ecx
  002b2	8b 55 f4	 mov	 edx, DWORD PTR _col$[ebp]
  002b5	52		 push	 edx
  002b6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002b9	e8 00 00 00 00	 call	 ?BoxOwner@DOTS_AND_BOXES@@QBE?AW4OWNER_TYPE@@HH@Z ; DOTS_AND_BOXES::BoxOwner
  002be	89 45 e4	 mov	 DWORD PTR tv183[ebp], eax
  002c1	83 7d e4 01	 cmp	 DWORD PTR tv183[ebp], 1
  002c5	74 08		 je	 SHORT $LN27@operator
  002c7	83 7d e4 02	 cmp	 DWORD PTR tv183[ebp], 2
  002cb	74 08		 je	 SHORT $LN28@operator
  002cd	eb 0c		 jmp	 SHORT $LN29@operator
$LN27@operator:

; 144  :           {
; 145  :           case OWNER_HUMAN: c = OWNER_HUMAN_CHAR; break;

  002cf	c6 45 f3 48	 mov	 BYTE PTR _c$[ebp], 72	; 00000048H
  002d3	eb 0a		 jmp	 SHORT $LN15@operator
$LN28@operator:

; 146  :           case OWNER_COMPUTER: c = OWNER_COMPUTER_CHAR; break;

  002d5	c6 45 f3 43	 mov	 BYTE PTR _c$[ebp], 67	; 00000043H
  002d9	eb 04		 jmp	 SHORT $LN15@operator
$LN29@operator:

; 147  :           default: c = ' ';

  002db	c6 45 f3 20	 mov	 BYTE PTR _c$[ebp], 32	; 00000020H
$LN15@operator:

; 148  :           };
; 149  :           Write(ar, c);

  002df	0f b6 45 f3	 movzx	 eax, BYTE PTR _c$[ebp]
  002e3	50		 push	 eax
  002e4	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  002e7	51		 push	 ecx
  002e8	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@D@Z ; Write
  002ed	83 c4 08	 add	 esp, 8
$LN26@operator:

; 150  :         };
; 151  :       };

  002f0	e9 51 ff ff ff	 jmp	 $LN10@operator
$LN11@operator:

; 152  :       Write(ar,"\n");

  002f5	68 00 00 00 00	 push	 OFFSET $SG225064
  002fa	8b 55 08	 mov	 edx, DWORD PTR _ar$[ebp]
  002fd	52		 push	 edx
  002fe	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@PBD@Z ; Write
  00303	83 c4 08	 add	 esp, 8
$LN22@operator:

; 153  :     };
; 154  :   };

  00306	e9 63 fe ff ff	 jmp	 $LN2@operator
$LN3@operator:

; 155  :   Write(ar,"Anything illegal in column one determines height.\n");

  0030b	68 00 00 00 00	 push	 OFFSET $SG225065
  00310	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  00313	50		 push	 eax
  00314	e8 00 00 00 00	 call	 ?Write@@YAXAAVCArchive@@PBD@Z ; Write
  00319	83 c4 08	 add	 esp, 8

; 156  : }

  0031c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0031f	3b ec		 cmp	 ebp, esp
  00321	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00326	8b e5		 mov	 esp, ebp
  00328	5d		 pop	 ebp
  00329	c2 04 00	 ret	 4
??5DOTS_AND_BOXES@@QBEXAAVCArchive@@@Z ENDP		; DOTS_AND_BOXES::operator>>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1DOTS_AND_BOXES@@QAE@XZ PROC				; DOTS_AND_BOXES::~DOTS_AND_BOXES
; _this$ = ecx

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1DOTS_AND_BOXES@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 75   :   Clear();

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?Clear@DOTS_AND_BOXES@@AAEXXZ ; DOTS_AND_BOXES::Clear

; 76   : }

  00035	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00038	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003f	59		 pop	 ecx
  00040	83 c4 10	 add	 esp, 16			; 00000010H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
  0004e	cc		 int	 3
  0004f	cc		 int	 3
  00050	cc		 int	 3
  00051	cc		 int	 3
  00052	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$??1DOTS_AND_BOXES@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1DOTS_AND_BOXES@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1DOTS_AND_BOXES@@QAE@XZ ENDP				; DOTS_AND_BOXES::~DOTS_AND_BOXES
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
??0DOTS_AND_BOXES@@QAE@HH@Z PROC			; DOTS_AND_BOXES::DOTS_AND_BOXES
; _this$ = ecx

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 70   :   Setup(width, height);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _height$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _width$[ebp]
  00015	51		 push	 ecx
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?Setup@DOTS_AND_BOXES@@AAEXHH@Z ; DOTS_AND_BOXES::Setup

; 71   : }

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	83 c4 04	 add	 esp, 4
  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
??0DOTS_AND_BOXES@@QAE@HH@Z ENDP			; DOTS_AND_BOXES::DOTS_AND_BOXES
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.h
;	COMDAT ?v@DOTS_AND_BOXES@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?v@DOTS_AND_BOXES@@AAEXXZ PROC				; DOTS_AND_BOXES::v, COMDAT
; _this$ = ecx

; 80   :   INLINE void v(void){m_loopWeightsValid=false;m_divideWeightsValid=false;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?v@DOTS_AND_BOXES@@AAEXXZ ENDP				; DOTS_AND_BOXES::v
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
_boxNum$ = -32						; size = 4
_height$ = -28						; size = 4
_width$ = -24						; size = 4
_dotNum$ = -16						; size = 8
_this$ = -4						; size = 4
_xition$ = 8						; size = 4
?BuildXitionTable@DOTS_AND_BOXES@@AAEXQAY131H@Z PROC	; DOTS_AND_BOXES::BuildXitionTable
; _this$ = ecx

; 679  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0000e	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00011	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00014	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00017	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001a	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001d	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00020	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00023	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 680  :   POINT dotNum;
; 681  :   int width, height, boxNum;
; 682  :   width = Width();

  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?Width@DOTS_AND_BOXES@@QBEHXZ ; DOTS_AND_BOXES::Width
  0002e	89 45 e8	 mov	 DWORD PTR _width$[ebp], eax

; 683  :   height = Height();

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ?Height@DOTS_AND_BOXES@@QBEHXZ ; DOTS_AND_BOXES::Height
  00039	89 45 e4	 mov	 DWORD PTR _height$[ebp], eax

; 684  :   for (boxNum=0, dotNum.y=0; dotNum.y<height-1; dotNum.y++)

  0003c	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _boxNum$[ebp], 0
  00043	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dotNum$[ebp+4], 0
  0004a	eb 09		 jmp	 SHORT $LN4@BuildXitio
$LN2@BuildXitio:
  0004c	8b 45 f4	 mov	 eax, DWORD PTR _dotNum$[ebp+4]
  0004f	83 c0 01	 add	 eax, 1
  00052	89 45 f4	 mov	 DWORD PTR _dotNum$[ebp+4], eax
$LN4@BuildXitio:
  00055	8b 4d e4	 mov	 ecx, DWORD PTR _height$[ebp]
  00058	83 e9 01	 sub	 ecx, 1
  0005b	39 4d f4	 cmp	 DWORD PTR _dotNum$[ebp+4], ecx
  0005e	0f 8d 91 02 00
	00		 jge	 $LN1@BuildXitio

; 685  :   {
; 686  :     for (dotNum.x=0; dotNum.x<width-1; dotNum.x++, boxNum++)

  00064	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dotNum$[ebp], 0
  0006b	eb 12		 jmp	 SHORT $LN7@BuildXitio
$LN5@BuildXitio:
  0006d	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp]
  00070	83 c2 01	 add	 edx, 1
  00073	89 55 f0	 mov	 DWORD PTR _dotNum$[ebp], edx
  00076	8b 45 e0	 mov	 eax, DWORD PTR _boxNum$[ebp]
  00079	83 c0 01	 add	 eax, 1
  0007c	89 45 e0	 mov	 DWORD PTR _boxNum$[ebp], eax
$LN7@BuildXitio:
  0007f	8b 4d e8	 mov	 ecx, DWORD PTR _width$[ebp]
  00082	83 e9 01	 sub	 ecx, 1
  00085	39 4d f0	 cmp	 DWORD PTR _dotNum$[ebp], ecx
  00088	0f 8d 62 02 00
	00		 jge	 $LN6@BuildXitio

; 687  :     {
; 688  :       //Up
; 689  :       if ((dotNum.y > 0) && (HLineType(dotNum.x, dotNum.y) == LINE_NONE))

  0008e	83 7d f4 00	 cmp	 DWORD PTR _dotNum$[ebp+4], 0
  00092	7e 6b		 jle	 SHORT $LN8@BuildXitio
  00094	8b 55 f4	 mov	 edx, DWORD PTR _dotNum$[ebp+4]
  00097	52		 push	 edx
  00098	8b 45 f0	 mov	 eax, DWORD PTR _dotNum$[ebp]
  0009b	50		 push	 eax
  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  000a4	85 c0		 test	 eax, eax
  000a6	75 57		 jne	 SHORT $LN8@BuildXitio

; 690  :       {
; 691  :         xition[boxNum][0][0] = boxNum-(width-1);

  000a8	8b 4d e8	 mov	 ecx, DWORD PTR _width$[ebp]
  000ab	83 e9 01	 sub	 ecx, 1
  000ae	8b 55 e0	 mov	 edx, DWORD PTR _boxNum$[ebp]
  000b1	2b d1		 sub	 edx, ecx
  000b3	8b 45 e0	 mov	 eax, DWORD PTR _boxNum$[ebp]
  000b6	c1 e0 05	 shl	 eax, 5
  000b9	03 45 08	 add	 eax, DWORD PTR _xition$[ebp]
  000bc	b9 08 00 00 00	 mov	 ecx, 8
  000c1	6b c9 00	 imul	 ecx, ecx, 0
  000c4	03 c1		 add	 eax, ecx
  000c6	b9 04 00 00 00	 mov	 ecx, 4
  000cb	6b c9 00	 imul	 ecx, ecx, 0
  000ce	89 14 08	 mov	 DWORD PTR [eax+ecx], edx

; 692  :         xition[boxNum][0][1] = dotNum.y*(2*width-1) + dotNum.x;

  000d1	8b 55 e8	 mov	 edx, DWORD PTR _width$[ebp]
  000d4	8d 44 12 ff	 lea	 eax, DWORD PTR [edx+edx-1]
  000d8	0f af 45 f4	 imul	 eax, DWORD PTR _dotNum$[ebp+4]
  000dc	03 45 f0	 add	 eax, DWORD PTR _dotNum$[ebp]
  000df	8b 4d e0	 mov	 ecx, DWORD PTR _boxNum$[ebp]
  000e2	c1 e1 05	 shl	 ecx, 5
  000e5	03 4d 08	 add	 ecx, DWORD PTR _xition$[ebp]
  000e8	ba 08 00 00 00	 mov	 edx, 8
  000ed	6b d2 00	 imul	 edx, edx, 0
  000f0	03 ca		 add	 ecx, edx
  000f2	ba 04 00 00 00	 mov	 edx, 4
  000f7	c1 e2 00	 shl	 edx, 0
  000fa	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 693  :       }

  000fd	eb 22		 jmp	 SHORT $LN9@BuildXitio
$LN8@BuildXitio:

; 694  :       else
; 695  :       {
; 696  :         xition[boxNum][0][0] = -1;

  000ff	8b 45 e0	 mov	 eax, DWORD PTR _boxNum$[ebp]
  00102	c1 e0 05	 shl	 eax, 5
  00105	03 45 08	 add	 eax, DWORD PTR _xition$[ebp]
  00108	b9 08 00 00 00	 mov	 ecx, 8
  0010d	6b d1 00	 imul	 edx, ecx, 0
  00110	03 c2		 add	 eax, edx
  00112	b9 04 00 00 00	 mov	 ecx, 4
  00117	6b d1 00	 imul	 edx, ecx, 0
  0011a	c7 04 10 ff ff
	ff ff		 mov	 DWORD PTR [eax+edx], -1
$LN9@BuildXitio:

; 697  :       };
; 698  :       //Right
; 699  :       if ((dotNum.x < width-2) && (VLineType(dotNum.x+1, dotNum.y) == LINE_NONE))

  00121	8b 45 e8	 mov	 eax, DWORD PTR _width$[ebp]
  00124	83 e8 02	 sub	 eax, 2
  00127	39 45 f0	 cmp	 DWORD PTR _dotNum$[ebp], eax
  0012a	7d 6c		 jge	 SHORT $LN10@BuildXitio
  0012c	8b 4d f4	 mov	 ecx, DWORD PTR _dotNum$[ebp+4]
  0012f	51		 push	 ecx
  00130	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp]
  00133	83 c2 01	 add	 edx, 1
  00136	52		 push	 edx
  00137	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013a	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  0013f	85 c0		 test	 eax, eax
  00141	75 55		 jne	 SHORT $LN10@BuildXitio

; 700  :       {
; 701  :         xition[boxNum][1][0] = boxNum + 1;

  00143	8b 45 e0	 mov	 eax, DWORD PTR _boxNum$[ebp]
  00146	83 c0 01	 add	 eax, 1
  00149	8b 4d e0	 mov	 ecx, DWORD PTR _boxNum$[ebp]
  0014c	c1 e1 05	 shl	 ecx, 5
  0014f	03 4d 08	 add	 ecx, DWORD PTR _xition$[ebp]
  00152	ba 08 00 00 00	 mov	 edx, 8
  00157	c1 e2 00	 shl	 edx, 0
  0015a	03 ca		 add	 ecx, edx
  0015c	ba 04 00 00 00	 mov	 edx, 4
  00161	6b d2 00	 imul	 edx, edx, 0
  00164	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 702  :         xition[boxNum][1][1] = dotNum.y*(2*width-1) + width - 1+ dotNum.x + 1;

  00167	8b 45 e8	 mov	 eax, DWORD PTR _width$[ebp]
  0016a	8d 4c 00 ff	 lea	 ecx, DWORD PTR [eax+eax-1]
  0016e	0f af 4d f4	 imul	 ecx, DWORD PTR _dotNum$[ebp+4]
  00172	03 4d e8	 add	 ecx, DWORD PTR _width$[ebp]
  00175	03 4d f0	 add	 ecx, DWORD PTR _dotNum$[ebp]
  00178	8b 55 e0	 mov	 edx, DWORD PTR _boxNum$[ebp]
  0017b	c1 e2 05	 shl	 edx, 5
  0017e	03 55 08	 add	 edx, DWORD PTR _xition$[ebp]
  00181	b8 08 00 00 00	 mov	 eax, 8
  00186	c1 e0 00	 shl	 eax, 0
  00189	03 d0		 add	 edx, eax
  0018b	b8 04 00 00 00	 mov	 eax, 4
  00190	c1 e0 00	 shl	 eax, 0
  00193	89 0c 02	 mov	 DWORD PTR [edx+eax], ecx

; 703  :       }

  00196	eb 22		 jmp	 SHORT $LN11@BuildXitio
$LN10@BuildXitio:

; 704  :       else
; 705  :       {
; 706  :         xition[boxNum][1][0] = -1;

  00198	8b 4d e0	 mov	 ecx, DWORD PTR _boxNum$[ebp]
  0019b	c1 e1 05	 shl	 ecx, 5
  0019e	03 4d 08	 add	 ecx, DWORD PTR _xition$[ebp]
  001a1	ba 08 00 00 00	 mov	 edx, 8
  001a6	c1 e2 00	 shl	 edx, 0
  001a9	03 ca		 add	 ecx, edx
  001ab	b8 04 00 00 00	 mov	 eax, 4
  001b0	6b d0 00	 imul	 edx, eax, 0
  001b3	c7 04 11 ff ff
	ff ff		 mov	 DWORD PTR [ecx+edx], -1
$LN11@BuildXitio:

; 707  :       };
; 708  :       //Down
; 709  :       if ((dotNum.y < height-2) && (HLineType(dotNum.x, dotNum.y+1) == LINE_NONE))

  001ba	8b 45 e4	 mov	 eax, DWORD PTR _height$[ebp]
  001bd	83 e8 02	 sub	 eax, 2
  001c0	39 45 f4	 cmp	 DWORD PTR _dotNum$[ebp+4], eax
  001c3	7d 70		 jge	 SHORT $LN12@BuildXitio
  001c5	8b 4d f4	 mov	 ecx, DWORD PTR _dotNum$[ebp+4]
  001c8	83 c1 01	 add	 ecx, 1
  001cb	51		 push	 ecx
  001cc	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp]
  001cf	52		 push	 edx
  001d0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001d3	e8 00 00 00 00	 call	 ?HLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::HLineType
  001d8	85 c0		 test	 eax, eax
  001da	75 59		 jne	 SHORT $LN12@BuildXitio

; 710  :       {
; 711  :         xition[boxNum][2][0] = boxNum + (width-1);

  001dc	8b 45 e8	 mov	 eax, DWORD PTR _width$[ebp]
  001df	8b 4d e0	 mov	 ecx, DWORD PTR _boxNum$[ebp]
  001e2	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  001e6	8b 45 e0	 mov	 eax, DWORD PTR _boxNum$[ebp]
  001e9	c1 e0 05	 shl	 eax, 5
  001ec	03 45 08	 add	 eax, DWORD PTR _xition$[ebp]
  001ef	b9 08 00 00 00	 mov	 ecx, 8
  001f4	d1 e1		 shl	 ecx, 1
  001f6	03 c1		 add	 eax, ecx
  001f8	b9 04 00 00 00	 mov	 ecx, 4
  001fd	6b c9 00	 imul	 ecx, ecx, 0
  00200	89 14 08	 mov	 DWORD PTR [eax+ecx], edx

; 712  :         xition[boxNum][2][1] = (dotNum.y+1)*(2*width-1) + dotNum.x;

  00203	8b 55 f4	 mov	 edx, DWORD PTR _dotNum$[ebp+4]
  00206	83 c2 01	 add	 edx, 1
  00209	8b 45 e8	 mov	 eax, DWORD PTR _width$[ebp]
  0020c	8d 4c 00 ff	 lea	 ecx, DWORD PTR [eax+eax-1]
  00210	0f af d1	 imul	 edx, ecx
  00213	03 55 f0	 add	 edx, DWORD PTR _dotNum$[ebp]
  00216	8b 45 e0	 mov	 eax, DWORD PTR _boxNum$[ebp]
  00219	c1 e0 05	 shl	 eax, 5
  0021c	03 45 08	 add	 eax, DWORD PTR _xition$[ebp]
  0021f	b9 08 00 00 00	 mov	 ecx, 8
  00224	d1 e1		 shl	 ecx, 1
  00226	03 c1		 add	 eax, ecx
  00228	b9 04 00 00 00	 mov	 ecx, 4
  0022d	c1 e1 00	 shl	 ecx, 0
  00230	89 14 08	 mov	 DWORD PTR [eax+ecx], edx

; 713  :       }

  00233	eb 21		 jmp	 SHORT $LN13@BuildXitio
$LN12@BuildXitio:

; 714  :       else
; 715  :       {
; 716  :         xition[boxNum][2][0] = -1;

  00235	8b 55 e0	 mov	 edx, DWORD PTR _boxNum$[ebp]
  00238	c1 e2 05	 shl	 edx, 5
  0023b	03 55 08	 add	 edx, DWORD PTR _xition$[ebp]
  0023e	b8 08 00 00 00	 mov	 eax, 8
  00243	d1 e0		 shl	 eax, 1
  00245	03 d0		 add	 edx, eax
  00247	b9 04 00 00 00	 mov	 ecx, 4
  0024c	6b c1 00	 imul	 eax, ecx, 0
  0024f	c7 04 02 ff ff
	ff ff		 mov	 DWORD PTR [edx+eax], -1
$LN13@BuildXitio:

; 717  :       };
; 718  :       //Left
; 719  :       if ((dotNum.x > 0) && (VLineType(dotNum.x, dotNum.y) == LINE_NONE))

  00256	83 7d f0 00	 cmp	 DWORD PTR _dotNum$[ebp], 0
  0025a	7e 6d		 jle	 SHORT $LN14@BuildXitio
  0025c	8b 4d f4	 mov	 ecx, DWORD PTR _dotNum$[ebp+4]
  0025f	51		 push	 ecx
  00260	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp]
  00263	52		 push	 edx
  00264	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00267	e8 00 00 00 00	 call	 ?VLineType@DOTS_AND_BOXES@@QBE?AW4LINE_TYPE@@HH@Z ; DOTS_AND_BOXES::VLineType
  0026c	85 c0		 test	 eax, eax
  0026e	75 59		 jne	 SHORT $LN14@BuildXitio

; 720  :       {
; 721  :         xition[boxNum][3][0] = boxNum-1;

  00270	8b 45 e0	 mov	 eax, DWORD PTR _boxNum$[ebp]
  00273	83 e8 01	 sub	 eax, 1
  00276	8b 4d e0	 mov	 ecx, DWORD PTR _boxNum$[ebp]
  00279	c1 e1 05	 shl	 ecx, 5
  0027c	03 4d 08	 add	 ecx, DWORD PTR _xition$[ebp]
  0027f	ba 08 00 00 00	 mov	 edx, 8
  00284	6b d2 03	 imul	 edx, edx, 3
  00287	03 ca		 add	 ecx, edx
  00289	ba 04 00 00 00	 mov	 edx, 4
  0028e	6b d2 00	 imul	 edx, edx, 0
  00291	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 722  :         xition[boxNum][3][1] = dotNum.y*(2*width-1) + width - 1 + dotNum.x;

  00294	8b 45 e8	 mov	 eax, DWORD PTR _width$[ebp]
  00297	8d 4c 00 ff	 lea	 ecx, DWORD PTR [eax+eax-1]
  0029b	0f af 4d f4	 imul	 ecx, DWORD PTR _dotNum$[ebp+4]
  0029f	03 4d e8	 add	 ecx, DWORD PTR _width$[ebp]
  002a2	8b 55 f0	 mov	 edx, DWORD PTR _dotNum$[ebp]
  002a5	8d 44 11 ff	 lea	 eax, DWORD PTR [ecx+edx-1]
  002a9	8b 4d e0	 mov	 ecx, DWORD PTR _boxNum$[ebp]
  002ac	c1 e1 05	 shl	 ecx, 5
  002af	03 4d 08	 add	 ecx, DWORD PTR _xition$[ebp]
  002b2	ba 08 00 00 00	 mov	 edx, 8
  002b7	6b d2 03	 imul	 edx, edx, 3
  002ba	03 ca		 add	 ecx, edx
  002bc	ba 04 00 00 00	 mov	 edx, 4
  002c1	c1 e2 00	 shl	 edx, 0
  002c4	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 723  :       }

  002c7	eb 22		 jmp	 SHORT $LN15@BuildXitio
$LN14@BuildXitio:

; 724  :       else
; 725  :       {
; 726  :         xition[boxNum][3][0] = -1;

  002c9	8b 45 e0	 mov	 eax, DWORD PTR _boxNum$[ebp]
  002cc	c1 e0 05	 shl	 eax, 5
  002cf	03 45 08	 add	 eax, DWORD PTR _xition$[ebp]
  002d2	b9 08 00 00 00	 mov	 ecx, 8
  002d7	6b d1 03	 imul	 edx, ecx, 3
  002da	03 c2		 add	 eax, edx
  002dc	b9 04 00 00 00	 mov	 ecx, 4
  002e1	6b d1 00	 imul	 edx, ecx, 0
  002e4	c7 04 10 ff ff
	ff ff		 mov	 DWORD PTR [eax+edx], -1
$LN15@BuildXitio:

; 727  :       };
; 728  :     };

  002eb	e9 7d fd ff ff	 jmp	 $LN5@BuildXitio
$LN6@BuildXitio:

; 729  :   };

  002f0	e9 57 fd ff ff	 jmp	 $LN2@BuildXitio
$LN1@BuildXitio:

; 730  : }

  002f5	52		 push	 edx
  002f6	8b cd		 mov	 ecx, ebp
  002f8	50		 push	 eax
  002f9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@BuildXitio
  002ff	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00304	58		 pop	 eax
  00305	5a		 pop	 edx
  00306	83 c4 20	 add	 esp, 32			; 00000020H
  00309	3b ec		 cmp	 ebp, esp
  0030b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00310	8b e5		 mov	 esp, ebp
  00312	5d		 pop	 ebp
  00313	c2 04 00	 ret	 4
  00316	66 90		 npad	 2
$LN19@BuildXitio:
  00318	01 00 00 00	 DD	 1
  0031c	00 00 00 00	 DD	 $LN18@BuildXitio
$LN18@BuildXitio:
  00320	f0 ff ff ff	 DD	 -16			; fffffff0H
  00324	08 00 00 00	 DD	 8
  00328	00 00 00 00	 DD	 $LN17@BuildXitio
$LN17@BuildXitio:
  0032c	64		 DB	 100			; 00000064H
  0032d	6f		 DB	 111			; 0000006fH
  0032e	74		 DB	 116			; 00000074H
  0032f	4e		 DB	 78			; 0000004eH
  00330	75		 DB	 117			; 00000075H
  00331	6d		 DB	 109			; 0000006dH
  00332	00		 DB	 0
?BuildXitionTable@DOTS_AND_BOXES@@AAEXQAY131H@Z ENDP	; DOTS_AND_BOXES::BuildXitionTable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
$T8 = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
?Setup@DOTS_AND_BOXES@@AAEXHH@Z PROC			; DOTS_AND_BOXES::Setup
; _this$ = ecx

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	57		 push	 edi
  00007	51		 push	 ecx
  00008	8d 7d d8	 lea	 edi, DWORD PTR [ebp-40]
  0000b	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	59		 pop	 ecx
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 11   :   int i;
; 12   :   m_vlines = new ui8[(width) * (height-1)];

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _height$[ebp]
  0001e	83 e8 01	 sub	 eax, 1
  00021	0f af 45 08	 imul	 eax, DWORD PTR _width$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0002b	83 c4 04	 add	 esp, 4
  0002e	89 45 f4	 mov	 DWORD PTR $T8[ebp], eax
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 55 f4	 mov	 edx, DWORD PTR $T8[ebp]
  00037	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 13   :   for (i=0; i<(width)*(height-1); i++)

  0003a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00041	eb 09		 jmp	 SHORT $LN4@Setup
$LN2@Setup:
  00043	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00046	83 c0 01	 add	 eax, 1
  00049	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Setup:
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _height$[ebp]
  0004f	83 e9 01	 sub	 ecx, 1
  00052	0f af 4d 08	 imul	 ecx, DWORD PTR _width$[ebp]
  00056	39 4d f8	 cmp	 DWORD PTR _i$[ebp], ecx
  00059	7d 0f		 jge	 SHORT $LN3@Setup

; 14   :   {
; 15   :     m_vlines[i] = LINE_NONE;

  0005b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005e	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00064	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 16   :   };

  00068	eb d9		 jmp	 SHORT $LN2@Setup
$LN3@Setup:

; 17   :   m_hlines = new ui8[(width-1) * (height)];

  0006a	8b 55 08	 mov	 edx, DWORD PTR _width$[ebp]
  0006d	83 ea 01	 sub	 edx, 1
  00070	0f af 55 0c	 imul	 edx, DWORD PTR _height$[ebp]
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0007a	83 c4 04	 add	 esp, 4
  0007d	89 45 f0	 mov	 DWORD PTR $T7[ebp], eax
  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d f0	 mov	 ecx, DWORD PTR $T7[ebp]
  00086	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 18   :   for (i=0; i<(width-1)*(height); i++)

  00089	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00090	eb 09		 jmp	 SHORT $LN7@Setup
$LN5@Setup:
  00092	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00095	83 c2 01	 add	 edx, 1
  00098	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN7@Setup:
  0009b	8b 45 08	 mov	 eax, DWORD PTR _width$[ebp]
  0009e	83 e8 01	 sub	 eax, 1
  000a1	0f af 45 0c	 imul	 eax, DWORD PTR _height$[ebp]
  000a5	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  000a8	7d 0f		 jge	 SHORT $LN6@Setup

; 19   :   {
; 20   :     m_hlines[i] = LINE_NONE;

  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000b0	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000b3	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 21   :   };

  000b7	eb d9		 jmp	 SHORT $LN5@Setup
$LN6@Setup:

; 22   :   m_owners = new ui8[(width-1)*(height-1)];

  000b9	8b 4d 08	 mov	 ecx, DWORD PTR _width$[ebp]
  000bc	83 e9 01	 sub	 ecx, 1
  000bf	8b 55 0c	 mov	 edx, DWORD PTR _height$[ebp]
  000c2	83 ea 01	 sub	 edx, 1
  000c5	0f af ca	 imul	 ecx, edx
  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000ce	83 c4 04	 add	 esp, 4
  000d1	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
  000d4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d7	8b 4d ec	 mov	 ecx, DWORD PTR $T6[ebp]
  000da	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 23   :   for (i=0; i<(width-1)*(height-1); i++)

  000dd	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000e4	eb 09		 jmp	 SHORT $LN10@Setup
$LN8@Setup:
  000e6	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000e9	83 c2 01	 add	 edx, 1
  000ec	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN10@Setup:
  000ef	8b 45 08	 mov	 eax, DWORD PTR _width$[ebp]
  000f2	83 e8 01	 sub	 eax, 1
  000f5	8b 4d 0c	 mov	 ecx, DWORD PTR _height$[ebp]
  000f8	83 e9 01	 sub	 ecx, 1
  000fb	0f af c1	 imul	 eax, ecx
  000fe	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  00101	7d 0f		 jge	 SHORT $LN9@Setup

; 24   :   {
; 25   :     m_owners[i] = OWNER_NONE;

  00103	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00106	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00109	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0010c	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 26   :   };

  00110	eb d4		 jmp	 SHORT $LN8@Setup
$LN9@Setup:

; 27   :   m_dotLoopThreat = new ui8[width*height];

  00112	8b 55 08	 mov	 edx, DWORD PTR _width$[ebp]
  00115	0f af 55 0c	 imul	 edx, DWORD PTR _height$[ebp]
  00119	52		 push	 edx
  0011a	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0011f	83 c4 04	 add	 esp, 4
  00122	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
  00125	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00128	8b 4d e8	 mov	 ecx, DWORD PTR $T5[ebp]
  0012b	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 28   :   for (i=0; i<width*height; i++)

  0012e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00135	eb 09		 jmp	 SHORT $LN13@Setup
$LN11@Setup:
  00137	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0013a	83 c2 01	 add	 edx, 1
  0013d	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN13@Setup:
  00140	8b 45 08	 mov	 eax, DWORD PTR _width$[ebp]
  00143	0f af 45 0c	 imul	 eax, DWORD PTR _height$[ebp]
  00147	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  0014a	7d 0f		 jge	 SHORT $LN12@Setup

; 29   :   {
; 30   :     m_dotLoopThreat[i] = 0;

  0014c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0014f	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00152	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00155	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 31   :   };

  00159	eb dc		 jmp	 SHORT $LN11@Setup
$LN12@Setup:

; 32   :   m_lineLoopThreat = new ui8[(width-1)*height + (height-1)*width];

  0015b	8b 4d 08	 mov	 ecx, DWORD PTR _width$[ebp]
  0015e	83 e9 01	 sub	 ecx, 1
  00161	0f af 4d 0c	 imul	 ecx, DWORD PTR _height$[ebp]
  00165	8b 55 0c	 mov	 edx, DWORD PTR _height$[ebp]
  00168	83 ea 01	 sub	 edx, 1
  0016b	0f af 55 08	 imul	 edx, DWORD PTR _width$[ebp]
  0016f	03 ca		 add	 ecx, edx
  00171	51		 push	 ecx
  00172	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00177	83 c4 04	 add	 esp, 4
  0017a	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
  0017d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00180	8b 4d e4	 mov	 ecx, DWORD PTR $T4[ebp]
  00183	89 48 2c	 mov	 DWORD PTR [eax+44], ecx

; 33   :   for (i=0; i<(width-1)*height+(height-1)*width; i++)

  00186	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0018d	eb 09		 jmp	 SHORT $LN16@Setup
$LN14@Setup:
  0018f	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00192	83 c2 01	 add	 edx, 1
  00195	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN16@Setup:
  00198	8b 45 08	 mov	 eax, DWORD PTR _width$[ebp]
  0019b	83 e8 01	 sub	 eax, 1
  0019e	0f af 45 0c	 imul	 eax, DWORD PTR _height$[ebp]
  001a2	8b 4d 0c	 mov	 ecx, DWORD PTR _height$[ebp]
  001a5	83 e9 01	 sub	 ecx, 1
  001a8	0f af 4d 08	 imul	 ecx, DWORD PTR _width$[ebp]
  001ac	03 c1		 add	 eax, ecx
  001ae	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  001b1	7d 0f		 jge	 SHORT $LN15@Setup

; 34   :   {
; 35   :     m_lineLoopThreat[i] = 0;

  001b3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001b6	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  001b9	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  001bc	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 36   :   };

  001c0	eb cd		 jmp	 SHORT $LN14@Setup
$LN15@Setup:

; 37   :   m_divideAndConquerWeight = new int[(width-1)*height + (height-1)*width];

  001c2	8b 45 08	 mov	 eax, DWORD PTR _width$[ebp]
  001c5	83 e8 01	 sub	 eax, 1
  001c8	0f af 45 0c	 imul	 eax, DWORD PTR _height$[ebp]
  001cc	8b 55 0c	 mov	 edx, DWORD PTR _height$[ebp]
  001cf	83 ea 01	 sub	 edx, 1
  001d2	0f af 55 08	 imul	 edx, DWORD PTR _width$[ebp]
  001d6	03 c2		 add	 eax, edx
  001d8	33 c9		 xor	 ecx, ecx
  001da	ba 04 00 00 00	 mov	 edx, 4
  001df	f7 e2		 mul	 edx
  001e1	0f 90 c1	 seto	 cl
  001e4	f7 d9		 neg	 ecx
  001e6	0b c8		 or	 ecx, eax
  001e8	51		 push	 ecx
  001e9	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  001ee	83 c4 04	 add	 esp, 4
  001f1	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
  001f4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001f7	8b 4d e0	 mov	 ecx, DWORD PTR $T3[ebp]
  001fa	89 08		 mov	 DWORD PTR [eax], ecx

; 38   :   for (i=0; i<(width-1)*height+(height-1)*width; i++)

  001fc	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00203	eb 09		 jmp	 SHORT $LN19@Setup
$LN17@Setup:
  00205	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00208	83 c2 01	 add	 edx, 1
  0020b	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN19@Setup:
  0020e	8b 45 08	 mov	 eax, DWORD PTR _width$[ebp]
  00211	83 e8 01	 sub	 eax, 1
  00214	0f af 45 0c	 imul	 eax, DWORD PTR _height$[ebp]
  00218	8b 4d 0c	 mov	 ecx, DWORD PTR _height$[ebp]
  0021b	83 e9 01	 sub	 ecx, 1
  0021e	0f af 4d 08	 imul	 ecx, DWORD PTR _width$[ebp]
  00222	03 c1		 add	 eax, ecx
  00224	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  00227	7d 11		 jge	 SHORT $LN18@Setup

; 39   :   {
; 40   :     m_divideAndConquerWeight[i] = -1;

  00229	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0022c	8b 02		 mov	 eax, DWORD PTR [edx]
  0022e	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00231	c7 04 88 ff ff
	ff ff		 mov	 DWORD PTR [eax+ecx*4], -1

; 41   :   };

  00238	eb cb		 jmp	 SHORT $LN17@Setup
$LN18@Setup:

; 42   :   m_breakUpLoopsWeight = new int[(width-1)*height + (height-1)*width];

  0023a	8b 45 08	 mov	 eax, DWORD PTR _width$[ebp]
  0023d	83 e8 01	 sub	 eax, 1
  00240	0f af 45 0c	 imul	 eax, DWORD PTR _height$[ebp]
  00244	8b 55 0c	 mov	 edx, DWORD PTR _height$[ebp]
  00247	83 ea 01	 sub	 edx, 1
  0024a	0f af 55 08	 imul	 edx, DWORD PTR _width$[ebp]
  0024e	03 c2		 add	 eax, edx
  00250	33 c9		 xor	 ecx, ecx
  00252	ba 04 00 00 00	 mov	 edx, 4
  00257	f7 e2		 mul	 edx
  00259	0f 90 c1	 seto	 cl
  0025c	f7 d9		 neg	 ecx
  0025e	0b c8		 or	 ecx, eax
  00260	51		 push	 ecx
  00261	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00266	83 c4 04	 add	 esp, 4
  00269	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
  0026c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0026f	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  00272	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 43   :   m_loopWeightsValid = false;

  00275	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00278	c6 42 0c 00	 mov	 BYTE PTR [edx+12], 0

; 44   :   for (i=0; i<(width-1)*height+(height-1)*width; i++)

  0027c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00283	eb 09		 jmp	 SHORT $LN22@Setup
$LN20@Setup:
  00285	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00288	83 c0 01	 add	 eax, 1
  0028b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN22@Setup:
  0028e	8b 4d 08	 mov	 ecx, DWORD PTR _width$[ebp]
  00291	83 e9 01	 sub	 ecx, 1
  00294	0f af 4d 0c	 imul	 ecx, DWORD PTR _height$[ebp]
  00298	8b 55 0c	 mov	 edx, DWORD PTR _height$[ebp]
  0029b	83 ea 01	 sub	 edx, 1
  0029e	0f af 55 08	 imul	 edx, DWORD PTR _width$[ebp]
  002a2	03 ca		 add	 ecx, edx
  002a4	39 4d f8	 cmp	 DWORD PTR _i$[ebp], ecx
  002a7	7d 11		 jge	 SHORT $LN21@Setup

; 45   :   {
; 46   :     m_divideAndConquerWeight[i] = -1;

  002a9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ae	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  002b1	c7 04 91 ff ff
	ff ff		 mov	 DWORD PTR [ecx+edx*4], -1

; 47   :   };

  002b8	eb cb		 jmp	 SHORT $LN20@Setup
$LN21@Setup:

; 48   :   m_divideWeightsValid = false;

  002ba	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002bd	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 49   :   m_avoidFlgs = new ui8[(width-1)*height + (height-1)*width];

  002c1	8b 4d 08	 mov	 ecx, DWORD PTR _width$[ebp]
  002c4	83 e9 01	 sub	 ecx, 1
  002c7	0f af 4d 0c	 imul	 ecx, DWORD PTR _height$[ebp]
  002cb	8b 55 0c	 mov	 edx, DWORD PTR _height$[ebp]
  002ce	83 ea 01	 sub	 edx, 1
  002d1	0f af 55 08	 imul	 edx, DWORD PTR _width$[ebp]
  002d5	03 ca		 add	 ecx, edx
  002d7	51		 push	 ecx
  002d8	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  002dd	83 c4 04	 add	 esp, 4
  002e0	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
  002e3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002e6	8b 4d d8	 mov	 ecx, DWORD PTR $T1[ebp]
  002e9	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 50   :   m_width = width;

  002ec	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002ef	8b 45 08	 mov	 eax, DWORD PTR _width$[ebp]
  002f2	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 51   :   m_height = height;

  002f5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002f8	8b 55 0c	 mov	 edx, DWORD PTR _height$[ebp]
  002fb	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 52   : }

  002fe	5f		 pop	 edi
  002ff	83 c4 28	 add	 esp, 40			; 00000028H
  00302	3b ec		 cmp	 ebp, esp
  00304	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00309	8b e5		 mov	 esp, ebp
  0030b	5d		 pop	 ebp
  0030c	c2 08 00	 ret	 8
?Setup@DOTS_AND_BOXES@@AAEXHH@Z ENDP			; DOTS_AND_BOXES::Setup
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
$T6 = -16						; size = 4
$T7 = -12						; size = 4
$T8 = -8						; size = 4
_this$ = -4						; size = 4
?Clear@DOTS_AND_BOXES@@AAEXXZ PROC			; DOTS_AND_BOXES::Clear
; _this$ = ecx

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0000e	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00011	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00014	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00017	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0001a	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001d	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00020	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00023	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00026	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 56   :   delete m_vlines;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0002f	89 4d f8	 mov	 DWORD PTR $T8[ebp], ecx
  00032	6a 01		 push	 1
  00034	8b 55 f8	 mov	 edx, DWORD PTR $T8[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003d	83 c4 08	 add	 esp, 8

; 57   :   delete m_hlines;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00046	89 4d f4	 mov	 DWORD PTR $T7[ebp], ecx
  00049	6a 01		 push	 1
  0004b	8b 55 f4	 mov	 edx, DWORD PTR $T7[ebp]
  0004e	52		 push	 edx
  0004f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00054	83 c4 08	 add	 esp, 8

; 58   :   delete m_owners;

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0005d	89 4d f0	 mov	 DWORD PTR $T6[ebp], ecx
  00060	6a 01		 push	 1
  00062	8b 55 f0	 mov	 edx, DWORD PTR $T6[ebp]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0006b	83 c4 08	 add	 esp, 8

; 59   :   delete m_dotLoopThreat;

  0006e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00071	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00074	89 4d ec	 mov	 DWORD PTR $T5[ebp], ecx
  00077	6a 01		 push	 1
  00079	8b 55 ec	 mov	 edx, DWORD PTR $T5[ebp]
  0007c	52		 push	 edx
  0007d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00082	83 c4 08	 add	 esp, 8

; 60   :   delete m_lineLoopThreat;

  00085	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0008b	89 4d e8	 mov	 DWORD PTR $T4[ebp], ecx
  0008e	6a 01		 push	 1
  00090	8b 55 e8	 mov	 edx, DWORD PTR $T4[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00099	83 c4 08	 add	 esp, 8

; 61   :   delete m_divideAndConquerWeight;

  0009c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a1	89 4d e4	 mov	 DWORD PTR $T3[ebp], ecx
  000a4	6a 04		 push	 4
  000a6	8b 55 e4	 mov	 edx, DWORD PTR $T3[ebp]
  000a9	52		 push	 edx
  000aa	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000af	83 c4 08	 add	 esp, 8

; 62   :   delete m_breakUpLoopsWeight;

  000b2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b5	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b8	89 4d e0	 mov	 DWORD PTR $T2[ebp], ecx
  000bb	6a 04		 push	 4
  000bd	8b 55 e0	 mov	 edx, DWORD PTR $T2[ebp]
  000c0	52		 push	 edx
  000c1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000c6	83 c4 08	 add	 esp, 8

; 63   :   delete m_avoidFlgs;

  000c9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000cf	89 4d dc	 mov	 DWORD PTR $T1[ebp], ecx
  000d2	6a 01		 push	 1
  000d4	8b 55 dc	 mov	 edx, DWORD PTR $T1[ebp]
  000d7	52		 push	 edx
  000d8	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000dd	83 c4 08	 add	 esp, 8

; 64   :   m_loopWeightsValid = false;

  000e0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e3	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 65   :   m_divideWeightsValid = false;

  000e7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ea	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0

; 66   : }

  000ee	83 c4 24	 add	 esp, 36			; 00000024H
  000f1	3b ec		 cmp	 ebp, esp
  000f3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c3		 ret	 0
?Clear@DOTS_AND_BOXES@@AAEXXZ ENDP			; DOTS_AND_BOXES::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
_TEXT	SEGMENT
tv250 = -120						; size = 4
tv248 = -113						; size = 1
tv219 = -112						; size = 4
tv217 = -105						; size = 1
tv193 = -104						; size = 4
tv264 = -100						; size = 4
tv269 = -96						; size = 4
tv162 = -92						; size = 4
tv134 = -88						; size = 4
tv86 = -84						; size = 4
tv260 = -80						; size = 4
tv65 = -76						; size = 4
$T2 = -72						; size = 1
$T3 = -71						; size = 1
$T4 = -70						; size = 1
$T5 = -69						; size = 1
$T6 = -68						; size = 4
$T7 = -63						; size = 1
$T8 = -62						; size = 1
$T9 = -61						; size = 1
$T10 = -60						; size = 4
$T11 = -53						; size = 1
_ownerType$ = -52					; size = 4
_lineType$ = -48					; size = 4
_error$ = -41						; size = 1
_line$ = -36						; size = 4
_m$ = -28						; size = 4
_row$ = -24						; size = 4
_col$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_arIn$ = 8						; size = 4
?ReadFromArchive@DOTS_AND_BOXES@@AAE_NAAVarInput@@@Z PROC ; DOTS_AND_BOXES::ReadFromArchive
; _this$ = ecx

; 167  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ReadFromArchive@DOTS_AND_BOXES@@AAE_NAAVarInput@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	8d 7d 88	 lea	 edi, DWORD PTR [ebp-120]
  0001a	b9 1b 00 00 00	 mov	 ecx, 27			; 0000001bH
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	59		 pop	 ecx
  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002c	33 c5		 xor	 eax, ebp
  0002e	50		 push	 eax
  0002f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00032	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00038	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 168  :   int col, row, m;
; 169  :   CString line;

  0003b	8b f4		 mov	 esi, esp
  0003d	8d 4d dc	 lea	 ecx, DWORD PTR _line$[ebp]
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00046	3b f4		 cmp	 esi, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 170  :   bool error;
; 171  :   LINE_TYPE lineType = LINE_NONE; // to avoid compiler warning

  00054	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _lineType$[ebp], 0

; 172  :   OWNER_TYPE ownerType;
; 173  :   m_loopWeightsValid = false;

  0005b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 174  :   m_divideWeightsValid = false;

  00062	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0

; 175  :   for(row=0; row<MAX_HEIGHT; row++)

  00069	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _row$[ebp], 0
  00070	eb 09		 jmp	 SHORT $LN4@ReadFromAr
$LN2@ReadFromAr:
  00072	8b 55 e8	 mov	 edx, DWORD PTR _row$[ebp]
  00075	83 c2 01	 add	 edx, 1
  00078	89 55 e8	 mov	 DWORD PTR _row$[ebp], edx
$LN4@ReadFromAr:
  0007b	83 7d e8 0b	 cmp	 DWORD PTR _row$[ebp], 11 ; 0000000bH
  0007f	0f 8d 74 04 00
	00		 jge	 $LN3@ReadFromAr

; 176  :   {
; 177  :     // First dots and horizontal lines
; 178  :     if ((line = arIn.ReadLine()).GetLength() == 0) break;

  00085	8d 45 c4	 lea	 eax, DWORD PTR $T10[ebp]
  00088	50		 push	 eax
  00089	8b 4d 08	 mov	 ecx, DWORD PTR _arIn$[ebp]
  0008c	e8 00 00 00 00	 call	 ?ReadLine@arInput@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; arInput::ReadLine
  00091	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  00094	8b 4d b4	 mov	 ecx, DWORD PTR tv65[ebp]
  00097	89 4d b0	 mov	 DWORD PTR tv260[ebp], ecx
  0009a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0009e	8b f4		 mov	 esi, esp
  000a0	8b 55 b0	 mov	 edx, DWORD PTR tv260[ebp]
  000a3	52		 push	 edx
  000a4	8d 4d dc	 lea	 ecx, DWORD PTR _line$[ebp]
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  000ad	3b f4		 cmp	 esi, esp
  000af	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b4	8b f4		 mov	 esi, esp
  000b6	8b c8		 mov	 ecx, eax
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  000be	3b f4		 cmp	 esi, esp
  000c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c5	85 c0		 test	 eax, eax
  000c7	75 09		 jne	 SHORT $LN44@ReadFromAr
  000c9	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv86[ebp], 1
  000d0	eb 07		 jmp	 SHORT $LN45@ReadFromAr
$LN44@ReadFromAr:
  000d2	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
$LN45@ReadFromAr:
  000d9	8a 45 ac	 mov	 al, BYTE PTR tv86[ebp]
  000dc	88 45 cb	 mov	 BYTE PTR $T11[ebp], al
  000df	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000e3	8b f4		 mov	 esi, esp
  000e5	8d 4d c4	 lea	 ecx, DWORD PTR $T10[ebp]
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000ee	3b f4		 cmp	 esi, esp
  000f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f5	0f b6 4d cb	 movzx	 ecx, BYTE PTR $T11[ebp]
  000f9	85 c9		 test	 ecx, ecx
  000fb	74 05		 je	 SHORT $LN17@ReadFromAr
  000fd	e9 f7 03 00 00	 jmp	 $LN3@ReadFromAr
$LN17@ReadFromAr:

; 179  :     m = (row==0) ? (strlen(line)+1)/2 : m_width;

  00102	83 7d e8 00	 cmp	 DWORD PTR _row$[ebp], 0
  00106	75 25		 jne	 SHORT $LN46@ReadFromAr
  00108	8b f4		 mov	 esi, esp
  0010a	8d 4d dc	 lea	 ecx, DWORD PTR _line$[ebp]
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00113	3b f4		 cmp	 esi, esp
  00115	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011a	50		 push	 eax
  0011b	e8 00 00 00 00	 call	 _strlen
  00120	83 c4 04	 add	 esp, 4
  00123	83 c0 01	 add	 eax, 1
  00126	d1 e8		 shr	 eax, 1
  00128	89 45 a8	 mov	 DWORD PTR tv134[ebp], eax
  0012b	eb 09		 jmp	 SHORT $LN47@ReadFromAr
$LN46@ReadFromAr:
  0012d	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00130	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00133	89 45 a8	 mov	 DWORD PTR tv134[ebp], eax
$LN47@ReadFromAr:
  00136	8b 4d a8	 mov	 ecx, DWORD PTR tv134[ebp]
  00139	89 4d e4	 mov	 DWORD PTR _m$[ebp], ecx

; 180  :     for (col=0; col<m; col++)

  0013c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _col$[ebp], 0
  00143	eb 09		 jmp	 SHORT $LN7@ReadFromAr
$LN5@ReadFromAr:
  00145	8b 55 ec	 mov	 edx, DWORD PTR _col$[ebp]
  00148	83 c2 01	 add	 edx, 1
  0014b	89 55 ec	 mov	 DWORD PTR _col$[ebp], edx
$LN7@ReadFromAr:
  0014e	8b 45 ec	 mov	 eax, DWORD PTR _col$[ebp]
  00151	3b 45 e4	 cmp	 eax, DWORD PTR _m$[ebp]
  00154	0f 8d 30 01 00
	00		 jge	 $LN6@ReadFromAr

; 181  :     {
; 182  :       if (line[2*col] != DOT_CHAR)

  0015a	8b 4d ec	 mov	 ecx, DWORD PTR _col$[ebp]
  0015d	d1 e1		 shl	 ecx, 1
  0015f	8b f4		 mov	 esi, esp
  00161	51		 push	 ecx
  00162	8d 4d dc	 lea	 ecx, DWORD PTR _line$[ebp]
  00165	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$CSimpleStringT@D$00@ATL@@QBEDH@Z
  0016b	3b f4		 cmp	 esi, esp
  0016d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00172	0f be d0	 movsx	 edx, al
  00175	83 fa 2b	 cmp	 edx, 43			; 0000002bH
  00178	74 44		 je	 SHORT $LN18@ReadFromAr

; 183  :       {
; 184  :         if (row == 0)

  0017a	83 7d e8 00	 cmp	 DWORD PTR _row$[ebp], 0
  0017e	75 10		 jne	 SHORT $LN19@ReadFromAr

; 185  :         {
; 186  :           m_width = col;

  00180	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00183	8b 4d ec	 mov	 ecx, DWORD PTR _col$[ebp]
  00186	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 187  :           break;

  00189	e9 fc 00 00 00	 jmp	 $LN6@ReadFromAr

; 188  :         }

  0018e	eb 2e		 jmp	 SHORT $LN18@ReadFromAr
$LN19@ReadFromAr:

; 189  :         else
; 190  :         {
; 191  :           m_height = row;

  00190	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00193	8b 45 e8	 mov	 eax, DWORD PTR _row$[ebp]
  00196	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 192  :           return true;

  00199	c6 45 c3 01	 mov	 BYTE PTR $T9[ebp], 1
  0019d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001a4	8b f4		 mov	 esi, esp
  001a6	8d 4d dc	 lea	 ecx, DWORD PTR _line$[ebp]
  001a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001af	3b f4		 cmp	 esi, esp
  001b1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b6	8a 45 c3	 mov	 al, BYTE PTR $T9[ebp]
  001b9	e9 68 03 00 00	 jmp	 $LN1@ReadFromAr
$LN18@ReadFromAr:

; 193  :         };
; 194  :       };
; 195  :       if (col < m-1)

  001be	8b 4d e4	 mov	 ecx, DWORD PTR _m$[ebp]
  001c1	83 e9 01	 sub	 ecx, 1
  001c4	39 4d ec	 cmp	 DWORD PTR _col$[ebp], ecx
  001c7	0f 8d b8 00 00
	00		 jge	 $LN21@ReadFromAr

; 196  :       {
; 197  :         error = false;

  001cd	c6 45 d7 00	 mov	 BYTE PTR _error$[ebp], 0

; 198  :         switch (line[2*col+1])

  001d1	8b 55 ec	 mov	 edx, DWORD PTR _col$[ebp]
  001d4	8d 44 12 01	 lea	 eax, DWORD PTR [edx+edx+1]
  001d8	8b f4		 mov	 esi, esp
  001da	50		 push	 eax
  001db	8d 4d dc	 lea	 ecx, DWORD PTR _line$[ebp]
  001de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$CSimpleStringT@D$00@ATL@@QBEDH@Z
  001e4	3b f4		 cmp	 esi, esp
  001e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001eb	88 45 a4	 mov	 BYTE PTR tv162[ebp], al
  001ee	80 7d a4 20	 cmp	 BYTE PTR tv162[ebp], 32	; 00000020H
  001f2	74 20		 je	 SHORT $LN24@ReadFromAr
  001f4	80 7d a4 2d	 cmp	 BYTE PTR tv162[ebp], 45	; 0000002dH
  001f8	74 08		 je	 SHORT $LN22@ReadFromAr
  001fa	80 7d a4 3d	 cmp	 BYTE PTR tv162[ebp], 61	; 0000003dH
  001fe	74 0b		 je	 SHORT $LN23@ReadFromAr
  00200	eb 1b		 jmp	 SHORT $LN25@ReadFromAr
$LN22@ReadFromAr:

; 199  :         {
; 200  :         case HORIZONTAL_HUMAN_CHAR: lineType = LINE_HUMAN; break;

  00202	c7 45 d0 02 00
	00 00		 mov	 DWORD PTR _lineType$[ebp], 2
  00209	eb 16		 jmp	 SHORT $LN8@ReadFromAr
$LN23@ReadFromAr:

; 201  :         case HORIZONTAL_COMPUTER_CHAR: lineType = LINE_COMPUTER; break;

  0020b	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _lineType$[ebp], 1
  00212	eb 0d		 jmp	 SHORT $LN8@ReadFromAr
$LN24@ReadFromAr:

; 202  :         case ' ': lineType = LINE_NONE; break;

  00214	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _lineType$[ebp], 0
  0021b	eb 04		 jmp	 SHORT $LN8@ReadFromAr
$LN25@ReadFromAr:

; 203  :         default: error = true;

  0021d	c6 45 d7 01	 mov	 BYTE PTR _error$[ebp], 1
$LN8@ReadFromAr:

; 204  :         };
; 205  :         if (error)

  00221	0f b6 4d d7	 movzx	 ecx, BYTE PTR _error$[ebp]
  00225	85 c9		 test	 ecx, ecx
  00227	74 48		 je	 SHORT $LN26@ReadFromAr

; 206  :         {
; 207  :           if (row == 0) 

  00229	83 7d e8 00	 cmp	 DWORD PTR _row$[ebp], 0
  0022d	75 10		 jne	 SHORT $LN27@ReadFromAr

; 208  :           {
; 209  :             m_width = col + 1;

  0022f	8b 55 ec	 mov	 edx, DWORD PTR _col$[ebp]
  00232	83 c2 01	 add	 edx, 1
  00235	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00238	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 210  :             break;

  0023b	eb 4d		 jmp	 SHORT $LN6@ReadFromAr

; 211  :           }

  0023d	eb 32		 jmp	 SHORT $LN26@ReadFromAr
$LN27@ReadFromAr:

; 212  :           else
; 213  :           {
; 214  :             BadFormat("Expected Horizontal line character");

  0023f	68 00 00 00 00	 push	 OFFSET $SG225114
  00244	e8 00 00 00 00	 call	 ?BadFormat@@YAXPAD@Z	; BadFormat
  00249	83 c4 04	 add	 esp, 4

; 215  :             return false;

  0024c	c6 45 c2 00	 mov	 BYTE PTR $T8[ebp], 0
  00250	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00257	8b f4		 mov	 esi, esp
  00259	8d 4d dc	 lea	 ecx, DWORD PTR _line$[ebp]
  0025c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00262	3b f4		 cmp	 esi, esp
  00264	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00269	8a 45 c2	 mov	 al, BYTE PTR $T8[ebp]
  0026c	e9 b5 02 00 00	 jmp	 $LN1@ReadFromAr
$LN26@ReadFromAr:

; 216  :           };
; 217  :         };
; 218  :         SetHLineType(col, row, lineType);

  00271	8b 4d d0	 mov	 ecx, DWORD PTR _lineType$[ebp]
  00274	51		 push	 ecx
  00275	8b 55 e8	 mov	 edx, DWORD PTR _row$[ebp]
  00278	52		 push	 edx
  00279	8b 45 ec	 mov	 eax, DWORD PTR _col$[ebp]
  0027c	50		 push	 eax
  0027d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00280	e8 00 00 00 00	 call	 ?SetHLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetHLineType
$LN21@ReadFromAr:

; 219  :       };
; 220  :     };

  00285	e9 bb fe ff ff	 jmp	 $LN5@ReadFromAr
$LN6@ReadFromAr:

; 221  :     // Now vertical lines and box owners
; 222  :     if ((line = arIn.ReadLine()).GetLength() == 0) 

  0028a	8d 4d bc	 lea	 ecx, DWORD PTR $T6[ebp]
  0028d	51		 push	 ecx
  0028e	8b 4d 08	 mov	 ecx, DWORD PTR _arIn$[ebp]
  00291	e8 00 00 00 00	 call	 ?ReadLine@arInput@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; arInput::ReadLine
  00296	89 45 a0	 mov	 DWORD PTR tv269[ebp], eax
  00299	8b 55 a0	 mov	 edx, DWORD PTR tv269[ebp]
  0029c	89 55 9c	 mov	 DWORD PTR tv264[ebp], edx
  0029f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  002a3	8b f4		 mov	 esi, esp
  002a5	8b 45 9c	 mov	 eax, DWORD PTR tv264[ebp]
  002a8	50		 push	 eax
  002a9	8d 4d dc	 lea	 ecx, DWORD PTR _line$[ebp]
  002ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  002b2	3b f4		 cmp	 esi, esp
  002b4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002b9	8b f4		 mov	 esi, esp
  002bb	8b c8		 mov	 ecx, eax
  002bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  002c3	3b f4		 cmp	 esi, esp
  002c5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002ca	85 c0		 test	 eax, eax
  002cc	75 09		 jne	 SHORT $LN48@ReadFromAr
  002ce	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv193[ebp], 1
  002d5	eb 07		 jmp	 SHORT $LN49@ReadFromAr
$LN48@ReadFromAr:
  002d7	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv193[ebp], 0
$LN49@ReadFromAr:
  002de	8a 4d 98	 mov	 cl, BYTE PTR tv193[ebp]
  002e1	88 4d c1	 mov	 BYTE PTR $T7[ebp], cl
  002e4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  002e8	8b f4		 mov	 esi, esp
  002ea	8d 4d bc	 lea	 ecx, DWORD PTR $T6[ebp]
  002ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  002f3	3b f4		 cmp	 esi, esp
  002f5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002fa	0f b6 55 c1	 movzx	 edx, BYTE PTR $T7[ebp]
  002fe	85 d2		 test	 edx, edx
  00300	74 32		 je	 SHORT $LN29@ReadFromAr

; 223  :     {
; 224  :       BadFormat("Expected vertical lines and owners.");

  00302	68 00 00 00 00	 push	 OFFSET $SG225118
  00307	e8 00 00 00 00	 call	 ?BadFormat@@YAXPAD@Z	; BadFormat
  0030c	83 c4 04	 add	 esp, 4

; 225  :       return false;

  0030f	c6 45 bb 00	 mov	 BYTE PTR $T5[ebp], 0
  00313	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0031a	8b f4		 mov	 esi, esp
  0031c	8d 4d dc	 lea	 ecx, DWORD PTR _line$[ebp]
  0031f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00325	3b f4		 cmp	 esi, esp
  00327	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0032c	8a 45 bb	 mov	 al, BYTE PTR $T5[ebp]
  0032f	e9 f2 01 00 00	 jmp	 $LN1@ReadFromAr
$LN29@ReadFromAr:

; 226  :     };
; 227  :     for (col=0; col<m_width; col++)

  00334	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _col$[ebp], 0
  0033b	eb 09		 jmp	 SHORT $LN12@ReadFromAr
$LN10@ReadFromAr:
  0033d	8b 45 ec	 mov	 eax, DWORD PTR _col$[ebp]
  00340	83 c0 01	 add	 eax, 1
  00343	89 45 ec	 mov	 DWORD PTR _col$[ebp], eax
$LN12@ReadFromAr:
  00346	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00349	8b 55 ec	 mov	 edx, DWORD PTR _col$[ebp]
  0034c	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  0034f	0f 8d 9f 01 00
	00		 jge	 $LN11@ReadFromAr

; 228  :     {
; 229  :       switch ((line.GetLength()>2*col)?line[2*col]:' ')

  00355	8b f4		 mov	 esi, esp
  00357	8d 4d dc	 lea	 ecx, DWORD PTR _line$[ebp]
  0035a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  00360	3b f4		 cmp	 esi, esp
  00362	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00367	8b 4d ec	 mov	 ecx, DWORD PTR _col$[ebp]
  0036a	d1 e1		 shl	 ecx, 1
  0036c	3b c1		 cmp	 eax, ecx
  0036e	7e 1d		 jle	 SHORT $LN50@ReadFromAr
  00370	8b 55 ec	 mov	 edx, DWORD PTR _col$[ebp]
  00373	d1 e2		 shl	 edx, 1
  00375	8b f4		 mov	 esi, esp
  00377	52		 push	 edx
  00378	8d 4d dc	 lea	 ecx, DWORD PTR _line$[ebp]
  0037b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$CSimpleStringT@D$00@ATL@@QBEDH@Z
  00381	3b f4		 cmp	 esi, esp
  00383	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00388	88 45 97	 mov	 BYTE PTR tv217[ebp], al
  0038b	eb 04		 jmp	 SHORT $LN51@ReadFromAr
$LN50@ReadFromAr:
  0038d	c6 45 97 20	 mov	 BYTE PTR tv217[ebp], 32	; 00000020H
$LN51@ReadFromAr:
  00391	0f be 45 97	 movsx	 eax, BYTE PTR tv217[ebp]
  00395	89 45 90	 mov	 DWORD PTR tv219[ebp], eax
  00398	83 7d 90 7c	 cmp	 DWORD PTR tv219[ebp], 124 ; 0000007cH
  0039c	77 35		 ja	 SHORT $LN35@ReadFromAr
  0039e	8b 4d 90	 mov	 ecx, DWORD PTR tv219[ebp]
  003a1	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN57@ReadFromAr[ecx]
  003a8	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN58@ReadFromAr[edx*4]
$LN30@ReadFromAr:

; 230  :       {
; 231  :       case VERTICAL_HUMAN_CHAR: lineType = LINE_HUMAN; break;

  003af	c7 45 d0 02 00
	00 00		 mov	 DWORD PTR _lineType$[ebp], 2
  003b6	eb 4c		 jmp	 SHORT $LN13@ReadFromAr
$LN31@ReadFromAr:

; 232  :       case VERTICAL_COMPUTER_CHAR: lineType = LINE_COMPUTER; break;

  003b8	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _lineType$[ebp], 1
  003bf	eb 43		 jmp	 SHORT $LN13@ReadFromAr
$LN32@ReadFromAr:

; 233  :       case ' ': lineType = LINE_NONE; break;

  003c1	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _lineType$[ebp], 0
  003c8	eb 3a		 jmp	 SHORT $LN13@ReadFromAr
$LN34@ReadFromAr:

; 234  :       case 0:    
; 235  :       case '\n': lineType = LINE_NONE; break;

  003ca	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _lineType$[ebp], 0
  003d1	eb 31		 jmp	 SHORT $LN13@ReadFromAr
$LN35@ReadFromAr:

; 236  :       default:
; 237  :         m_height = row + 1;

  003d3	8b 45 e8	 mov	 eax, DWORD PTR _row$[ebp]
  003d6	83 c0 01	 add	 eax, 1
  003d9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  003dc	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 238  :         return true;

  003df	c6 45 ba 01	 mov	 BYTE PTR $T4[ebp], 1
  003e3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003ea	8b f4		 mov	 esi, esp
  003ec	8d 4d dc	 lea	 ecx, DWORD PTR _line$[ebp]
  003ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  003f5	3b f4		 cmp	 esi, esp
  003f7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003fc	8a 45 ba	 mov	 al, BYTE PTR $T4[ebp]
  003ff	e9 22 01 00 00	 jmp	 $LN1@ReadFromAr
$LN13@ReadFromAr:

; 239  :       };
; 240  :       SetVLineType(col, row, lineType);

  00404	8b 55 d0	 mov	 edx, DWORD PTR _lineType$[ebp]
  00407	52		 push	 edx
  00408	8b 45 e8	 mov	 eax, DWORD PTR _row$[ebp]
  0040b	50		 push	 eax
  0040c	8b 4d ec	 mov	 ecx, DWORD PTR _col$[ebp]
  0040f	51		 push	 ecx
  00410	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00413	e8 00 00 00 00	 call	 ?SetVLineType@DOTS_AND_BOXES@@QAEXHHW4LINE_TYPE@@@Z ; DOTS_AND_BOXES::SetVLineType

; 241  :       if (col < m_width-1)

  00418	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0041b	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0041e	83 e8 01	 sub	 eax, 1
  00421	39 45 ec	 cmp	 DWORD PTR _col$[ebp], eax
  00424	0f 8d c5 00 00
	00		 jge	 $LN36@ReadFromAr

; 242  :       {
; 243  :         switch (line.GetLength()>(2*col+1)?line[2*col+1]:' ')

  0042a	8b f4		 mov	 esi, esp
  0042c	8d 4d dc	 lea	 ecx, DWORD PTR _line$[ebp]
  0042f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  00435	3b f4		 cmp	 esi, esp
  00437	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0043c	8b 4d ec	 mov	 ecx, DWORD PTR _col$[ebp]
  0043f	8d 54 09 01	 lea	 edx, DWORD PTR [ecx+ecx+1]
  00443	3b c2		 cmp	 eax, edx
  00445	7e 1f		 jle	 SHORT $LN52@ReadFromAr
  00447	8b 45 ec	 mov	 eax, DWORD PTR _col$[ebp]
  0044a	8d 4c 00 01	 lea	 ecx, DWORD PTR [eax+eax+1]
  0044e	8b f4		 mov	 esi, esp
  00450	51		 push	 ecx
  00451	8d 4d dc	 lea	 ecx, DWORD PTR _line$[ebp]
  00454	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$CSimpleStringT@D$00@ATL@@QBEDH@Z
  0045a	3b f4		 cmp	 esi, esp
  0045c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00461	88 45 8f	 mov	 BYTE PTR tv248[ebp], al
  00464	eb 04		 jmp	 SHORT $LN53@ReadFromAr
$LN52@ReadFromAr:
  00466	c6 45 8f 20	 mov	 BYTE PTR tv248[ebp], 32	; 00000020H
$LN53@ReadFromAr:
  0046a	0f be 55 8f	 movsx	 edx, BYTE PTR tv248[ebp]
  0046e	89 55 88	 mov	 DWORD PTR tv250[ebp], edx
  00471	83 7d 88 48	 cmp	 DWORD PTR tv250[ebp], 72 ; 00000048H
  00475	77 35		 ja	 SHORT $LN42@ReadFromAr
  00477	8b 45 88	 mov	 eax, DWORD PTR tv250[ebp]
  0047a	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN59@ReadFromAr[eax]
  00481	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN60@ReadFromAr[ecx*4]
$LN37@ReadFromAr:

; 244  :         {
; 245  :         case OWNER_HUMAN_CHAR: ownerType = OWNER_HUMAN; break;

  00488	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _ownerType$[ebp], 1
  0048f	eb 4a		 jmp	 SHORT $LN15@ReadFromAr
$LN38@ReadFromAr:

; 246  :         case OWNER_COMPUTER_CHAR: ownerType = OWNER_COMPUTER; break;

  00491	c7 45 cc 02 00
	00 00		 mov	 DWORD PTR _ownerType$[ebp], 2
  00498	eb 41		 jmp	 SHORT $LN15@ReadFromAr
$LN39@ReadFromAr:

; 247  :         case ' ': ownerType = OWNER_NONE; break;

  0049a	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _ownerType$[ebp], 0
  004a1	eb 38		 jmp	 SHORT $LN15@ReadFromAr
$LN41@ReadFromAr:

; 248  :         case 0:    
; 249  :         case '\n': ownerType = OWNER_NONE; break;

  004a3	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _ownerType$[ebp], 0
  004aa	eb 2f		 jmp	 SHORT $LN15@ReadFromAr
$LN42@ReadFromAr:

; 250  :         default:
; 251  :           BadFormat("Expected blank or Owner Type");

  004ac	68 00 00 00 00	 push	 OFFSET $SG225134
  004b1	e8 00 00 00 00	 call	 ?BadFormat@@YAXPAD@Z	; BadFormat
  004b6	83 c4 04	 add	 esp, 4

; 252  :           return false;

  004b9	c6 45 b9 00	 mov	 BYTE PTR $T3[ebp], 0
  004bd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  004c4	8b f4		 mov	 esi, esp
  004c6	8d 4d dc	 lea	 ecx, DWORD PTR _line$[ebp]
  004c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  004cf	3b f4		 cmp	 esi, esp
  004d1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004d6	8a 45 b9	 mov	 al, BYTE PTR $T3[ebp]
  004d9	eb 4b		 jmp	 SHORT $LN1@ReadFromAr
$LN15@ReadFromAr:

; 253  :         };
; 254  :         SetBoxOwner(col, row, ownerType);

  004db	8b 55 cc	 mov	 edx, DWORD PTR _ownerType$[ebp]
  004de	52		 push	 edx
  004df	8b 45 e8	 mov	 eax, DWORD PTR _row$[ebp]
  004e2	50		 push	 eax
  004e3	8b 4d ec	 mov	 ecx, DWORD PTR _col$[ebp]
  004e6	51		 push	 ecx
  004e7	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  004ea	e8 00 00 00 00	 call	 ?SetBoxOwner@DOTS_AND_BOXES@@QAEXHHW4OWNER_TYPE@@@Z ; DOTS_AND_BOXES::SetBoxOwner
$LN36@ReadFromAr:

; 255  :       };
; 256  :     };

  004ef	e9 49 fe ff ff	 jmp	 $LN10@ReadFromAr
$LN11@ReadFromAr:

; 257  :   };

  004f4	e9 79 fb ff ff	 jmp	 $LN2@ReadFromAr
$LN3@ReadFromAr:

; 258  :   BadFormat("No game found in file");

  004f9	68 00 00 00 00	 push	 OFFSET $SG225136
  004fe	e8 00 00 00 00	 call	 ?BadFormat@@YAXPAD@Z	; BadFormat
  00503	83 c4 04	 add	 esp, 4

; 259  :   return false;

  00506	c6 45 b8 00	 mov	 BYTE PTR $T2[ebp], 0
  0050a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00511	8b f4		 mov	 esi, esp
  00513	8d 4d dc	 lea	 ecx, DWORD PTR _line$[ebp]
  00516	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0051c	3b f4		 cmp	 esi, esp
  0051e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00523	8a 45 b8	 mov	 al, BYTE PTR $T2[ebp]
$LN1@ReadFromAr:

; 260  : }

  00526	52		 push	 edx
  00527	8b cd		 mov	 ecx, ebp
  00529	50		 push	 eax
  0052a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN64@ReadFromAr
  00530	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00535	58		 pop	 eax
  00536	5a		 pop	 edx
  00537	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0053a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00541	59		 pop	 ecx
  00542	5f		 pop	 edi
  00543	5e		 pop	 esi
  00544	83 c4 78	 add	 esp, 120		; 00000078H
  00547	3b ec		 cmp	 ebp, esp
  00549	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0054e	8b e5		 mov	 esp, ebp
  00550	5d		 pop	 ebp
  00551	c2 04 00	 ret	 4
$LN64@ReadFromAr:
  00554	01 00 00 00	 DD	 1
  00558	00 00 00 00	 DD	 $LN63@ReadFromAr
$LN63@ReadFromAr:
  0055c	dc ff ff ff	 DD	 -36			; ffffffdcH
  00560	04 00 00 00	 DD	 4
  00564	00 00 00 00	 DD	 $LN61@ReadFromAr
$LN61@ReadFromAr:
  00568	6c		 DB	 108			; 0000006cH
  00569	69		 DB	 105			; 00000069H
  0056a	6e		 DB	 110			; 0000006eH
  0056b	65		 DB	 101			; 00000065H
  0056c	00		 DB	 0
  0056d	0f 1f 00	 npad	 3
$LN58@ReadFromAr:
  00570	00 00 00 00	 DD	 $LN34@ReadFromAr
  00574	00 00 00 00	 DD	 $LN32@ReadFromAr
  00578	00 00 00 00	 DD	 $LN30@ReadFromAr
  0057c	00 00 00 00	 DD	 $LN31@ReadFromAr
  00580	00 00 00 00	 DD	 $LN35@ReadFromAr
$LN57@ReadFromAr:
  00584	00		 DB	 0
  00585	04		 DB	 4
  00586	04		 DB	 4
  00587	04		 DB	 4
  00588	04		 DB	 4
  00589	04		 DB	 4
  0058a	04		 DB	 4
  0058b	04		 DB	 4
  0058c	04		 DB	 4
  0058d	04		 DB	 4
  0058e	00		 DB	 0
  0058f	04		 DB	 4
  00590	04		 DB	 4
  00591	04		 DB	 4
  00592	04		 DB	 4
  00593	04		 DB	 4
  00594	04		 DB	 4
  00595	04		 DB	 4
  00596	04		 DB	 4
  00597	04		 DB	 4
  00598	04		 DB	 4
  00599	04		 DB	 4
  0059a	04		 DB	 4
  0059b	04		 DB	 4
  0059c	04		 DB	 4
  0059d	04		 DB	 4
  0059e	04		 DB	 4
  0059f	04		 DB	 4
  005a0	04		 DB	 4
  005a1	04		 DB	 4
  005a2	04		 DB	 4
  005a3	04		 DB	 4
  005a4	01		 DB	 1
  005a5	04		 DB	 4
  005a6	04		 DB	 4
  005a7	04		 DB	 4
  005a8	04		 DB	 4
  005a9	04		 DB	 4
  005aa	04		 DB	 4
  005ab	04		 DB	 4
  005ac	04		 DB	 4
  005ad	04		 DB	 4
  005ae	04		 DB	 4
  005af	04		 DB	 4
  005b0	04		 DB	 4
  005b1	04		 DB	 4
  005b2	04		 DB	 4
  005b3	04		 DB	 4
  005b4	04		 DB	 4
  005b5	04		 DB	 4
  005b6	04		 DB	 4
  005b7	04		 DB	 4
  005b8	04		 DB	 4
  005b9	04		 DB	 4
  005ba	04		 DB	 4
  005bb	04		 DB	 4
  005bc	04		 DB	 4
  005bd	04		 DB	 4
  005be	04		 DB	 4
  005bf	04		 DB	 4
  005c0	04		 DB	 4
  005c1	04		 DB	 4
  005c2	04		 DB	 4
  005c3	04		 DB	 4
  005c4	04		 DB	 4
  005c5	04		 DB	 4
  005c6	04		 DB	 4
  005c7	04		 DB	 4
  005c8	04		 DB	 4
  005c9	04		 DB	 4
  005ca	04		 DB	 4
  005cb	04		 DB	 4
  005cc	04		 DB	 4
  005cd	02		 DB	 2
  005ce	04		 DB	 4
  005cf	04		 DB	 4
  005d0	04		 DB	 4
  005d1	04		 DB	 4
  005d2	04		 DB	 4
  005d3	04		 DB	 4
  005d4	04		 DB	 4
  005d5	04		 DB	 4
  005d6	04		 DB	 4
  005d7	04		 DB	 4
  005d8	04		 DB	 4
  005d9	04		 DB	 4
  005da	04		 DB	 4
  005db	04		 DB	 4
  005dc	04		 DB	 4
  005dd	04		 DB	 4
  005de	04		 DB	 4
  005df	04		 DB	 4
  005e0	04		 DB	 4
  005e1	04		 DB	 4
  005e2	04		 DB	 4
  005e3	04		 DB	 4
  005e4	04		 DB	 4
  005e5	04		 DB	 4
  005e6	04		 DB	 4
  005e7	04		 DB	 4
  005e8	04		 DB	 4
  005e9	04		 DB	 4
  005ea	04		 DB	 4
  005eb	04		 DB	 4
  005ec	04		 DB	 4
  005ed	04		 DB	 4
  005ee	04		 DB	 4
  005ef	04		 DB	 4
  005f0	04		 DB	 4
  005f1	04		 DB	 4
  005f2	04		 DB	 4
  005f3	04		 DB	 4
  005f4	04		 DB	 4
  005f5	04		 DB	 4
  005f6	04		 DB	 4
  005f7	04		 DB	 4
  005f8	04		 DB	 4
  005f9	04		 DB	 4
  005fa	04		 DB	 4
  005fb	04		 DB	 4
  005fc	04		 DB	 4
  005fd	04		 DB	 4
  005fe	04		 DB	 4
  005ff	04		 DB	 4
  00600	03		 DB	 3
  00601	0f 1f 00	 npad	 3
$LN60@ReadFromAr:
  00604	00 00 00 00	 DD	 $LN41@ReadFromAr
  00608	00 00 00 00	 DD	 $LN39@ReadFromAr
  0060c	00 00 00 00	 DD	 $LN38@ReadFromAr
  00610	00 00 00 00	 DD	 $LN37@ReadFromAr
  00614	00 00 00 00	 DD	 $LN42@ReadFromAr
$LN59@ReadFromAr:
  00618	00		 DB	 0
  00619	04		 DB	 4
  0061a	04		 DB	 4
  0061b	04		 DB	 4
  0061c	04		 DB	 4
  0061d	04		 DB	 4
  0061e	04		 DB	 4
  0061f	04		 DB	 4
  00620	04		 DB	 4
  00621	04		 DB	 4
  00622	00		 DB	 0
  00623	04		 DB	 4
  00624	04		 DB	 4
  00625	04		 DB	 4
  00626	04		 DB	 4
  00627	04		 DB	 4
  00628	04		 DB	 4
  00629	04		 DB	 4
  0062a	04		 DB	 4
  0062b	04		 DB	 4
  0062c	04		 DB	 4
  0062d	04		 DB	 4
  0062e	04		 DB	 4
  0062f	04		 DB	 4
  00630	04		 DB	 4
  00631	04		 DB	 4
  00632	04		 DB	 4
  00633	04		 DB	 4
  00634	04		 DB	 4
  00635	04		 DB	 4
  00636	04		 DB	 4
  00637	04		 DB	 4
  00638	01		 DB	 1
  00639	04		 DB	 4
  0063a	04		 DB	 4
  0063b	04		 DB	 4
  0063c	04		 DB	 4
  0063d	04		 DB	 4
  0063e	04		 DB	 4
  0063f	04		 DB	 4
  00640	04		 DB	 4
  00641	04		 DB	 4
  00642	04		 DB	 4
  00643	04		 DB	 4
  00644	04		 DB	 4
  00645	04		 DB	 4
  00646	04		 DB	 4
  00647	04		 DB	 4
  00648	04		 DB	 4
  00649	04		 DB	 4
  0064a	04		 DB	 4
  0064b	04		 DB	 4
  0064c	04		 DB	 4
  0064d	04		 DB	 4
  0064e	04		 DB	 4
  0064f	04		 DB	 4
  00650	04		 DB	 4
  00651	04		 DB	 4
  00652	04		 DB	 4
  00653	04		 DB	 4
  00654	04		 DB	 4
  00655	04		 DB	 4
  00656	04		 DB	 4
  00657	04		 DB	 4
  00658	04		 DB	 4
  00659	04		 DB	 4
  0065a	04		 DB	 4
  0065b	02		 DB	 2
  0065c	04		 DB	 4
  0065d	04		 DB	 4
  0065e	04		 DB	 4
  0065f	04		 DB	 4
  00660	03		 DB	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ReadFromArchive@DOTS_AND_BOXES@@AAE_NAAVarInput@@@Z$0:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d dc	 lea	 ecx, DWORD PTR _line$[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__unwindfunclet$?ReadFromArchive@DOTS_AND_BOXES@@AAE_NAAVarInput@@@Z$1:
  00012	8b f4		 mov	 esi, esp
  00014	8d 4d c4	 lea	 ecx, DWORD PTR $T10[ebp]
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0001d	3b f4		 cmp	 esi, esp
  0001f	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__unwindfunclet$?ReadFromArchive@DOTS_AND_BOXES@@AAE_NAAVarInput@@@Z$2:
  00024	8b f4		 mov	 esi, esp
  00026	8d 4d bc	 lea	 ecx, DWORD PTR $T6[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0002f	3b f4		 cmp	 esi, esp
  00031	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
  00036	cc		 int	 3
  00037	cc		 int	 3
  00038	cc		 int	 3
  00039	cc		 int	 3
  0003a	cc		 int	 3
__ehhandler$?ReadFromArchive@DOTS_AND_BOXES@@AAE_NAAVarInput@@@Z:
  0003b	90		 npad	 1
  0003c	90		 npad	 1
  0003d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00041	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00044	8b 4a 88	 mov	 ecx, DWORD PTR [edx-120]
  00047	33 c8		 xor	 ecx, eax
  00049	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ReadFromArchive@DOTS_AND_BOXES@@AAE_NAAVarInput@@@Z
  00053	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ReadFromArchive@DOTS_AND_BOXES@@AAE_NAAVarInput@@@Z ENDP ; DOTS_AND_BOXES::ReadFromArchive
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\工程之星点格棋\stdafx.h
;	COMDAT ??0VECTOR@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VECTOR@@QAE@XZ PROC					; VECTOR::VECTOR, COMDAT
; _this$ = ecx

; 61   :   VECTOR(void){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0VECTOR@@QAE@XZ ENDP					; VECTOR::VECTOR
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File G:\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\atlmfc\include\atltrace.h
;	COMDAT ?RegisterCategory@CTrace@ATL@@SAXPBDI@Z
_TEXT	SEGMENT
_buffer$ = -264						; size = 256
__$ArrayPad$ = -4					; size = 4
_pszCategory$ = 8					; size = 4
_nCategory$ = 12					; size = 4
?RegisterCategory@CTrace@ATL@@SAXPBDI@Z PROC		; ATL::CTrace::RegisterCategory, COMDAT

; 329  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  00011	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 330  : 		if (pszCategory == nullptr)

  00027	83 7d 08 00	 cmp	 DWORD PTR _pszCategory$[ebp], 0
  0002b	75 05		 jne	 SHORT $LN2@RegisterCa

; 331  : 		{
; 332  : 			return;

  0002d	e9 bb 00 00 00	 jmp	 $LN1@RegisterCa
$LN2@RegisterCa:

; 333  : 		}
; 334  : 
; 335  : 		if (m_nLastCategory >= MaxCategoryArray) 

  00032	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 32 ; ATL::CTrace::m_nLastCategory, 00000020H
  00039	72 36		 jb	 SHORT $LN3@RegisterCa

; 336  : 		{
; 337  : 			ATLASSERT(false && "Too many categories defined");

  0003b	33 c0		 xor	 eax, eax
  0003d	75 30		 jne	 SHORT $LN5@RegisterCa
  0003f	8b f4		 mov	 esi, esp
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm@
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs@
  0004b	6a 00		 push	 0
  0004d	68 51 01 00 00	 push	 337			; 00000151H
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_1LM@KONDCONO@?$AAG?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi@
  00057	6a 02		 push	 2
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0005f	83 c4 18	 add	 esp, 24			; 00000018H
  00062	3b f4		 cmp	 esi, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	83 f8 01	 cmp	 eax, 1
  0006c	75 01		 jne	 SHORT $LN5@RegisterCa
  0006e	cc		 int	 3
$LN5@RegisterCa:

; 338  : 			return;

  0006f	eb 7c		 jmp	 SHORT $LN1@RegisterCa
$LN3@RegisterCa:

; 339  : 		}
; 340  : 
; 341  : 		m_nMap[m_nLastCategory].nCategory = nCategory;

  00071	69 15 00 00 00
	00 04 01 00 00	 imul	 edx, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 260 ; ATL::CTrace::m_nLastCategory
  0007b	8b 45 0c	 mov	 eax, DWORD PTR _nCategory$[ebp]
  0007e	89 82 00 00 00
	00		 mov	 DWORD PTR ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A[edx], eax

; 342  : #ifdef _UNICODE
; 343  : 		wcscpy_s(m_nMap[m_nLastCategory].categryName, MaxLengthOfCategoryName - 1, pszCategory);
; 344  : #else
; 345  : 		wchar_t buffer[MaxLengthOfCategoryName] = { 0 };	

  00084	68 00 01 00 00	 push	 256			; 00000100H
  00089	6a 00		 push	 0
  0008b	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 _memset
  00097	83 c4 0c	 add	 esp, 12			; 0000000cH

; 346  : #if _MSC_VER < 1900
; 347  : 		swprintf_s(buffer, MaxLengthOfCategoryName - 1, L"%S", pszCategory);
; 348  : #else
; 349  : 		swprintf_s(buffer, MaxLengthOfCategoryName - 1, L"%hs", pszCategory);

  0009a	8b 55 08	 mov	 edx, DWORD PTR _pszCategory$[ebp]
  0009d	52		 push	 edx
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs@
  000a3	6a 7f		 push	 127			; 0000007fH
  000a5	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _swprintf_s
  000b1	83 c4 10	 add	 esp, 16			; 00000010H

; 350  : #endif
; 351  : 		wcscpy_s(m_nMap[m_nLastCategory].categryName, MaxLengthOfCategoryName - 1, buffer);

  000b4	8b f4		 mov	 esi, esp
  000b6	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  000bc	51		 push	 ecx
  000bd	6a 7f		 push	 127			; 0000007fH
  000bf	69 15 00 00 00
	00 04 01 00 00	 imul	 edx, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 260 ; ATL::CTrace::m_nLastCategory
  000c9	81 c2 04 00 00
	00		 add	 edx, OFFSET ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A+4
  000cf	52		 push	 edx
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcscpy_s
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d9	3b f4		 cmp	 esi, esp
  000db	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 352  : #endif
; 353  : 	
; 354  : 		m_nLastCategory++;

  000e0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA ; ATL::CTrace::m_nLastCategory
  000e5	83 c0 01	 add	 eax, 1
  000e8	a3 00 00 00 00	 mov	 DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, eax ; ATL::CTrace::m_nLastCategory
$LN1@RegisterCa:

; 355  : 	}

  000ed	52		 push	 edx
  000ee	8b cd		 mov	 ecx, ebp
  000f0	50		 push	 eax
  000f1	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@RegisterCa
  000f7	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000fc	58		 pop	 eax
  000fd	5a		 pop	 edx
  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00103	33 cd		 xor	 ecx, ebp
  00105	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010a	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  00110	3b ec		 cmp	 ebp, esp
  00112	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c3		 ret	 0
  0011b	90		 npad	 1
$LN8@RegisterCa:
  0011c	01 00 00 00	 DD	 1
  00120	00 00 00 00	 DD	 $LN7@RegisterCa
$LN7@RegisterCa:
  00124	f8 fe ff ff	 DD	 -264			; fffffef8H
  00128	00 01 00 00	 DD	 256			; 00000100H
  0012c	00 00 00 00	 DD	 $LN6@RegisterCa
$LN6@RegisterCa:
  00130	62		 DB	 98			; 00000062H
  00131	75		 DB	 117			; 00000075H
  00132	66		 DB	 102			; 00000066H
  00133	66		 DB	 102			; 00000066H
  00134	65		 DB	 101			; 00000065H
  00135	72		 DB	 114			; 00000072H
  00136	00		 DB	 0
?RegisterCategory@CTrace@ATL@@SAXPBDI@Z ENDP		; ATL::CTrace::RegisterCategory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File G:\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceException@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceException@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceException'', COMDAT

; 110  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceException> atlTraceException(_T("atlTraceException"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG74042
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
  00012	3b ec		 cmp	 ebp, esp
  00014	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??__EatlTraceException@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceException''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu
; File G:\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>, COMDAT
; _this$ = ecx

; 480  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 481  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  0000e	68 00 20 00 00	 push	 8192			; 00002000H
  00013	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPBDI@Z ; ATL::CTrace::RegisterCategory
  0001c	83 c4 08	 add	 esp, 8

; 482  : }

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	83 c4 04	 add	 esp, 4
  00025	3b ec		 cmp	 ebp, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_wstdio.h
;	COMDAT _swprintf_s
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_swprintf_s PROC					; COMDAT

; 1523 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1524 :             int _Result;
; 1525 :             va_list _ArgList;
; 1526 :             __crt_va_start(_ArgList, _Format);

  0001b	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0001e	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1527 :             _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00021	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  00024	51		 push	 ecx
  00025	6a 00		 push	 0
  00027	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  0002a	52		 push	 edx
  0002b	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 __vswprintf_s_l
  00038	83 c4 14	 add	 esp, 20			; 00000014H
  0003b	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1528 :             __crt_va_end(_ArgList);

  0003e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1529 :             return _Result;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1530 :         }

  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_swprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_wstdio.h
;	COMDAT __vswprintf_s_l
_TEXT	SEGMENT
tv73 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vswprintf_s_l PROC					; COMDAT

; 1256 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1257 :         int const _Result = __stdio_common_vswprintf_s(

  00015	8b f4		 mov	 esi, esp
  00017	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00022	52		 push	 edx
  00023	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00030	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00033	52		 push	 edx
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vswprintf_s
  0003d	83 c4 1c	 add	 esp, 28			; 0000001cH
  00040	3b f4		 cmp	 esi, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1258 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1259 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1260 : 
; 1261 :         return _Result < 0 ? -1 : _Result;

  0004a	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0004e	7d 09		 jge	 SHORT $LN3@vswprintf_
  00050	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv73[ebp], -1
  00057	eb 06		 jmp	 SHORT $LN4@vswprintf_
$LN3@vswprintf_:
  00059	8b 4d fc	 mov	 ecx, DWORD PTR __Result$[ebp]
  0005c	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
$LN4@vswprintf_:
  0005f	8b 45 f8	 mov	 eax, DWORD PTR tv73[ebp]

; 1262 :     }

  00062	5e		 pop	 esi
  00063	83 c4 08	 add	 esp, 8
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
__vswprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File D:\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\15485\Desktop\工程之星点格棋\DotBoxLib\DotsAndBoxes.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
